====================================
cd to out
"/home/vf/om/models/omni/test/out"
====================================
Setting ModelicaPath
true
====================================
Loading Modelica
true
====================================
Loading MbsLite
true
""
====================================
Loading MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest
true
""
====================================
Instantiating MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest
"function MbsLite.Examples.OmniVehicle.Initials \"Automatically generated record constructor for MbsLite.Examples.OmniVehicle.Initials\"
  input String name;
  input Real omega;
  input Real vAbs;
  input Real vDirAngle;
  input Real[3] vVec;
  input Real[3] omegaVec;
  output Initials res;
end MbsLite.Examples.OmniVehicle.Initials;

function MbsLite.Examples.OmniVehicle.Params \"Automatically generated record constructor for MbsLite.Examples.OmniVehicle.Params\"
  input String name;
  input Integer NWheels;
  input Integer nRollers;
  input Real mecanumAngle;
  input Real platformRadius;
  input Real wheelRadius;
  input Real platformMass;
  input Real wheelHubMass;
  input Real rollerMass;
  input Real rollerHalfAngle;
  input Real wheelHubRadius;
  input Real rollerRadius;
  input Real rollerLength;
  input Real platformAxialMoi;
  input Real platformOrthogonalMoi;
  input Real wheelHubAxialMoi;
  input Real wheelHubOrthogonalMoi;
  input Real rollerAxialMoi;
  input Real rollerOrthogonalMoi;
  output Params res;
end MbsLite.Examples.OmniVehicle.Params;

function MbsLite.Examples.OmniVehicle.Utils.CreateParams
  input String name;
  input Integer NWheels;
  input Integer nRollers;
  input Real mecanumAngle;
  input Real platformRadius;
  input Real wheelRadius;
  input Real platformMass;
  input Real wheelHubMass;
  input Real rollerMass;
  output MbsLite.Examples.OmniVehicle.Params params;
  protected Real rollerHalfAngle = 3.141592653589793 / /*Real*/(nRollers);
  protected Real wheelHubRadius = wheelRadius * cos(rollerHalfAngle);
  protected Real rollerLength = wheelRadius * sin(rollerHalfAngle);
  protected Real rollerRadius = 0.5 * (wheelRadius - wheelHubRadius);
algorithm
  params := MbsLite.Examples.OmniVehicle.Params(name, NWheels, nRollers, mecanumAngle, platformRadius, wheelRadius, platformMass, wheelHubMass, rollerMass, rollerHalfAngle, wheelHubRadius, rollerRadius, rollerLength, MbsLite.Util.MassGeometry.CylinderAxialMoi(platformMass, platformRadius), MbsLite.Util.MassGeometry.CylinderOrthogonalMoi(platformMass, platformRadius, 0.01), MbsLite.Util.MassGeometry.CylinderAxialMoi(wheelHubMass, wheelHubRadius), MbsLite.Util.MassGeometry.CylinderOrthogonalMoi(wheelHubMass, wheelHubRadius, 0.01), MbsLite.Util.MassGeometry.CylinderAxialMoi(rollerMass, rollerRadius), MbsLite.Util.MassGeometry.CylinderOrthogonalMoi(rollerMass, rollerRadius, rollerLength));
end MbsLite.Examples.OmniVehicle.Utils.CreateParams;

function MbsLite.Util.Asserts.AssertInitialized
  input String modelName;
  input Real[:] value;
  input String parameterName;
algorithm
  assert(max(value) < 9.999999999999999e+59, modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Asserts.AssertInitialized;

function MbsLite.Util.Asserts.AssertInitializedI
  input String modelName;
  input Integer value;
  input String parameterName;
algorithm
  assert(value > -4611686018427387903, modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Asserts.AssertInitializedI;

function MbsLite.Util.Asserts.AssertInitializedS
  input String modelName;
  input String value;
  input String parameterName;
algorithm
  assert(value <> \"NOT INITIALIZED\", modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Asserts.AssertInitializedS;

function MbsLite.Util.CompareReal
  input Real a;
  input Real b;
  input Real absTol = 1e-10 \"Absolute tolerance.\";
  input Real relTol = 1e-05 \"Relative tolerance.\";
  output Boolean equal;
  protected Real diff;
algorithm
  diff := abs(a - b);
  equal := diff < absTol or diff <= max(abs(b), abs(a)) * relTol;
end MbsLite.Util.CompareReal;

function MbsLite.Util.Euler \"Inline before index reduction\"
  input Real[3] origin;
  input Real[3] point;
  input Real[3] velocityOfOrigin;
  input Real[3] omega;
  output Real[3] velocityOfPoint;
algorithm
  velocityOfPoint := {velocityOfOrigin[1] + omega[2] * (point[3] - origin[3]) - omega[3] * (point[2] - origin[2]), velocityOfOrigin[2] + omega[3] * (point[1] - origin[1]) - omega[1] * (point[3] - origin[3]), velocityOfOrigin[3] + omega[1] * (point[2] - origin[2]) - omega[2] * (point[1] - origin[1])};
end MbsLite.Util.Euler;

function MbsLite.Util.MassGeometry.CylinderAxialMoi
  input Real m;
  input Real r;
  output Real axial;
algorithm
  axial := 0.5 * m * r ^ 2.0;
end MbsLite.Util.MassGeometry.CylinderAxialMoi;

function MbsLite.Util.MassGeometry.CylinderOrthogonalMoi
  input Real m;
  input Real r;
  input Real l;
  output Real orthogonal;
algorithm
  orthogonal := 0.08333333333333333 * m * (3.0 * r ^ 2.0 + l ^ 2.0);
end MbsLite.Util.MassGeometry.CylinderOrthogonalMoi;

function MbsLite.Util.Quaternions.QMult \"Inline before index reduction\"
  input Real[4] q1;
  input Real[4] q2;
  output Real[4] q3;
  protected Real a1;
  protected Real a2;
  protected Real[3] A1;
  protected Real[3] A2;
  protected Real[3] A3;
algorithm
  a1 := q1[1];
  a2 := q2[1];
  A1 := {q1[2], q1[3], q1[4]};
  A2 := {q2[2], q2[3], q2[4]};
  A3 := {A2[1] * a1 + A1[1] * a2 + A1[2] * A2[3] - A1[3] * A2[2], A2[2] * a1 + A1[2] * a2 + A1[3] * A2[1] - A1[1] * A2[3], A2[3] * a1 + A1[3] * a2 + A1[1] * A2[2] - A1[2] * A2[1]};
  q3 := {a1 * a2 + (-A1[2]) * A2[2] - A1[3] * A2[3] - A1[1] * A2[1], A3[1], A3[2], A3[3]};
end MbsLite.Util.Quaternions.QMult;

function MbsLite.Util.Quaternions.QRot \"Inline before index reduction\" \"quaternion of rotation by angle about axis CW+ looking along the axis\"
  input Real angle;
  input Real[3] axis;
  output Real[4] q;
  protected Real s;
algorithm
  s := sin(0.5 * angle);
  q := {cos(0.5 * angle), s * axis[1], s * axis[2], s * axis[3]};
end MbsLite.Util.Quaternions.QRot;

function MbsLite.Util.Quaternions.QToT \"Inline before index reduction\" \"Converts quaternion to Rotation matrix.\"
  input Real[4] q;
  output Real[3, 3] T;
algorithm
  T := {{(q[1] ^ 2.0 + q[2] ^ 2.0 + (-q[3] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[3] - q[1] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[4] + q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[1] * q[4] + q[2] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[3] ^ 2.0 + (-q[2] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[3] * q[4] - q[1] * q[2]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[2] * q[4] - q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[1] * q[2] + q[3] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[4] ^ 2.0 - q[3] ^ 2.0 - q[2] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}};
end MbsLite.Util.Quaternions.QToT;

function MbsLite.Util.StringA
  input Real[:] array;
  input String delim = \", \";
  output String render;
  protected String accumulator = \"\";
  protected Integer counter = 0;
algorithm
  for item in array loop
    accumulator := accumulator + String(item, 0, true, 6);
    counter := 1 + counter;
    if counter < size(array, 1) then
      accumulator := accumulator + delim;
    end if;
  end for;
  render := \"{ \" + accumulator + \" }\";
end MbsLite.Util.StringA;

class MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest
  constant String params.name = \"params used in the PMM paper\";
  constant Integer params.NWheels = 3;
  constant Integer params.nRollers = 5;
  constant Real params.mecanumAngle = 0.0;
  constant Real params.platformRadius = 0.15;
  constant Real params.wheelRadius = 0.05;
  constant Real params.platformMass = 1.0;
  constant Real params.wheelHubMass = 0.15;
  constant Real params.rollerMass = 0.05;
  constant Real params.rollerHalfAngle = 0.6283185307179586;
  constant Real params.wheelHubRadius = 0.04045084971874738;
  constant Real params.rollerRadius = 0.004774575140626312;
  constant Real params.rollerLength = 0.02938926261462366;
  constant Real params.platformAxialMoi = 0.01125;
  constant Real params.platformOrthogonalMoi = 0.005633333333333334;
  constant Real params.wheelHubAxialMoi = 0.0001227203432226514;
  constant Real params.wheelHubOrthogonalMoi = 6.261017161132568e-05;
  constant Real params.rollerAxialMoi = 5.699141943371693e-07;
  constant Real params.rollerOrthogonalMoi = 3.8838269181324e-06;
  constant String initials.name = \"wheel still\";
  constant Real initials.omega = 0.0;
  constant Real initials.vAbs = 0.0;
  constant Real initials.vDirAngle = 0.0 \"angle between inertial X axis and vehicle's X axis counter-clockwise-positive looking from the end of Z axis\";
  constant Real initials.vVec[1] = 0.0;
  constant Real initials.vVec[2] = 0.0;
  constant Real initials.vVec[3] = 0.0;
  constant Real initials.omegaVec[1] = 0.0;
  constant Real initials.omegaVec[2] = 0.0;
  constant Real initials.omegaVec[3] = 0.0;
  parameter String m.name = \"OmniWheelAtRest\";
  parameter Boolean m.strict = false;
  parameter Real m.Gravity[1] = -0.0;
  parameter Real m.Gravity[2] = -1.0;
  parameter Real m.Gravity[3] = -0.0;
  parameter Integer m.nActual = 5;
  parameter Real m.r0[1] = 0.0;
  parameter Real m.r0[2] = 0.05;
  parameter Real m.r0[3] = 0.0;
  parameter Real m.q0[1] = 1.0;
  parameter Real m.q0[2] = 0.0;
  parameter Real m.q0[3] = 0.0;
  parameter Real m.q0[4] = 0.0;
  parameter String m.params.name = \"params used in the PMM paper\";
  parameter Integer m.params.NWheels = 3;
  parameter Integer m.params.nRollers = 5;
  parameter Real m.params.mecanumAngle = 0.0;
  parameter Real m.params.platformRadius = 0.15;
  parameter Real m.params.wheelRadius = 0.05;
  parameter Real m.params.platformMass = 1.0;
  parameter Real m.params.wheelHubMass = 0.15;
  parameter Real m.params.rollerMass = 0.05;
  parameter Real m.params.rollerHalfAngle = 0.6283185307179586;
  parameter Real m.params.wheelHubRadius = 0.04045084971874738;
  parameter Real m.params.rollerRadius = 0.004774575140626312;
  parameter Real m.params.rollerLength = 0.02938926261462366;
  parameter Real m.params.platformAxialMoi = 0.01125;
  parameter Real m.params.platformOrthogonalMoi = 0.005633333333333334;
  parameter Real m.params.wheelHubAxialMoi = 0.0001227203432226514;
  parameter Real m.params.wheelHubOrthogonalMoi = 6.261017161132568e-05;
  parameter Real m.params.rollerAxialMoi = 5.699141943371693e-07;
  parameter Real m.params.rollerOrthogonalMoi = 3.8838269181324e-06;
  parameter String m.initials.name = \"wheel still\";
  parameter Real m.initials.omega = 0.0;
  parameter Real m.initials.vAbs = 0.0;
  parameter Real m.initials.vDirAngle = 0.0 \"angle between inertial X axis and vehicle's X axis counter-clockwise-positive looking from the end of Z axis\";
  parameter Real m.initials.vVec[1] = 0.0;
  parameter Real m.initials.vVec[2] = 0.0;
  parameter Real m.initials.vVec[3] = 0.0;
  parameter Real m.initials.omegaVec[1] = 0.0;
  parameter Real m.initials.omegaVec[2] = 0.0;
  parameter Real m.initials.omegaVec[3] = 0.0;
  Real m.base.OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.base.OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.base.OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.base.OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.base.OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.base.OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.base.OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.base.OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.base.OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.base.OutPort.T[1,1] \"Matrix of rotation\";
  Real m.base.OutPort.T[1,2] \"Matrix of rotation\";
  Real m.base.OutPort.T[1,3] \"Matrix of rotation\";
  Real m.base.OutPort.T[2,1] \"Matrix of rotation\";
  Real m.base.OutPort.T[2,2] \"Matrix of rotation\";
  Real m.base.OutPort.T[2,3] \"Matrix of rotation\";
  Real m.base.OutPort.T[3,1] \"Matrix of rotation\";
  Real m.base.OutPort.T[3,2] \"Matrix of rotation\";
  Real m.base.OutPort.T[3,3] \"Matrix of rotation\";
  Real m.base.OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.base.OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.base.OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.base.OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.base.OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.base.OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  constant Real m.wheel.rollerAxisLocal[1] = 1.0;
  constant Real m.wheel.rollerAxisLocal[2] = 0.0;
  constant Real m.wheel.rollerAxisLocal[3] = 0.0;
  constant Real m.wheel.wheelAxis[1] = 0.0;
  constant Real m.wheel.wheelAxis[2] = 0.0;
  constant Real m.wheel.wheelAxis[3] = 1.0;
  parameter String m.wheel.params.name = \"params used in the PMM paper\";
  parameter Integer m.wheel.params.NWheels = 3;
  parameter Integer m.wheel.params.nRollers = 5;
  parameter Real m.wheel.params.mecanumAngle = 0.0;
  parameter Real m.wheel.params.platformRadius = 0.15;
  parameter Real m.wheel.params.wheelRadius = 0.05;
  parameter Real m.wheel.params.platformMass = 1.0;
  parameter Real m.wheel.params.wheelHubMass = 0.15;
  parameter Real m.wheel.params.rollerMass = 0.05;
  parameter Real m.wheel.params.rollerHalfAngle = 0.6283185307179586;
  parameter Real m.wheel.params.wheelHubRadius = 0.04045084971874738;
  parameter Real m.wheel.params.rollerRadius = 0.004774575140626312;
  parameter Real m.wheel.params.rollerLength = 0.02938926261462366;
  parameter Real m.wheel.params.platformAxialMoi = 0.01125;
  parameter Real m.wheel.params.platformOrthogonalMoi = 0.005633333333333334;
  parameter Real m.wheel.params.wheelHubAxialMoi = 0.0001227203432226514;
  parameter Real m.wheel.params.wheelHubOrthogonalMoi = 6.261017161132568e-05;
  parameter Real m.wheel.params.rollerAxialMoi = 5.699141943371693e-07;
  parameter Real m.wheel.params.rollerOrthogonalMoi = 3.8838269181324e-06;
  parameter String m.wheel.initials.name = \"wheel still\";
  parameter Real m.wheel.initials.omega = 0.0;
  parameter Real m.wheel.initials.vAbs = 0.0;
  parameter Real m.wheel.initials.vDirAngle = 0.0 \"angle between inertial X axis and vehicle's X axis counter-clockwise-positive looking from the end of Z axis\";
  parameter Real m.wheel.initials.vVec[1] = 0.0;
  parameter Real m.wheel.initials.vVec[2] = 0.0;
  parameter Real m.wheel.initials.vVec[3] = 0.0;
  parameter Real m.wheel.initials.omegaVec[1] = 0.0;
  parameter Real m.wheel.initials.omegaVec[2] = 0.0;
  parameter Real m.wheel.initials.omegaVec[3] = 0.0;
  parameter String m.wheel.name = \"wheel\";
  parameter Integer m.wheel.nActual = 5 \"actual number of rollers on the wheel\";
  parameter Real m.wheel.Gravity[1] = -0.0;
  parameter Real m.wheel.Gravity[2] = -1.0;
  parameter Real m.wheel.Gravity[3] = -0.0;
  parameter Real m.wheel.r0[1] = 0.0;
  parameter Real m.wheel.r0[2] = 0.05;
  parameter Real m.wheel.r0[3] = 0.0;
  parameter Real m.wheel.q0[1] = 1.0;
  parameter Real m.wheel.q0[2] = 0.0;
  parameter Real m.wheel.q0[3] = 0.0;
  parameter Real m.wheel.q0[4] = 0.0;
  parameter Real m.wheel.T0[1,1] = 1.0;
  parameter Real m.wheel.T0[1,2] = 0.0;
  parameter Real m.wheel.T0[1,3] = 0.0;
  parameter Real m.wheel.T0[2,1] = 0.0;
  parameter Real m.wheel.T0[2,2] = 1.0;
  parameter Real m.wheel.T0[2,3] = 0.0;
  parameter Real m.wheel.T0[3,1] = 0.0;
  parameter Real m.wheel.T0[3,2] = 0.0;
  parameter Real m.wheel.T0[3,3] = 1.0;
  parameter Real m.wheel.RollerAngles[1] = 0.0 \"Angles between downward vertical { 0, -1, 0 } and roller center radius vectors\";
  parameter Real m.wheel.RollerAngles[2] = 1.256637061435917 \"Angles between downward vertical { 0, -1, 0 } and roller center radius vectors\";
  parameter Real m.wheel.RollerAngles[3] = 2.513274122871834 \"Angles between downward vertical { 0, -1, 0 } and roller center radius vectors\";
  parameter Real m.wheel.RollerAngles[4] = 3.769911184307752 \"Angles between downward vertical { 0, -1, 0 } and roller center radius vectors\";
  parameter Real m.wheel.RollerAngles[5] = 5.026548245743669 \"Angles between downward vertical { 0, -1, 0 } and roller center radius vectors\";
  parameter Real m.wheel.RollerQs[1,1] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(0.0, {0.0, 0.0, 1.0}))[1];
  parameter Real m.wheel.RollerQs[1,2] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(0.0, {0.0, 0.0, 1.0}))[2];
  parameter Real m.wheel.RollerQs[1,3] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(0.0, {0.0, 0.0, 1.0}))[3];
  parameter Real m.wheel.RollerQs[1,4] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(0.0, {0.0, 0.0, 1.0}))[4];
  parameter Real m.wheel.RollerQs[2,1] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(1.256637061435917, {0.0, 0.0, 1.0}))[1];
  parameter Real m.wheel.RollerQs[2,2] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(1.256637061435917, {0.0, 0.0, 1.0}))[2];
  parameter Real m.wheel.RollerQs[2,3] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(1.256637061435917, {0.0, 0.0, 1.0}))[3];
  parameter Real m.wheel.RollerQs[2,4] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(1.256637061435917, {0.0, 0.0, 1.0}))[4];
  parameter Real m.wheel.RollerQs[3,1] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(2.513274122871834, {0.0, 0.0, 1.0}))[1];
  parameter Real m.wheel.RollerQs[3,2] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(2.513274122871834, {0.0, 0.0, 1.0}))[2];
  parameter Real m.wheel.RollerQs[3,3] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(2.513274122871834, {0.0, 0.0, 1.0}))[3];
  parameter Real m.wheel.RollerQs[3,4] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(2.513274122871834, {0.0, 0.0, 1.0}))[4];
  parameter Real m.wheel.RollerQs[4,1] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(3.769911184307752, {0.0, 0.0, 1.0}))[1];
  parameter Real m.wheel.RollerQs[4,2] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(3.769911184307752, {0.0, 0.0, 1.0}))[2];
  parameter Real m.wheel.RollerQs[4,3] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(3.769911184307752, {0.0, 0.0, 1.0}))[3];
  parameter Real m.wheel.RollerQs[4,4] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(3.769911184307752, {0.0, 0.0, 1.0}))[4];
  parameter Real m.wheel.RollerQs[5,1] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(5.026548245743669, {0.0, 0.0, 1.0}))[1];
  parameter Real m.wheel.RollerQs[5,2] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(5.026548245743669, {0.0, 0.0, 1.0}))[2];
  parameter Real m.wheel.RollerQs[5,3] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(5.026548245743669, {0.0, 0.0, 1.0}))[3];
  parameter Real m.wheel.RollerQs[5,4] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(5.026548245743669, {0.0, 0.0, 1.0}))[4];
  parameter Real m.wheel.VerticalInRollersAxes[1,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {0.0, 1.0, 0.0})[1];
  parameter Real m.wheel.VerticalInRollersAxes[1,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {0.0, 1.0, 0.0})[2];
  parameter Real m.wheel.VerticalInRollersAxes[1,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {0.0, 1.0, 0.0})[3];
  parameter Real m.wheel.VerticalInRollersAxes[2,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {0.0, 1.0, 0.0})[1];
  parameter Real m.wheel.VerticalInRollersAxes[2,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {0.0, 1.0, 0.0})[2];
  parameter Real m.wheel.VerticalInRollersAxes[2,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {0.0, 1.0, 0.0})[3];
  parameter Real m.wheel.VerticalInRollersAxes[3,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[3,1], m.wheel.RollerQs[3,2], m.wheel.RollerQs[3,3], m.wheel.RollerQs[3,4]}) * {0.0, 1.0, 0.0})[1];
  parameter Real m.wheel.VerticalInRollersAxes[3,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[3,1], m.wheel.RollerQs[3,2], m.wheel.RollerQs[3,3], m.wheel.RollerQs[3,4]}) * {0.0, 1.0, 0.0})[2];
  parameter Real m.wheel.VerticalInRollersAxes[3,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[3,1], m.wheel.RollerQs[3,2], m.wheel.RollerQs[3,3], m.wheel.RollerQs[3,4]}) * {0.0, 1.0, 0.0})[3];
  parameter Real m.wheel.VerticalInRollersAxes[4,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[4,1], m.wheel.RollerQs[4,2], m.wheel.RollerQs[4,3], m.wheel.RollerQs[4,4]}) * {0.0, 1.0, 0.0})[1];
  parameter Real m.wheel.VerticalInRollersAxes[4,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[4,1], m.wheel.RollerQs[4,2], m.wheel.RollerQs[4,3], m.wheel.RollerQs[4,4]}) * {0.0, 1.0, 0.0})[2];
  parameter Real m.wheel.VerticalInRollersAxes[4,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[4,1], m.wheel.RollerQs[4,2], m.wheel.RollerQs[4,3], m.wheel.RollerQs[4,4]}) * {0.0, 1.0, 0.0})[3];
  parameter Real m.wheel.VerticalInRollersAxes[5,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[5,1], m.wheel.RollerQs[5,2], m.wheel.RollerQs[5,3], m.wheel.RollerQs[5,4]}) * {0.0, 1.0, 0.0})[1];
  parameter Real m.wheel.VerticalInRollersAxes[5,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[5,1], m.wheel.RollerQs[5,2], m.wheel.RollerQs[5,3], m.wheel.RollerQs[5,4]}) * {0.0, 1.0, 0.0})[2];
  parameter Real m.wheel.VerticalInRollersAxes[5,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[5,1], m.wheel.RollerQs[5,2], m.wheel.RollerQs[5,3], m.wheel.RollerQs[5,4]}) * {0.0, 1.0, 0.0})[3];
  parameter Real m.wheel.RollerCenterDirections[1,1] = -0.0;
  parameter Real m.wheel.RollerCenterDirections[1,2] = -1.0;
  parameter Real m.wheel.RollerCenterDirections[1,3] = -0.0;
  parameter Real m.wheel.RollerCenterDirections[2,1] = 0.9510565162951536;
  parameter Real m.wheel.RollerCenterDirections[2,2] = -0.3090169943749475;
  parameter Real m.wheel.RollerCenterDirections[2,3] = -0.0;
  parameter Real m.wheel.RollerCenterDirections[3,1] = 0.5877852522924732;
  parameter Real m.wheel.RollerCenterDirections[3,2] = 0.8090169943749475;
  parameter Real m.wheel.RollerCenterDirections[3,3] = -0.0;
  parameter Real m.wheel.RollerCenterDirections[4,1] = -0.587785252292473;
  parameter Real m.wheel.RollerCenterDirections[4,2] = 0.8090169943749476;
  parameter Real m.wheel.RollerCenterDirections[4,3] = -0.0;
  parameter Real m.wheel.RollerCenterDirections[5,1] = -0.9510565162951536;
  parameter Real m.wheel.RollerCenterDirections[5,2] = -0.3090169943749472;
  parameter Real m.wheel.RollerCenterDirections[5,3] = -0.0;
  parameter Real m.wheel.RollerAxisDirections[1,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {1.0, 0.0, 0.0})[1];
  parameter Real m.wheel.RollerAxisDirections[1,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {1.0, 0.0, 0.0})[2];
  parameter Real m.wheel.RollerAxisDirections[1,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {1.0, 0.0, 0.0})[3];
  parameter Real m.wheel.RollerAxisDirections[2,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {1.0, 0.0, 0.0})[1];
  parameter Real m.wheel.RollerAxisDirections[2,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {1.0, 0.0, 0.0})[2];
  parameter Real m.wheel.RollerAxisDirections[2,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {1.0, 0.0, 0.0})[3];
  parameter Real m.wheel.RollerAxisDirections[3,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[3,1], m.wheel.RollerQs[3,2], m.wheel.RollerQs[3,3], m.wheel.RollerQs[3,4]}) * {1.0, 0.0, 0.0})[1];
  parameter Real m.wheel.RollerAxisDirections[3,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[3,1], m.wheel.RollerQs[3,2], m.wheel.RollerQs[3,3], m.wheel.RollerQs[3,4]}) * {1.0, 0.0, 0.0})[2];
  parameter Real m.wheel.RollerAxisDirections[3,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[3,1], m.wheel.RollerQs[3,2], m.wheel.RollerQs[3,3], m.wheel.RollerQs[3,4]}) * {1.0, 0.0, 0.0})[3];
  parameter Real m.wheel.RollerAxisDirections[4,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[4,1], m.wheel.RollerQs[4,2], m.wheel.RollerQs[4,3], m.wheel.RollerQs[4,4]}) * {1.0, 0.0, 0.0})[1];
  parameter Real m.wheel.RollerAxisDirections[4,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[4,1], m.wheel.RollerQs[4,2], m.wheel.RollerQs[4,3], m.wheel.RollerQs[4,4]}) * {1.0, 0.0, 0.0})[2];
  parameter Real m.wheel.RollerAxisDirections[4,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[4,1], m.wheel.RollerQs[4,2], m.wheel.RollerQs[4,3], m.wheel.RollerQs[4,4]}) * {1.0, 0.0, 0.0})[3];
  parameter Real m.wheel.RollerAxisDirections[5,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[5,1], m.wheel.RollerQs[5,2], m.wheel.RollerQs[5,3], m.wheel.RollerQs[5,4]}) * {1.0, 0.0, 0.0})[1];
  parameter Real m.wheel.RollerAxisDirections[5,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[5,1], m.wheel.RollerQs[5,2], m.wheel.RollerQs[5,3], m.wheel.RollerQs[5,4]}) * {1.0, 0.0, 0.0})[2];
  parameter Real m.wheel.RollerAxisDirections[5,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[5,1], m.wheel.RollerQs[5,2], m.wheel.RollerQs[5,3], m.wheel.RollerQs[5,4]}) * {1.0, 0.0, 0.0})[3];
  parameter Real m.wheel.RollerCenters[1,1] = -0.0;
  parameter Real m.wheel.RollerCenters[1,2] = -0.04045084971874738;
  parameter Real m.wheel.RollerCenters[1,3] = -0.0;
  parameter Real m.wheel.RollerCenters[2,1] = 0.03847104421469068;
  parameter Real m.wheel.RollerCenters[2,2] = -0.0125;
  parameter Real m.wheel.RollerCenters[2,3] = -0.0;
  parameter Real m.wheel.RollerCenters[3,1] = 0.02377641290737885;
  parameter Real m.wheel.RollerCenters[3,2] = 0.03272542485937369;
  parameter Real m.wheel.RollerCenters[3,3] = -0.0;
  parameter Real m.wheel.RollerCenters[4,1] = -0.02377641290737884;
  parameter Real m.wheel.RollerCenters[4,2] = 0.0327254248593737;
  parameter Real m.wheel.RollerCenters[4,3] = -0.0;
  parameter Real m.wheel.RollerCenters[5,1] = -0.03847104421469068;
  parameter Real m.wheel.RollerCenters[5,2] = -0.01249999999999999;
  parameter Real m.wheel.RollerCenters[5,3] = -0.0;
  Real m.wheel.Rollers[1].OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[1].OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[1].OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[1].OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Rollers[1].name = \"wheel.Rollers[1]\";
  parameter Real m.wheel.Rollers[1].m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.05 \"Mass of the body\";
  parameter Real m.wheel.Rollers[1].I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 5.699141943371693e-07 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  Real m.wheel.Rollers[1].r[1](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[1,1]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[1].r[2](quantity = \"Length\", unit = \"m\", start = 0.05 + m.wheel.RollerCenters[1,2]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[1].r[3](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[1,3]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[1].v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].q[1](start = m.wheel.RollerQs[1,1]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[1].q[2](start = m.wheel.RollerQs[1,2]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[1].q[3](start = m.wheel.RollerQs[1,3]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[1].q[4](start = m.wheel.RollerQs[1,4]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[1].omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[1].omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[1].omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[1].epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].F[1](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[1].F[2](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[1].F[3](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[1].M[1](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[1].M[2](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[1].M[3](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[1].T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Rollers[1].N = 2;
  parameter Real m.wheel.Rollers[1].Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  parameter Real m.wheel.Rollers[1].Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Rollers[1].Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  Real m.wheel.Rollers[1].InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].crosses[1,1];
  Real m.wheel.Rollers[1].crosses[1,2];
  Real m.wheel.Rollers[1].crosses[1,3];
  Real m.wheel.Rollers[1].crosses[2,1];
  Real m.wheel.Rollers[1].crosses[2,2];
  Real m.wheel.Rollers[1].crosses[2,3];
  Real m.wheel.Rollers[2].OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[2].OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[2].OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[2].OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Rollers[2].name = \"wheel.Rollers[2]\";
  parameter Real m.wheel.Rollers[2].m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.05 \"Mass of the body\";
  parameter Real m.wheel.Rollers[2].I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 5.699141943371693e-07 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  Real m.wheel.Rollers[2].r[1](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[2,1]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[2].r[2](quantity = \"Length\", unit = \"m\", start = 0.05 + m.wheel.RollerCenters[2,2]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[2].r[3](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[2,3]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[2].v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].q[1](start = m.wheel.RollerQs[2,1]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[2].q[2](start = m.wheel.RollerQs[2,2]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[2].q[3](start = m.wheel.RollerQs[2,3]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[2].q[4](start = m.wheel.RollerQs[2,4]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[2].omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[2].omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[2].omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[2].epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].F[1](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[2].F[2](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[2].F[3](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[2].M[1](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[2].M[2](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[2].M[3](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[2].T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Rollers[2].N = 2;
  parameter Real m.wheel.Rollers[2].Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  parameter Real m.wheel.Rollers[2].Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Rollers[2].Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  Real m.wheel.Rollers[2].InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].crosses[1,1];
  Real m.wheel.Rollers[2].crosses[1,2];
  Real m.wheel.Rollers[2].crosses[1,3];
  Real m.wheel.Rollers[2].crosses[2,1];
  Real m.wheel.Rollers[2].crosses[2,2];
  Real m.wheel.Rollers[2].crosses[2,3];
  Real m.wheel.Rollers[3].OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[3].OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[3].OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[3].OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[3].OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[3].OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[3].OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[3].OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Rollers[3].name = \"wheel.Rollers[3]\";
  parameter Real m.wheel.Rollers[3].m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.05 \"Mass of the body\";
  parameter Real m.wheel.Rollers[3].I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 5.699141943371693e-07 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[3].I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[3].I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[3].I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[3].I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[3].I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[3].I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[3].I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[3].I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  Real m.wheel.Rollers[3].r[1](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[3,1]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[3].r[2](quantity = \"Length\", unit = \"m\", start = 0.05 + m.wheel.RollerCenters[3,2]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[3].r[3](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[3,3]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[3].v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[3].v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[3].v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[3].a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[3].a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[3].a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[3].q[1](start = m.wheel.RollerQs[3,1]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[3].q[2](start = m.wheel.RollerQs[3,2]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[3].q[3](start = m.wheel.RollerQs[3,3]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[3].q[4](start = m.wheel.RollerQs[3,4]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[3].omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[3].omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[3].omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[3].epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[3].epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[3].epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[3].F[1](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[3].F[2](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[3].F[3](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[3].M[1](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[3].M[2](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[3].M[3](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[3].T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[3].Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Rollers[3].N = 2;
  parameter Real m.wheel.Rollers[3].Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  parameter Real m.wheel.Rollers[3].Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Rollers[3].Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  Real m.wheel.Rollers[3].InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[3].InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[3].InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[3].InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[3].InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[3].InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[3].InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[3].InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[3].InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[3].InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[3].InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[3].InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[3].InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[3].InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[3].InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[3].InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[3].InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[3].InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[3].crosses[1,1];
  Real m.wheel.Rollers[3].crosses[1,2];
  Real m.wheel.Rollers[3].crosses[1,3];
  Real m.wheel.Rollers[3].crosses[2,1];
  Real m.wheel.Rollers[3].crosses[2,2];
  Real m.wheel.Rollers[3].crosses[2,3];
  Real m.wheel.Rollers[4].OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[4].OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[4].OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[4].OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[4].OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[4].OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[4].OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[4].OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Rollers[4].name = \"wheel.Rollers[4]\";
  parameter Real m.wheel.Rollers[4].m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.05 \"Mass of the body\";
  parameter Real m.wheel.Rollers[4].I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 5.699141943371693e-07 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[4].I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[4].I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[4].I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[4].I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[4].I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[4].I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[4].I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[4].I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  Real m.wheel.Rollers[4].r[1](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[4,1]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[4].r[2](quantity = \"Length\", unit = \"m\", start = 0.05 + m.wheel.RollerCenters[4,2]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[4].r[3](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[4,3]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[4].v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[4].v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[4].v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[4].a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[4].a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[4].a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[4].q[1](start = m.wheel.RollerQs[4,1]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[4].q[2](start = m.wheel.RollerQs[4,2]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[4].q[3](start = m.wheel.RollerQs[4,3]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[4].q[4](start = m.wheel.RollerQs[4,4]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[4].omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[4].omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[4].omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[4].epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[4].epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[4].epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[4].F[1](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[4].F[2](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[4].F[3](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[4].M[1](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[4].M[2](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[4].M[3](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[4].T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[4].Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Rollers[4].N = 2;
  parameter Real m.wheel.Rollers[4].Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  parameter Real m.wheel.Rollers[4].Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Rollers[4].Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  Real m.wheel.Rollers[4].InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[4].InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[4].InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[4].InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[4].InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[4].InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[4].InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[4].InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[4].InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[4].InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[4].InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[4].InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[4].InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[4].InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[4].InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[4].InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[4].InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[4].InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[4].crosses[1,1];
  Real m.wheel.Rollers[4].crosses[1,2];
  Real m.wheel.Rollers[4].crosses[1,3];
  Real m.wheel.Rollers[4].crosses[2,1];
  Real m.wheel.Rollers[4].crosses[2,2];
  Real m.wheel.Rollers[4].crosses[2,3];
  Real m.wheel.Rollers[5].OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[5].OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[5].OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[5].OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[5].OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[5].OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[5].OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[5].OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Rollers[5].name = \"wheel.Rollers[5]\";
  parameter Real m.wheel.Rollers[5].m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.05 \"Mass of the body\";
  parameter Real m.wheel.Rollers[5].I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 5.699141943371693e-07 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[5].I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[5].I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[5].I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[5].I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[5].I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[5].I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[5].I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[5].I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 3.8838269181324e-06 \"Central tensor of inertia of the body\";
  Real m.wheel.Rollers[5].r[1](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[5,1]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[5].r[2](quantity = \"Length\", unit = \"m\", start = 0.05 + m.wheel.RollerCenters[5,2]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[5].r[3](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[5,3]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[5].v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[5].v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[5].v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[5].a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[5].a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[5].a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[5].q[1](start = m.wheel.RollerQs[5,1]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[5].q[2](start = m.wheel.RollerQs[5,2]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[5].q[3](start = m.wheel.RollerQs[5,3]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[5].q[4](start = m.wheel.RollerQs[5,4]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[5].omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[5].omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[5].omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[5].epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[5].epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[5].epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[5].F[1](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[5].F[2](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[5].F[3](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Rollers[5].M[1](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[5].M[2](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[5].M[3](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Rollers[5].T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[5].Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Rollers[5].N = 2;
  parameter Real m.wheel.Rollers[5].Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  parameter Real m.wheel.Rollers[5].Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Rollers[5].Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  Real m.wheel.Rollers[5].InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[5].InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[5].InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[5].InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[5].InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[5].InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[5].InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[5].InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[5].InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[5].InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[5].InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[5].InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[5].InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[5].InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[5].InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[5].InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[5].InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[5].InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[5].crosses[1,1];
  Real m.wheel.Rollers[5].crosses[1,2];
  Real m.wheel.Rollers[5].crosses[1,3];
  Real m.wheel.Rollers[5].crosses[2,1];
  Real m.wheel.Rollers[5].crosses[2,2];
  Real m.wheel.Rollers[5].crosses[2,3];
  parameter Integer m.wheel.Joints[1].ConstraintNo = 1;
  Real m.wheel.Joints[1].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Joints[1].name = \"joint1\";
  parameter Real m.wheel.Joints[1].nA[1] = 1.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[1].nA[2] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[1].nA[3] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[1].nB[1] = 1.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[1].nB[2] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[1].nB[3] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[1].rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[1].rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[1].rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[1].rB[1](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[1].rB[2](quantity = \"Length\", unit = \"m\") = -0.04045084971874738 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[1].rB[3](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  Real m.wheel.Joints[1].RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[1].RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[1].RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[1].RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[1].RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[1].RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[1].vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[1].vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[1].vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[1].vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[1].vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[1].vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[1].lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real m.wheel.Joints[1].mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real m.wheel.Joints[1].angle \"Relative angle. Beware numerical error accumulation!\";
  Real m.wheel.Joints[1].epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[1].epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[1].epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[1].nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[1].nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[1].nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[1].nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[1].nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[1].nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[1].M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
  parameter Integer m.wheel.Joints[2].ConstraintNo = 1;
  Real m.wheel.Joints[2].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Joints[2].name = \"joint2\";
  parameter Real m.wheel.Joints[2].nA[1] = 1.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[2].nA[2] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[2].nA[3] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[2].nB[1] = 0.3090169943749475 \"Axis in body B local\";
  parameter Real m.wheel.Joints[2].nB[2] = 0.9510565162951536 \"Axis in body B local\";
  parameter Real m.wheel.Joints[2].nB[3] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[2].rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[2].rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[2].rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[2].rB[1](quantity = \"Length\", unit = \"m\") = 0.03847104421469068 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[2].rB[2](quantity = \"Length\", unit = \"m\") = -0.0125 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[2].rB[3](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  Real m.wheel.Joints[2].RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[2].RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[2].RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[2].RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[2].RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[2].RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[2].vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[2].vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[2].vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[2].vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[2].vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[2].vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[2].lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real m.wheel.Joints[2].mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real m.wheel.Joints[2].angle \"Relative angle. Beware numerical error accumulation!\";
  Real m.wheel.Joints[2].epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[2].epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[2].epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[2].nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[2].nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[2].nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[2].nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[2].nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[2].nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[2].M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
  parameter Integer m.wheel.Joints[3].ConstraintNo = 1;
  Real m.wheel.Joints[3].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[3].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[3].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[3].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[3].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[3].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[3].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[3].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[3].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[3].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[3].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[3].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[3].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[3].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[3].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[3].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[3].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[3].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[3].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[3].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[3].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[3].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[3].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[3].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[3].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[3].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[3].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[3].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[3].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[3].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[3].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[3].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[3].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Joints[3].name = \"joint3\";
  parameter Real m.wheel.Joints[3].nA[1] = 1.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[3].nA[2] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[3].nA[3] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[3].nB[1] = -0.8090169943749475 \"Axis in body B local\";
  parameter Real m.wheel.Joints[3].nB[2] = 0.5877852522924732 \"Axis in body B local\";
  parameter Real m.wheel.Joints[3].nB[3] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[3].rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[3].rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[3].rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[3].rB[1](quantity = \"Length\", unit = \"m\") = 0.02377641290737885 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[3].rB[2](quantity = \"Length\", unit = \"m\") = 0.03272542485937369 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[3].rB[3](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  Real m.wheel.Joints[3].RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[3].RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[3].RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[3].RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[3].RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[3].RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[3].vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[3].vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[3].vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[3].vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[3].vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[3].vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[3].lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real m.wheel.Joints[3].mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real m.wheel.Joints[3].angle \"Relative angle. Beware numerical error accumulation!\";
  Real m.wheel.Joints[3].epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[3].epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[3].epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[3].nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[3].nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[3].nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[3].nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[3].nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[3].nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[3].M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
  parameter Integer m.wheel.Joints[4].ConstraintNo = 1;
  Real m.wheel.Joints[4].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[4].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[4].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[4].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[4].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[4].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[4].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[4].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[4].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[4].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[4].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[4].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[4].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[4].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[4].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[4].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[4].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[4].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[4].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[4].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[4].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[4].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[4].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[4].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[4].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[4].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[4].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[4].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[4].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[4].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[4].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[4].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[4].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Joints[4].name = \"joint4\";
  parameter Real m.wheel.Joints[4].nA[1] = 1.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[4].nA[2] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[4].nA[3] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[4].nB[1] = -0.8090169943749476 \"Axis in body B local\";
  parameter Real m.wheel.Joints[4].nB[2] = -0.587785252292473 \"Axis in body B local\";
  parameter Real m.wheel.Joints[4].nB[3] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[4].rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[4].rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[4].rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[4].rB[1](quantity = \"Length\", unit = \"m\") = -0.02377641290737884 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[4].rB[2](quantity = \"Length\", unit = \"m\") = 0.0327254248593737 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[4].rB[3](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  Real m.wheel.Joints[4].RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[4].RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[4].RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[4].RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[4].RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[4].RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[4].vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[4].vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[4].vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[4].vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[4].vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[4].vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[4].lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real m.wheel.Joints[4].mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real m.wheel.Joints[4].angle \"Relative angle. Beware numerical error accumulation!\";
  Real m.wheel.Joints[4].epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[4].epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[4].epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[4].nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[4].nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[4].nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[4].nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[4].nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[4].nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[4].M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
  parameter Integer m.wheel.Joints[5].ConstraintNo = 1;
  Real m.wheel.Joints[5].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[5].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[5].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[5].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[5].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[5].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[5].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[5].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[5].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[5].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[5].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[5].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[5].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[5].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[5].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[5].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[5].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[5].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[5].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[5].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[5].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[5].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[5].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[5].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[5].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[5].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[5].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[5].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[5].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[5].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[5].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[5].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[5].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Joints[5].name = \"joint5\";
  parameter Real m.wheel.Joints[5].nA[1] = 1.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[5].nA[2] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[5].nA[3] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[5].nB[1] = 0.3090169943749472 \"Axis in body B local\";
  parameter Real m.wheel.Joints[5].nB[2] = -0.9510565162951536 \"Axis in body B local\";
  parameter Real m.wheel.Joints[5].nB[3] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[5].rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[5].rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[5].rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[5].rB[1](quantity = \"Length\", unit = \"m\") = -0.03847104421469068 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[5].rB[2](quantity = \"Length\", unit = \"m\") = -0.01249999999999999 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[5].rB[3](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  Real m.wheel.Joints[5].RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[5].RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[5].RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[5].RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[5].RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[5].RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[5].vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[5].vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[5].vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[5].vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[5].vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[5].vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[5].lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real m.wheel.Joints[5].mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real m.wheel.Joints[5].angle \"Relative angle. Beware numerical error accumulation!\";
  Real m.wheel.Joints[5].epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[5].epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[5].epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[5].nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[5].nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[5].nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[5].nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[5].nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[5].nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[5].M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
  Real m.wheel.Wheel.OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Wheel.OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Wheel.OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Wheel.OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Wheel.OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Wheel.OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Wheel.OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Wheel.name = \"wheel hub\";
  parameter Real m.wheel.Wheel.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.15 \"Mass of the body\";
  parameter Real m.wheel.Wheel.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 6.261017161132568e-05 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 6.261017161132568e-05 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0001227203432226514 \"Central tensor of inertia of the body\";
  Real m.wheel.Wheel.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Wheel.r[2](quantity = \"Length\", unit = \"m\", start = 0.05) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Wheel.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Wheel.v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.q[1](start = 1.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Wheel.q[2](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Wheel.q[3](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Wheel.q[4](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Wheel.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Wheel.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Wheel.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Wheel.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.F[1](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Wheel.F[2](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Wheel.F[3](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real m.wheel.Wheel.M[1](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Wheel.M[2](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Wheel.M[3](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real m.wheel.Wheel.T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Wheel.N = 6;
  parameter Real m.wheel.Wheel.Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  parameter Real m.wheel.Wheel.Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Wheel.Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  Real m.wheel.Wheel.InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[3].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[3].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[3].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[3].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[3].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[3].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[3].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[3].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[3].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[4].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[4].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[4].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[4].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[4].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[4].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[4].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[4].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[4].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[5].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[5].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[5].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[5].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[5].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[5].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[5].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[5].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[5].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[6].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[6].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[6].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[6].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[6].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[6].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[6].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[6].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[6].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.crosses[1,1];
  Real m.wheel.Wheel.crosses[1,2];
  Real m.wheel.Wheel.crosses[1,3];
  Real m.wheel.Wheel.crosses[2,1];
  Real m.wheel.Wheel.crosses[2,2];
  Real m.wheel.Wheel.crosses[2,3];
  Real m.wheel.Wheel.crosses[3,1];
  Real m.wheel.Wheel.crosses[3,2];
  Real m.wheel.Wheel.crosses[3,3];
  Real m.wheel.Wheel.crosses[4,1];
  Real m.wheel.Wheel.crosses[4,2];
  Real m.wheel.Wheel.crosses[4,3];
  Real m.wheel.Wheel.crosses[5,1];
  Real m.wheel.Wheel.crosses[5,2];
  Real m.wheel.Wheel.crosses[5,3];
  Real m.wheel.Wheel.crosses[6,1];
  Real m.wheel.Wheel.crosses[6,2];
  Real m.wheel.Wheel.crosses[6,3];
  Real m.wheel.InPortF.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.InPortF.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.InPortF.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.InPortF.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.InPortF.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.InPortF.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.InPortF.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.InPortF.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.InPortF.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.OutPortK.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.OutPortK.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.OutPortK.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.OutPortK.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.OutPortK.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.OutPortK.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.OutPortK.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.OutPortK.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.OutPortK.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.OutPortK.T[1,1] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[1,2] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[1,3] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[2,1] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[2,2] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[2,3] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[3,1] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[3,2] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[3,3] \"Matrix of rotation\";
  Real m.wheel.OutPortK.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.OutPortK.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.OutPortK.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.OutPortK.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.OutPortK.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.OutPortK.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter Integer m.contacts[1].ConstraintNo = 1;
  Real m.contacts[1].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[1].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[1].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[1].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[1].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[1].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[1].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[1].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[1].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[1].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.contacts[1].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[1].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[1].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[1].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[1].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[1].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[1].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[1].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[1].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[1].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[1].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[1].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[1].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[1].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[1].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[1].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[1].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[1].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[1].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[1].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[1].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[1].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[1].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[1].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[1].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.contacts[1].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[1].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[1].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[1].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[1].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[1].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[1].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[1].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[1].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[1].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[1].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[1].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[1].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[1].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[1].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.contacts[1].params.name = \"params used in the PMM paper\";
  parameter Integer m.contacts[1].params.NWheels = 3;
  parameter Integer m.contacts[1].params.nRollers = 5;
  parameter Real m.contacts[1].params.mecanumAngle = 0.0;
  parameter Real m.contacts[1].params.platformRadius = 0.15;
  parameter Real m.contacts[1].params.wheelRadius = 0.05;
  parameter Real m.contacts[1].params.platformMass = 1.0;
  parameter Real m.contacts[1].params.wheelHubMass = 0.15;
  parameter Real m.contacts[1].params.rollerMass = 0.05;
  parameter Real m.contacts[1].params.rollerHalfAngle = 0.6283185307179586;
  parameter Real m.contacts[1].params.wheelHubRadius = 0.04045084971874738;
  parameter Real m.contacts[1].params.rollerRadius = 0.004774575140626312;
  parameter Real m.contacts[1].params.rollerLength = 0.02938926261462366;
  parameter Real m.contacts[1].params.platformAxialMoi = 0.01125;
  parameter Real m.contacts[1].params.platformOrthogonalMoi = 0.005633333333333334;
  parameter Real m.contacts[1].params.wheelHubAxialMoi = 0.0001227203432226514;
  parameter Real m.contacts[1].params.wheelHubOrthogonalMoi = 6.261017161132568e-05;
  parameter Real m.contacts[1].params.rollerAxialMoi = 5.699141943371693e-07;
  parameter Real m.contacts[1].params.rollerOrthogonalMoi = 3.8838269181324e-06;
  protected Real m.contacts[1].contactPointCoords[1];
  protected Real m.contacts[1].contactPointCoords[2];
  protected Real m.contacts[1].contactPointCoords[3];
  protected Real m.contacts[1].contactPointVelocity[1];
  protected Real m.contacts[1].contactPointVelocity[2];
  protected Real m.contacts[1].contactPointVelocity[3];
  protected Real m.contacts[1].cosBetweenRollerVerticalAndGlobalVertical;
  protected Boolean m.contacts[1].isInContact;
  parameter Integer m.contacts[2].ConstraintNo = 1;
  Real m.contacts[2].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[2].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[2].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[2].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[2].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[2].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[2].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[2].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[2].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[2].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.contacts[2].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[2].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[2].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[2].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[2].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[2].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[2].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[2].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[2].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[2].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[2].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[2].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[2].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[2].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[2].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[2].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[2].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[2].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[2].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[2].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[2].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[2].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[2].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[2].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[2].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.contacts[2].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[2].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[2].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[2].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[2].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[2].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[2].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[2].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[2].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[2].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[2].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[2].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[2].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[2].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[2].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.contacts[2].params.name = \"params used in the PMM paper\";
  parameter Integer m.contacts[2].params.NWheels = 3;
  parameter Integer m.contacts[2].params.nRollers = 5;
  parameter Real m.contacts[2].params.mecanumAngle = 0.0;
  parameter Real m.contacts[2].params.platformRadius = 0.15;
  parameter Real m.contacts[2].params.wheelRadius = 0.05;
  parameter Real m.contacts[2].params.platformMass = 1.0;
  parameter Real m.contacts[2].params.wheelHubMass = 0.15;
  parameter Real m.contacts[2].params.rollerMass = 0.05;
  parameter Real m.contacts[2].params.rollerHalfAngle = 0.6283185307179586;
  parameter Real m.contacts[2].params.wheelHubRadius = 0.04045084971874738;
  parameter Real m.contacts[2].params.rollerRadius = 0.004774575140626312;
  parameter Real m.contacts[2].params.rollerLength = 0.02938926261462366;
  parameter Real m.contacts[2].params.platformAxialMoi = 0.01125;
  parameter Real m.contacts[2].params.platformOrthogonalMoi = 0.005633333333333334;
  parameter Real m.contacts[2].params.wheelHubAxialMoi = 0.0001227203432226514;
  parameter Real m.contacts[2].params.wheelHubOrthogonalMoi = 6.261017161132568e-05;
  parameter Real m.contacts[2].params.rollerAxialMoi = 5.699141943371693e-07;
  parameter Real m.contacts[2].params.rollerOrthogonalMoi = 3.8838269181324e-06;
  protected Real m.contacts[2].contactPointCoords[1];
  protected Real m.contacts[2].contactPointCoords[2];
  protected Real m.contacts[2].contactPointCoords[3];
  protected Real m.contacts[2].contactPointVelocity[1];
  protected Real m.contacts[2].contactPointVelocity[2];
  protected Real m.contacts[2].contactPointVelocity[3];
  protected Real m.contacts[2].cosBetweenRollerVerticalAndGlobalVertical;
  protected Boolean m.contacts[2].isInContact;
  parameter Integer m.contacts[3].ConstraintNo = 1;
  Real m.contacts[3].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[3].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[3].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[3].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[3].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[3].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[3].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[3].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[3].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[3].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.contacts[3].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[3].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[3].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[3].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[3].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[3].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[3].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[3].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[3].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[3].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[3].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[3].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[3].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[3].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[3].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[3].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[3].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[3].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[3].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[3].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[3].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[3].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[3].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[3].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[3].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.contacts[3].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[3].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[3].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[3].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[3].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[3].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[3].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[3].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[3].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[3].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[3].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[3].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[3].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[3].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[3].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.contacts[3].params.name = \"params used in the PMM paper\";
  parameter Integer m.contacts[3].params.NWheels = 3;
  parameter Integer m.contacts[3].params.nRollers = 5;
  parameter Real m.contacts[3].params.mecanumAngle = 0.0;
  parameter Real m.contacts[3].params.platformRadius = 0.15;
  parameter Real m.contacts[3].params.wheelRadius = 0.05;
  parameter Real m.contacts[3].params.platformMass = 1.0;
  parameter Real m.contacts[3].params.wheelHubMass = 0.15;
  parameter Real m.contacts[3].params.rollerMass = 0.05;
  parameter Real m.contacts[3].params.rollerHalfAngle = 0.6283185307179586;
  parameter Real m.contacts[3].params.wheelHubRadius = 0.04045084971874738;
  parameter Real m.contacts[3].params.rollerRadius = 0.004774575140626312;
  parameter Real m.contacts[3].params.rollerLength = 0.02938926261462366;
  parameter Real m.contacts[3].params.platformAxialMoi = 0.01125;
  parameter Real m.contacts[3].params.platformOrthogonalMoi = 0.005633333333333334;
  parameter Real m.contacts[3].params.wheelHubAxialMoi = 0.0001227203432226514;
  parameter Real m.contacts[3].params.wheelHubOrthogonalMoi = 6.261017161132568e-05;
  parameter Real m.contacts[3].params.rollerAxialMoi = 5.699141943371693e-07;
  parameter Real m.contacts[3].params.rollerOrthogonalMoi = 3.8838269181324e-06;
  protected Real m.contacts[3].contactPointCoords[1];
  protected Real m.contacts[3].contactPointCoords[2];
  protected Real m.contacts[3].contactPointCoords[3];
  protected Real m.contacts[3].contactPointVelocity[1];
  protected Real m.contacts[3].contactPointVelocity[2];
  protected Real m.contacts[3].contactPointVelocity[3];
  protected Real m.contacts[3].cosBetweenRollerVerticalAndGlobalVertical;
  protected Boolean m.contacts[3].isInContact;
  parameter Integer m.contacts[4].ConstraintNo = 1;
  Real m.contacts[4].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[4].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[4].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[4].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[4].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[4].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[4].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[4].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[4].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[4].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.contacts[4].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[4].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[4].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[4].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[4].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[4].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[4].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[4].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[4].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[4].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[4].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[4].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[4].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[4].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[4].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[4].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[4].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[4].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[4].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[4].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[4].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[4].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[4].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[4].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[4].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.contacts[4].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[4].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[4].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[4].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[4].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[4].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[4].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[4].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[4].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[4].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[4].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[4].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[4].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[4].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[4].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.contacts[4].params.name = \"params used in the PMM paper\";
  parameter Integer m.contacts[4].params.NWheels = 3;
  parameter Integer m.contacts[4].params.nRollers = 5;
  parameter Real m.contacts[4].params.mecanumAngle = 0.0;
  parameter Real m.contacts[4].params.platformRadius = 0.15;
  parameter Real m.contacts[4].params.wheelRadius = 0.05;
  parameter Real m.contacts[4].params.platformMass = 1.0;
  parameter Real m.contacts[4].params.wheelHubMass = 0.15;
  parameter Real m.contacts[4].params.rollerMass = 0.05;
  parameter Real m.contacts[4].params.rollerHalfAngle = 0.6283185307179586;
  parameter Real m.contacts[4].params.wheelHubRadius = 0.04045084971874738;
  parameter Real m.contacts[4].params.rollerRadius = 0.004774575140626312;
  parameter Real m.contacts[4].params.rollerLength = 0.02938926261462366;
  parameter Real m.contacts[4].params.platformAxialMoi = 0.01125;
  parameter Real m.contacts[4].params.platformOrthogonalMoi = 0.005633333333333334;
  parameter Real m.contacts[4].params.wheelHubAxialMoi = 0.0001227203432226514;
  parameter Real m.contacts[4].params.wheelHubOrthogonalMoi = 6.261017161132568e-05;
  parameter Real m.contacts[4].params.rollerAxialMoi = 5.699141943371693e-07;
  parameter Real m.contacts[4].params.rollerOrthogonalMoi = 3.8838269181324e-06;
  protected Real m.contacts[4].contactPointCoords[1];
  protected Real m.contacts[4].contactPointCoords[2];
  protected Real m.contacts[4].contactPointCoords[3];
  protected Real m.contacts[4].contactPointVelocity[1];
  protected Real m.contacts[4].contactPointVelocity[2];
  protected Real m.contacts[4].contactPointVelocity[3];
  protected Real m.contacts[4].cosBetweenRollerVerticalAndGlobalVertical;
  protected Boolean m.contacts[4].isInContact;
  parameter Integer m.contacts[5].ConstraintNo = 1;
  Real m.contacts[5].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[5].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[5].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[5].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[5].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[5].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[5].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[5].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[5].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[5].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.contacts[5].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[5].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[5].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[5].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[5].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[5].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[5].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[5].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[5].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[5].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[5].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[5].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[5].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[5].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[5].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[5].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[5].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[5].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.contacts[5].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[5].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[5].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.contacts[5].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[5].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[5].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.contacts[5].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.contacts[5].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[5].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[5].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.contacts[5].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[5].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[5].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.contacts[5].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.contacts[5].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.contacts[5].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.contacts[5].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.contacts[5].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.contacts[5].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.contacts[5].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[5].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.contacts[5].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.contacts[5].params.name = \"params used in the PMM paper\";
  parameter Integer m.contacts[5].params.NWheels = 3;
  parameter Integer m.contacts[5].params.nRollers = 5;
  parameter Real m.contacts[5].params.mecanumAngle = 0.0;
  parameter Real m.contacts[5].params.platformRadius = 0.15;
  parameter Real m.contacts[5].params.wheelRadius = 0.05;
  parameter Real m.contacts[5].params.platformMass = 1.0;
  parameter Real m.contacts[5].params.wheelHubMass = 0.15;
  parameter Real m.contacts[5].params.rollerMass = 0.05;
  parameter Real m.contacts[5].params.rollerHalfAngle = 0.6283185307179586;
  parameter Real m.contacts[5].params.wheelHubRadius = 0.04045084971874738;
  parameter Real m.contacts[5].params.rollerRadius = 0.004774575140626312;
  parameter Real m.contacts[5].params.rollerLength = 0.02938926261462366;
  parameter Real m.contacts[5].params.platformAxialMoi = 0.01125;
  parameter Real m.contacts[5].params.platformOrthogonalMoi = 0.005633333333333334;
  parameter Real m.contacts[5].params.wheelHubAxialMoi = 0.0001227203432226514;
  parameter Real m.contacts[5].params.wheelHubOrthogonalMoi = 6.261017161132568e-05;
  parameter Real m.contacts[5].params.rollerAxialMoi = 5.699141943371693e-07;
  parameter Real m.contacts[5].params.rollerOrthogonalMoi = 3.8838269181324e-06;
  protected Real m.contacts[5].contactPointCoords[1];
  protected Real m.contacts[5].contactPointCoords[2];
  protected Real m.contacts[5].contactPointCoords[3];
  protected Real m.contacts[5].contactPointVelocity[1];
  protected Real m.contacts[5].contactPointVelocity[2];
  protected Real m.contacts[5].contactPointVelocity[3];
  protected Real m.contacts[5].cosBetweenRollerVerticalAndGlobalVertical;
  protected Boolean m.contacts[5].isInContact;
initial equation
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Rollers[1].q[1] ^ 2.0 + m.wheel.Rollers[1].q[2] ^ 2.0 + m.wheel.Rollers[1].q[3] ^ 2.0 + m.wheel.Rollers[1].q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Rollers[1].q[1] ^ 2.0 + m.wheel.Rollers[1].q[2] ^ 2.0 + m.wheel.Rollers[1].q[3] ^ 2.0 + m.wheel.Rollers[1].q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Rollers[1].q[1], m.wheel.Rollers[1].q[2], m.wheel.Rollers[1].q[3], m.wheel.Rollers[1].q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].r[1], m.wheel.Rollers[1].r[2], m.wheel.Rollers[1].r[3]}, \"r\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].v[1], m.wheel.Rollers[1].v[2], m.wheel.Rollers[1].v[3]}, \"v\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].q[1], m.wheel.Rollers[1].q[2], m.wheel.Rollers[1].q[3], m.wheel.Rollers[1].q[4]}, \"q\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].omega[1], m.wheel.Rollers[1].omega[2], m.wheel.Rollers[1].omega[3]}, \"omega\");
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Rollers[2].q[1] ^ 2.0 + m.wheel.Rollers[2].q[2] ^ 2.0 + m.wheel.Rollers[2].q[3] ^ 2.0 + m.wheel.Rollers[2].q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Rollers[2].q[1] ^ 2.0 + m.wheel.Rollers[2].q[2] ^ 2.0 + m.wheel.Rollers[2].q[3] ^ 2.0 + m.wheel.Rollers[2].q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Rollers[2].q[1], m.wheel.Rollers[2].q[2], m.wheel.Rollers[2].q[3], m.wheel.Rollers[2].q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].r[1], m.wheel.Rollers[2].r[2], m.wheel.Rollers[2].r[3]}, \"r\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].v[1], m.wheel.Rollers[2].v[2], m.wheel.Rollers[2].v[3]}, \"v\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].q[1], m.wheel.Rollers[2].q[2], m.wheel.Rollers[2].q[3], m.wheel.Rollers[2].q[4]}, \"q\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].omega[1], m.wheel.Rollers[2].omega[2], m.wheel.Rollers[2].omega[3]}, \"omega\");
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Rollers[3].q[1] ^ 2.0 + m.wheel.Rollers[3].q[2] ^ 2.0 + m.wheel.Rollers[3].q[3] ^ 2.0 + m.wheel.Rollers[3].q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Rollers[3].q[1] ^ 2.0 + m.wheel.Rollers[3].q[2] ^ 2.0 + m.wheel.Rollers[3].q[3] ^ 2.0 + m.wheel.Rollers[3].q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Rollers[3].q[1], m.wheel.Rollers[3].q[2], m.wheel.Rollers[3].q[3], m.wheel.Rollers[3].q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[3]\", {m.wheel.Rollers[3].r[1], m.wheel.Rollers[3].r[2], m.wheel.Rollers[3].r[3]}, \"r\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[3]\", {m.wheel.Rollers[3].v[1], m.wheel.Rollers[3].v[2], m.wheel.Rollers[3].v[3]}, \"v\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[3]\", {m.wheel.Rollers[3].q[1], m.wheel.Rollers[3].q[2], m.wheel.Rollers[3].q[3], m.wheel.Rollers[3].q[4]}, \"q\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[3]\", {m.wheel.Rollers[3].omega[1], m.wheel.Rollers[3].omega[2], m.wheel.Rollers[3].omega[3]}, \"omega\");
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Rollers[4].q[1] ^ 2.0 + m.wheel.Rollers[4].q[2] ^ 2.0 + m.wheel.Rollers[4].q[3] ^ 2.0 + m.wheel.Rollers[4].q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Rollers[4].q[1] ^ 2.0 + m.wheel.Rollers[4].q[2] ^ 2.0 + m.wheel.Rollers[4].q[3] ^ 2.0 + m.wheel.Rollers[4].q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Rollers[4].q[1], m.wheel.Rollers[4].q[2], m.wheel.Rollers[4].q[3], m.wheel.Rollers[4].q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[4]\", {m.wheel.Rollers[4].r[1], m.wheel.Rollers[4].r[2], m.wheel.Rollers[4].r[3]}, \"r\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[4]\", {m.wheel.Rollers[4].v[1], m.wheel.Rollers[4].v[2], m.wheel.Rollers[4].v[3]}, \"v\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[4]\", {m.wheel.Rollers[4].q[1], m.wheel.Rollers[4].q[2], m.wheel.Rollers[4].q[3], m.wheel.Rollers[4].q[4]}, \"q\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[4]\", {m.wheel.Rollers[4].omega[1], m.wheel.Rollers[4].omega[2], m.wheel.Rollers[4].omega[3]}, \"omega\");
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Rollers[5].q[1] ^ 2.0 + m.wheel.Rollers[5].q[2] ^ 2.0 + m.wheel.Rollers[5].q[3] ^ 2.0 + m.wheel.Rollers[5].q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Rollers[5].q[1] ^ 2.0 + m.wheel.Rollers[5].q[2] ^ 2.0 + m.wheel.Rollers[5].q[3] ^ 2.0 + m.wheel.Rollers[5].q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Rollers[5].q[1], m.wheel.Rollers[5].q[2], m.wheel.Rollers[5].q[3], m.wheel.Rollers[5].q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[5]\", {m.wheel.Rollers[5].r[1], m.wheel.Rollers[5].r[2], m.wheel.Rollers[5].r[3]}, \"r\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[5]\", {m.wheel.Rollers[5].v[1], m.wheel.Rollers[5].v[2], m.wheel.Rollers[5].v[3]}, \"v\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[5]\", {m.wheel.Rollers[5].q[1], m.wheel.Rollers[5].q[2], m.wheel.Rollers[5].q[3], m.wheel.Rollers[5].q[4]}, \"q\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel.Rollers[5]\", {m.wheel.Rollers[5].omega[1], m.wheel.Rollers[5].omega[2], m.wheel.Rollers[5].omega[3]}, \"omega\");
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Wheel.q[1] ^ 2.0 + m.wheel.Wheel.q[2] ^ 2.0 + m.wheel.Wheel.q[3] ^ 2.0 + m.wheel.Wheel.q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Wheel.q[1] ^ 2.0 + m.wheel.Wheel.q[2] ^ 2.0 + m.wheel.Wheel.q[3] ^ 2.0 + m.wheel.Wheel.q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Wheel.q[1], m.wheel.Wheel.q[2], m.wheel.Wheel.q[3], m.wheel.Wheel.q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.r[1], m.wheel.Wheel.r[2], m.wheel.Wheel.r[3]}, \"r\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.v[1], m.wheel.Wheel.v[2], m.wheel.Wheel.v[3]}, \"v\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.q[1], m.wheel.Wheel.q[2], m.wheel.Wheel.q[3], m.wheel.Wheel.q[4]}, \"q\");
  MbsLite.Util.Asserts.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.omega[1], m.wheel.Wheel.omega[2], m.wheel.Wheel.omega[3]}, \"omega\");
initial algorithm

initial algorithm
equation
  m.base.OutPort.r[1] = 0.0;
  m.base.OutPort.r[2] = 0.0;
  m.base.OutPort.r[3] = 0.0;
  m.base.OutPort.v[1] = 0.0;
  m.base.OutPort.v[2] = 0.0;
  m.base.OutPort.v[3] = 0.0;
  m.base.OutPort.a[1] = 0.0;
  m.base.OutPort.a[2] = 0.0;
  m.base.OutPort.a[3] = 0.0;
  m.base.OutPort.T[1,1] = 1.0;
  m.base.OutPort.T[1,2] = 0.0;
  m.base.OutPort.T[1,3] = 0.0;
  m.base.OutPort.T[2,1] = 0.0;
  m.base.OutPort.T[2,2] = 1.0;
  m.base.OutPort.T[2,3] = 0.0;
  m.base.OutPort.T[3,1] = 0.0;
  m.base.OutPort.T[3,2] = 0.0;
  m.base.OutPort.T[3,3] = 1.0;
  m.base.OutPort.omega[1] = 0.0;
  m.base.OutPort.omega[2] = 0.0;
  m.base.OutPort.omega[3] = 0.0;
  m.base.OutPort.epsilon[1] = 0.0;
  m.base.OutPort.epsilon[2] = 0.0;
  m.base.OutPort.epsilon[3] = 0.0;
  m.wheel.Rollers[1].crosses[1,1] = (m.wheel.Rollers[1].InPorts[1].P[2] - m.wheel.Rollers[1].r[2]) * m.wheel.Rollers[1].InPorts[1].F[3] - (m.wheel.Rollers[1].InPorts[1].P[3] - m.wheel.Rollers[1].r[3]) * m.wheel.Rollers[1].InPorts[1].F[2];
  m.wheel.Rollers[1].crosses[1,2] = (m.wheel.Rollers[1].InPorts[1].P[3] - m.wheel.Rollers[1].r[3]) * m.wheel.Rollers[1].InPorts[1].F[1] - (m.wheel.Rollers[1].InPorts[1].P[1] - m.wheel.Rollers[1].r[1]) * m.wheel.Rollers[1].InPorts[1].F[3];
  m.wheel.Rollers[1].crosses[1,3] = (m.wheel.Rollers[1].InPorts[1].P[1] - m.wheel.Rollers[1].r[1]) * m.wheel.Rollers[1].InPorts[1].F[2] - (m.wheel.Rollers[1].InPorts[1].P[2] - m.wheel.Rollers[1].r[2]) * m.wheel.Rollers[1].InPorts[1].F[1];
  m.wheel.Rollers[1].crosses[2,1] = (m.wheel.Rollers[1].InPorts[2].P[2] - m.wheel.Rollers[1].r[2]) * m.wheel.Rollers[1].InPorts[2].F[3] - (m.wheel.Rollers[1].InPorts[2].P[3] - m.wheel.Rollers[1].r[3]) * m.wheel.Rollers[1].InPorts[2].F[2];
  m.wheel.Rollers[1].crosses[2,2] = (m.wheel.Rollers[1].InPorts[2].P[3] - m.wheel.Rollers[1].r[3]) * m.wheel.Rollers[1].InPorts[2].F[1] - (m.wheel.Rollers[1].InPorts[2].P[1] - m.wheel.Rollers[1].r[1]) * m.wheel.Rollers[1].InPorts[2].F[3];
  m.wheel.Rollers[1].crosses[2,3] = (m.wheel.Rollers[1].InPorts[2].P[1] - m.wheel.Rollers[1].r[1]) * m.wheel.Rollers[1].InPorts[2].F[2] - (m.wheel.Rollers[1].InPorts[2].P[2] - m.wheel.Rollers[1].r[2]) * m.wheel.Rollers[1].InPorts[2].F[1];
  m.wheel.Rollers[1].F[1] = m.wheel.Rollers[1].InPorts[1].F[1] + m.wheel.Rollers[1].InPorts[2].F[1];
  m.wheel.Rollers[1].F[2] = -0.05 + m.wheel.Rollers[1].InPorts[1].F[2] + m.wheel.Rollers[1].InPorts[2].F[2];
  m.wheel.Rollers[1].F[3] = m.wheel.Rollers[1].InPorts[1].F[3] + m.wheel.Rollers[1].InPorts[2].F[3];
  m.wheel.Rollers[1].M[1] = m.wheel.Rollers[1].InPorts[1].M[1] + m.wheel.Rollers[1].crosses[1,1] + m.wheel.Rollers[1].InPorts[2].M[1] + m.wheel.Rollers[1].crosses[2,1];
  m.wheel.Rollers[1].M[2] = m.wheel.Rollers[1].InPorts[1].M[2] + m.wheel.Rollers[1].crosses[1,2] + m.wheel.Rollers[1].InPorts[2].M[2] + m.wheel.Rollers[1].crosses[2,2];
  m.wheel.Rollers[1].M[3] = m.wheel.Rollers[1].InPorts[1].M[3] + m.wheel.Rollers[1].crosses[1,3] + m.wheel.Rollers[1].InPorts[2].M[3] + m.wheel.Rollers[1].crosses[2,3];
  der(m.wheel.Rollers[1].Active) = 0.0;
  der(m.wheel.Rollers[1].r[1]) = m.wheel.Rollers[1].v[1] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].r[2]) = m.wheel.Rollers[1].v[2] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].r[3]) = m.wheel.Rollers[1].v[3] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].v[1]) = m.wheel.Rollers[1].a[1] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].v[2]) = m.wheel.Rollers[1].a[2] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].v[3]) = m.wheel.Rollers[1].a[3] * m.wheel.Rollers[1].Active;
  m.wheel.Rollers[1].a[1] * 0.05 = m.wheel.Rollers[1].F[1];
  m.wheel.Rollers[1].a[2] * 0.05 = m.wheel.Rollers[1].F[2];
  m.wheel.Rollers[1].a[3] * 0.05 = m.wheel.Rollers[1].F[3];
  {der(m.wheel.Rollers[1].q[1]), der(m.wheel.Rollers[1].q[2]), der(m.wheel.Rollers[1].q[3]), der(m.wheel.Rollers[1].q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Rollers[1].q[1], m.wheel.Rollers[1].q[2], m.wheel.Rollers[1].q[3], m.wheel.Rollers[1].q[4]}, {0.0, m.wheel.Rollers[1].omega[1], m.wheel.Rollers[1].omega[2], m.wheel.Rollers[1].omega[3]}) * 0.5 * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].omega[1]) = m.wheel.Rollers[1].epsilon[1] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].omega[2]) = m.wheel.Rollers[1].epsilon[2] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].omega[3]) = m.wheel.Rollers[1].epsilon[3] * m.wheel.Rollers[1].Active;
  m.wheel.Rollers[1].T = MbsLite.Util.Quaternions.QToT({m.wheel.Rollers[1].q[1], m.wheel.Rollers[1].q[2], m.wheel.Rollers[1].q[3], m.wheel.Rollers[1].q[4]});
  5.699141943371693e-07 * m.wheel.Rollers[1].epsilon[1] = m.wheel.Rollers[1].T[1,1] * m.wheel.Rollers[1].M[1] + m.wheel.Rollers[1].T[2,1] * m.wheel.Rollers[1].M[2] + m.wheel.Rollers[1].T[3,1] * m.wheel.Rollers[1].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[1].epsilon[2] + m.wheel.Rollers[1].omega[3] * 5.699141943371693e-07 * m.wheel.Rollers[1].omega[1] - m.wheel.Rollers[1].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[1].omega[3] = m.wheel.Rollers[1].T[1,2] * m.wheel.Rollers[1].M[1] + m.wheel.Rollers[1].T[2,2] * m.wheel.Rollers[1].M[2] + m.wheel.Rollers[1].T[3,2] * m.wheel.Rollers[1].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[1].epsilon[3] + m.wheel.Rollers[1].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[1].omega[2] - m.wheel.Rollers[1].omega[2] * 5.699141943371693e-07 * m.wheel.Rollers[1].omega[1] = m.wheel.Rollers[1].T[1,3] * m.wheel.Rollers[1].M[1] + m.wheel.Rollers[1].T[2,3] * m.wheel.Rollers[1].M[2] + m.wheel.Rollers[1].T[3,3] * m.wheel.Rollers[1].M[3];
  m.wheel.Rollers[1].OutPort.r[1] = m.wheel.Rollers[1].r[1];
  m.wheel.Rollers[1].OutPort.r[2] = m.wheel.Rollers[1].r[2];
  m.wheel.Rollers[1].OutPort.r[3] = m.wheel.Rollers[1].r[3];
  m.wheel.Rollers[1].OutPort.v[1] = m.wheel.Rollers[1].v[1];
  m.wheel.Rollers[1].OutPort.v[2] = m.wheel.Rollers[1].v[2];
  m.wheel.Rollers[1].OutPort.v[3] = m.wheel.Rollers[1].v[3];
  m.wheel.Rollers[1].OutPort.a[1] = m.wheel.Rollers[1].a[1];
  m.wheel.Rollers[1].OutPort.a[2] = m.wheel.Rollers[1].a[2];
  m.wheel.Rollers[1].OutPort.a[3] = m.wheel.Rollers[1].a[3];
  m.wheel.Rollers[1].OutPort.T[1,1] = m.wheel.Rollers[1].T[1,1];
  m.wheel.Rollers[1].OutPort.T[1,2] = m.wheel.Rollers[1].T[1,2];
  m.wheel.Rollers[1].OutPort.T[1,3] = m.wheel.Rollers[1].T[1,3];
  m.wheel.Rollers[1].OutPort.T[2,1] = m.wheel.Rollers[1].T[2,1];
  m.wheel.Rollers[1].OutPort.T[2,2] = m.wheel.Rollers[1].T[2,2];
  m.wheel.Rollers[1].OutPort.T[2,3] = m.wheel.Rollers[1].T[2,3];
  m.wheel.Rollers[1].OutPort.T[3,1] = m.wheel.Rollers[1].T[3,1];
  m.wheel.Rollers[1].OutPort.T[3,2] = m.wheel.Rollers[1].T[3,2];
  m.wheel.Rollers[1].OutPort.T[3,3] = m.wheel.Rollers[1].T[3,3];
  m.wheel.Rollers[1].OutPort.omega[1] = m.wheel.Rollers[1].T[1,1] * m.wheel.Rollers[1].omega[1] + m.wheel.Rollers[1].T[1,2] * m.wheel.Rollers[1].omega[2] + m.wheel.Rollers[1].T[1,3] * m.wheel.Rollers[1].omega[3];
  m.wheel.Rollers[1].OutPort.omega[2] = m.wheel.Rollers[1].T[2,1] * m.wheel.Rollers[1].omega[1] + m.wheel.Rollers[1].T[2,2] * m.wheel.Rollers[1].omega[2] + m.wheel.Rollers[1].T[2,3] * m.wheel.Rollers[1].omega[3];
  m.wheel.Rollers[1].OutPort.omega[3] = m.wheel.Rollers[1].T[3,1] * m.wheel.Rollers[1].omega[1] + m.wheel.Rollers[1].T[3,2] * m.wheel.Rollers[1].omega[2] + m.wheel.Rollers[1].T[3,3] * m.wheel.Rollers[1].omega[3];
  m.wheel.Rollers[1].OutPort.epsilon[1] = m.wheel.Rollers[1].T[1,1] * m.wheel.Rollers[1].epsilon[1] + m.wheel.Rollers[1].T[1,2] * m.wheel.Rollers[1].epsilon[2] + m.wheel.Rollers[1].T[1,3] * m.wheel.Rollers[1].epsilon[3];
  m.wheel.Rollers[1].OutPort.epsilon[2] = m.wheel.Rollers[1].T[2,1] * m.wheel.Rollers[1].epsilon[1] + m.wheel.Rollers[1].T[2,2] * m.wheel.Rollers[1].epsilon[2] + m.wheel.Rollers[1].T[2,3] * m.wheel.Rollers[1].epsilon[3];
  m.wheel.Rollers[1].OutPort.epsilon[3] = m.wheel.Rollers[1].T[3,1] * m.wheel.Rollers[1].epsilon[1] + m.wheel.Rollers[1].T[3,2] * m.wheel.Rollers[1].epsilon[2] + m.wheel.Rollers[1].T[3,3] * m.wheel.Rollers[1].epsilon[3];
  m.wheel.Rollers[2].crosses[1,1] = (m.wheel.Rollers[2].InPorts[1].P[2] - m.wheel.Rollers[2].r[2]) * m.wheel.Rollers[2].InPorts[1].F[3] - (m.wheel.Rollers[2].InPorts[1].P[3] - m.wheel.Rollers[2].r[3]) * m.wheel.Rollers[2].InPorts[1].F[2];
  m.wheel.Rollers[2].crosses[1,2] = (m.wheel.Rollers[2].InPorts[1].P[3] - m.wheel.Rollers[2].r[3]) * m.wheel.Rollers[2].InPorts[1].F[1] - (m.wheel.Rollers[2].InPorts[1].P[1] - m.wheel.Rollers[2].r[1]) * m.wheel.Rollers[2].InPorts[1].F[3];
  m.wheel.Rollers[2].crosses[1,3] = (m.wheel.Rollers[2].InPorts[1].P[1] - m.wheel.Rollers[2].r[1]) * m.wheel.Rollers[2].InPorts[1].F[2] - (m.wheel.Rollers[2].InPorts[1].P[2] - m.wheel.Rollers[2].r[2]) * m.wheel.Rollers[2].InPorts[1].F[1];
  m.wheel.Rollers[2].crosses[2,1] = (m.wheel.Rollers[2].InPorts[2].P[2] - m.wheel.Rollers[2].r[2]) * m.wheel.Rollers[2].InPorts[2].F[3] - (m.wheel.Rollers[2].InPorts[2].P[3] - m.wheel.Rollers[2].r[3]) * m.wheel.Rollers[2].InPorts[2].F[2];
  m.wheel.Rollers[2].crosses[2,2] = (m.wheel.Rollers[2].InPorts[2].P[3] - m.wheel.Rollers[2].r[3]) * m.wheel.Rollers[2].InPorts[2].F[1] - (m.wheel.Rollers[2].InPorts[2].P[1] - m.wheel.Rollers[2].r[1]) * m.wheel.Rollers[2].InPorts[2].F[3];
  m.wheel.Rollers[2].crosses[2,3] = (m.wheel.Rollers[2].InPorts[2].P[1] - m.wheel.Rollers[2].r[1]) * m.wheel.Rollers[2].InPorts[2].F[2] - (m.wheel.Rollers[2].InPorts[2].P[2] - m.wheel.Rollers[2].r[2]) * m.wheel.Rollers[2].InPorts[2].F[1];
  m.wheel.Rollers[2].F[1] = m.wheel.Rollers[2].InPorts[1].F[1] + m.wheel.Rollers[2].InPorts[2].F[1];
  m.wheel.Rollers[2].F[2] = -0.05 + m.wheel.Rollers[2].InPorts[1].F[2] + m.wheel.Rollers[2].InPorts[2].F[2];
  m.wheel.Rollers[2].F[3] = m.wheel.Rollers[2].InPorts[1].F[3] + m.wheel.Rollers[2].InPorts[2].F[3];
  m.wheel.Rollers[2].M[1] = m.wheel.Rollers[2].InPorts[1].M[1] + m.wheel.Rollers[2].crosses[1,1] + m.wheel.Rollers[2].InPorts[2].M[1] + m.wheel.Rollers[2].crosses[2,1];
  m.wheel.Rollers[2].M[2] = m.wheel.Rollers[2].InPorts[1].M[2] + m.wheel.Rollers[2].crosses[1,2] + m.wheel.Rollers[2].InPorts[2].M[2] + m.wheel.Rollers[2].crosses[2,2];
  m.wheel.Rollers[2].M[3] = m.wheel.Rollers[2].InPorts[1].M[3] + m.wheel.Rollers[2].crosses[1,3] + m.wheel.Rollers[2].InPorts[2].M[3] + m.wheel.Rollers[2].crosses[2,3];
  der(m.wheel.Rollers[2].Active) = 0.0;
  der(m.wheel.Rollers[2].r[1]) = m.wheel.Rollers[2].v[1] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].r[2]) = m.wheel.Rollers[2].v[2] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].r[3]) = m.wheel.Rollers[2].v[3] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].v[1]) = m.wheel.Rollers[2].a[1] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].v[2]) = m.wheel.Rollers[2].a[2] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].v[3]) = m.wheel.Rollers[2].a[3] * m.wheel.Rollers[2].Active;
  m.wheel.Rollers[2].a[1] * 0.05 = m.wheel.Rollers[2].F[1];
  m.wheel.Rollers[2].a[2] * 0.05 = m.wheel.Rollers[2].F[2];
  m.wheel.Rollers[2].a[3] * 0.05 = m.wheel.Rollers[2].F[3];
  {der(m.wheel.Rollers[2].q[1]), der(m.wheel.Rollers[2].q[2]), der(m.wheel.Rollers[2].q[3]), der(m.wheel.Rollers[2].q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Rollers[2].q[1], m.wheel.Rollers[2].q[2], m.wheel.Rollers[2].q[3], m.wheel.Rollers[2].q[4]}, {0.0, m.wheel.Rollers[2].omega[1], m.wheel.Rollers[2].omega[2], m.wheel.Rollers[2].omega[3]}) * 0.5 * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].omega[1]) = m.wheel.Rollers[2].epsilon[1] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].omega[2]) = m.wheel.Rollers[2].epsilon[2] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].omega[3]) = m.wheel.Rollers[2].epsilon[3] * m.wheel.Rollers[2].Active;
  m.wheel.Rollers[2].T = MbsLite.Util.Quaternions.QToT({m.wheel.Rollers[2].q[1], m.wheel.Rollers[2].q[2], m.wheel.Rollers[2].q[3], m.wheel.Rollers[2].q[4]});
  5.699141943371693e-07 * m.wheel.Rollers[2].epsilon[1] = m.wheel.Rollers[2].T[1,1] * m.wheel.Rollers[2].M[1] + m.wheel.Rollers[2].T[2,1] * m.wheel.Rollers[2].M[2] + m.wheel.Rollers[2].T[3,1] * m.wheel.Rollers[2].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[2].epsilon[2] + m.wheel.Rollers[2].omega[3] * 5.699141943371693e-07 * m.wheel.Rollers[2].omega[1] - m.wheel.Rollers[2].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[2].omega[3] = m.wheel.Rollers[2].T[1,2] * m.wheel.Rollers[2].M[1] + m.wheel.Rollers[2].T[2,2] * m.wheel.Rollers[2].M[2] + m.wheel.Rollers[2].T[3,2] * m.wheel.Rollers[2].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[2].epsilon[3] + m.wheel.Rollers[2].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[2].omega[2] - m.wheel.Rollers[2].omega[2] * 5.699141943371693e-07 * m.wheel.Rollers[2].omega[1] = m.wheel.Rollers[2].T[1,3] * m.wheel.Rollers[2].M[1] + m.wheel.Rollers[2].T[2,3] * m.wheel.Rollers[2].M[2] + m.wheel.Rollers[2].T[3,3] * m.wheel.Rollers[2].M[3];
  m.wheel.Rollers[2].OutPort.r[1] = m.wheel.Rollers[2].r[1];
  m.wheel.Rollers[2].OutPort.r[2] = m.wheel.Rollers[2].r[2];
  m.wheel.Rollers[2].OutPort.r[3] = m.wheel.Rollers[2].r[3];
  m.wheel.Rollers[2].OutPort.v[1] = m.wheel.Rollers[2].v[1];
  m.wheel.Rollers[2].OutPort.v[2] = m.wheel.Rollers[2].v[2];
  m.wheel.Rollers[2].OutPort.v[3] = m.wheel.Rollers[2].v[3];
  m.wheel.Rollers[2].OutPort.a[1] = m.wheel.Rollers[2].a[1];
  m.wheel.Rollers[2].OutPort.a[2] = m.wheel.Rollers[2].a[2];
  m.wheel.Rollers[2].OutPort.a[3] = m.wheel.Rollers[2].a[3];
  m.wheel.Rollers[2].OutPort.T[1,1] = m.wheel.Rollers[2].T[1,1];
  m.wheel.Rollers[2].OutPort.T[1,2] = m.wheel.Rollers[2].T[1,2];
  m.wheel.Rollers[2].OutPort.T[1,3] = m.wheel.Rollers[2].T[1,3];
  m.wheel.Rollers[2].OutPort.T[2,1] = m.wheel.Rollers[2].T[2,1];
  m.wheel.Rollers[2].OutPort.T[2,2] = m.wheel.Rollers[2].T[2,2];
  m.wheel.Rollers[2].OutPort.T[2,3] = m.wheel.Rollers[2].T[2,3];
  m.wheel.Rollers[2].OutPort.T[3,1] = m.wheel.Rollers[2].T[3,1];
  m.wheel.Rollers[2].OutPort.T[3,2] = m.wheel.Rollers[2].T[3,2];
  m.wheel.Rollers[2].OutPort.T[3,3] = m.wheel.Rollers[2].T[3,3];
  m.wheel.Rollers[2].OutPort.omega[1] = m.wheel.Rollers[2].T[1,1] * m.wheel.Rollers[2].omega[1] + m.wheel.Rollers[2].T[1,2] * m.wheel.Rollers[2].omega[2] + m.wheel.Rollers[2].T[1,3] * m.wheel.Rollers[2].omega[3];
  m.wheel.Rollers[2].OutPort.omega[2] = m.wheel.Rollers[2].T[2,1] * m.wheel.Rollers[2].omega[1] + m.wheel.Rollers[2].T[2,2] * m.wheel.Rollers[2].omega[2] + m.wheel.Rollers[2].T[2,3] * m.wheel.Rollers[2].omega[3];
  m.wheel.Rollers[2].OutPort.omega[3] = m.wheel.Rollers[2].T[3,1] * m.wheel.Rollers[2].omega[1] + m.wheel.Rollers[2].T[3,2] * m.wheel.Rollers[2].omega[2] + m.wheel.Rollers[2].T[3,3] * m.wheel.Rollers[2].omega[3];
  m.wheel.Rollers[2].OutPort.epsilon[1] = m.wheel.Rollers[2].T[1,1] * m.wheel.Rollers[2].epsilon[1] + m.wheel.Rollers[2].T[1,2] * m.wheel.Rollers[2].epsilon[2] + m.wheel.Rollers[2].T[1,3] * m.wheel.Rollers[2].epsilon[3];
  m.wheel.Rollers[2].OutPort.epsilon[2] = m.wheel.Rollers[2].T[2,1] * m.wheel.Rollers[2].epsilon[1] + m.wheel.Rollers[2].T[2,2] * m.wheel.Rollers[2].epsilon[2] + m.wheel.Rollers[2].T[2,3] * m.wheel.Rollers[2].epsilon[3];
  m.wheel.Rollers[2].OutPort.epsilon[3] = m.wheel.Rollers[2].T[3,1] * m.wheel.Rollers[2].epsilon[1] + m.wheel.Rollers[2].T[3,2] * m.wheel.Rollers[2].epsilon[2] + m.wheel.Rollers[2].T[3,3] * m.wheel.Rollers[2].epsilon[3];
  m.wheel.Rollers[3].crosses[1,1] = (m.wheel.Rollers[3].InPorts[1].P[2] - m.wheel.Rollers[3].r[2]) * m.wheel.Rollers[3].InPorts[1].F[3] - (m.wheel.Rollers[3].InPorts[1].P[3] - m.wheel.Rollers[3].r[3]) * m.wheel.Rollers[3].InPorts[1].F[2];
  m.wheel.Rollers[3].crosses[1,2] = (m.wheel.Rollers[3].InPorts[1].P[3] - m.wheel.Rollers[3].r[3]) * m.wheel.Rollers[3].InPorts[1].F[1] - (m.wheel.Rollers[3].InPorts[1].P[1] - m.wheel.Rollers[3].r[1]) * m.wheel.Rollers[3].InPorts[1].F[3];
  m.wheel.Rollers[3].crosses[1,3] = (m.wheel.Rollers[3].InPorts[1].P[1] - m.wheel.Rollers[3].r[1]) * m.wheel.Rollers[3].InPorts[1].F[2] - (m.wheel.Rollers[3].InPorts[1].P[2] - m.wheel.Rollers[3].r[2]) * m.wheel.Rollers[3].InPorts[1].F[1];
  m.wheel.Rollers[3].crosses[2,1] = (m.wheel.Rollers[3].InPorts[2].P[2] - m.wheel.Rollers[3].r[2]) * m.wheel.Rollers[3].InPorts[2].F[3] - (m.wheel.Rollers[3].InPorts[2].P[3] - m.wheel.Rollers[3].r[3]) * m.wheel.Rollers[3].InPorts[2].F[2];
  m.wheel.Rollers[3].crosses[2,2] = (m.wheel.Rollers[3].InPorts[2].P[3] - m.wheel.Rollers[3].r[3]) * m.wheel.Rollers[3].InPorts[2].F[1] - (m.wheel.Rollers[3].InPorts[2].P[1] - m.wheel.Rollers[3].r[1]) * m.wheel.Rollers[3].InPorts[2].F[3];
  m.wheel.Rollers[3].crosses[2,3] = (m.wheel.Rollers[3].InPorts[2].P[1] - m.wheel.Rollers[3].r[1]) * m.wheel.Rollers[3].InPorts[2].F[2] - (m.wheel.Rollers[3].InPorts[2].P[2] - m.wheel.Rollers[3].r[2]) * m.wheel.Rollers[3].InPorts[2].F[1];
  m.wheel.Rollers[3].F[1] = m.wheel.Rollers[3].InPorts[1].F[1] + m.wheel.Rollers[3].InPorts[2].F[1];
  m.wheel.Rollers[3].F[2] = -0.05 + m.wheel.Rollers[3].InPorts[1].F[2] + m.wheel.Rollers[3].InPorts[2].F[2];
  m.wheel.Rollers[3].F[3] = m.wheel.Rollers[3].InPorts[1].F[3] + m.wheel.Rollers[3].InPorts[2].F[3];
  m.wheel.Rollers[3].M[1] = m.wheel.Rollers[3].InPorts[1].M[1] + m.wheel.Rollers[3].crosses[1,1] + m.wheel.Rollers[3].InPorts[2].M[1] + m.wheel.Rollers[3].crosses[2,1];
  m.wheel.Rollers[3].M[2] = m.wheel.Rollers[3].InPorts[1].M[2] + m.wheel.Rollers[3].crosses[1,2] + m.wheel.Rollers[3].InPorts[2].M[2] + m.wheel.Rollers[3].crosses[2,2];
  m.wheel.Rollers[3].M[3] = m.wheel.Rollers[3].InPorts[1].M[3] + m.wheel.Rollers[3].crosses[1,3] + m.wheel.Rollers[3].InPorts[2].M[3] + m.wheel.Rollers[3].crosses[2,3];
  der(m.wheel.Rollers[3].Active) = 0.0;
  der(m.wheel.Rollers[3].r[1]) = m.wheel.Rollers[3].v[1] * m.wheel.Rollers[3].Active;
  der(m.wheel.Rollers[3].r[2]) = m.wheel.Rollers[3].v[2] * m.wheel.Rollers[3].Active;
  der(m.wheel.Rollers[3].r[3]) = m.wheel.Rollers[3].v[3] * m.wheel.Rollers[3].Active;
  der(m.wheel.Rollers[3].v[1]) = m.wheel.Rollers[3].a[1] * m.wheel.Rollers[3].Active;
  der(m.wheel.Rollers[3].v[2]) = m.wheel.Rollers[3].a[2] * m.wheel.Rollers[3].Active;
  der(m.wheel.Rollers[3].v[3]) = m.wheel.Rollers[3].a[3] * m.wheel.Rollers[3].Active;
  m.wheel.Rollers[3].a[1] * 0.05 = m.wheel.Rollers[3].F[1];
  m.wheel.Rollers[3].a[2] * 0.05 = m.wheel.Rollers[3].F[2];
  m.wheel.Rollers[3].a[3] * 0.05 = m.wheel.Rollers[3].F[3];
  {der(m.wheel.Rollers[3].q[1]), der(m.wheel.Rollers[3].q[2]), der(m.wheel.Rollers[3].q[3]), der(m.wheel.Rollers[3].q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Rollers[3].q[1], m.wheel.Rollers[3].q[2], m.wheel.Rollers[3].q[3], m.wheel.Rollers[3].q[4]}, {0.0, m.wheel.Rollers[3].omega[1], m.wheel.Rollers[3].omega[2], m.wheel.Rollers[3].omega[3]}) * 0.5 * m.wheel.Rollers[3].Active;
  der(m.wheel.Rollers[3].omega[1]) = m.wheel.Rollers[3].epsilon[1] * m.wheel.Rollers[3].Active;
  der(m.wheel.Rollers[3].omega[2]) = m.wheel.Rollers[3].epsilon[2] * m.wheel.Rollers[3].Active;
  der(m.wheel.Rollers[3].omega[3]) = m.wheel.Rollers[3].epsilon[3] * m.wheel.Rollers[3].Active;
  m.wheel.Rollers[3].T = MbsLite.Util.Quaternions.QToT({m.wheel.Rollers[3].q[1], m.wheel.Rollers[3].q[2], m.wheel.Rollers[3].q[3], m.wheel.Rollers[3].q[4]});
  5.699141943371693e-07 * m.wheel.Rollers[3].epsilon[1] = m.wheel.Rollers[3].T[1,1] * m.wheel.Rollers[3].M[1] + m.wheel.Rollers[3].T[2,1] * m.wheel.Rollers[3].M[2] + m.wheel.Rollers[3].T[3,1] * m.wheel.Rollers[3].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[3].epsilon[2] + m.wheel.Rollers[3].omega[3] * 5.699141943371693e-07 * m.wheel.Rollers[3].omega[1] - m.wheel.Rollers[3].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[3].omega[3] = m.wheel.Rollers[3].T[1,2] * m.wheel.Rollers[3].M[1] + m.wheel.Rollers[3].T[2,2] * m.wheel.Rollers[3].M[2] + m.wheel.Rollers[3].T[3,2] * m.wheel.Rollers[3].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[3].epsilon[3] + m.wheel.Rollers[3].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[3].omega[2] - m.wheel.Rollers[3].omega[2] * 5.699141943371693e-07 * m.wheel.Rollers[3].omega[1] = m.wheel.Rollers[3].T[1,3] * m.wheel.Rollers[3].M[1] + m.wheel.Rollers[3].T[2,3] * m.wheel.Rollers[3].M[2] + m.wheel.Rollers[3].T[3,3] * m.wheel.Rollers[3].M[3];
  m.wheel.Rollers[3].OutPort.r[1] = m.wheel.Rollers[3].r[1];
  m.wheel.Rollers[3].OutPort.r[2] = m.wheel.Rollers[3].r[2];
  m.wheel.Rollers[3].OutPort.r[3] = m.wheel.Rollers[3].r[3];
  m.wheel.Rollers[3].OutPort.v[1] = m.wheel.Rollers[3].v[1];
  m.wheel.Rollers[3].OutPort.v[2] = m.wheel.Rollers[3].v[2];
  m.wheel.Rollers[3].OutPort.v[3] = m.wheel.Rollers[3].v[3];
  m.wheel.Rollers[3].OutPort.a[1] = m.wheel.Rollers[3].a[1];
  m.wheel.Rollers[3].OutPort.a[2] = m.wheel.Rollers[3].a[2];
  m.wheel.Rollers[3].OutPort.a[3] = m.wheel.Rollers[3].a[3];
  m.wheel.Rollers[3].OutPort.T[1,1] = m.wheel.Rollers[3].T[1,1];
  m.wheel.Rollers[3].OutPort.T[1,2] = m.wheel.Rollers[3].T[1,2];
  m.wheel.Rollers[3].OutPort.T[1,3] = m.wheel.Rollers[3].T[1,3];
  m.wheel.Rollers[3].OutPort.T[2,1] = m.wheel.Rollers[3].T[2,1];
  m.wheel.Rollers[3].OutPort.T[2,2] = m.wheel.Rollers[3].T[2,2];
  m.wheel.Rollers[3].OutPort.T[2,3] = m.wheel.Rollers[3].T[2,3];
  m.wheel.Rollers[3].OutPort.T[3,1] = m.wheel.Rollers[3].T[3,1];
  m.wheel.Rollers[3].OutPort.T[3,2] = m.wheel.Rollers[3].T[3,2];
  m.wheel.Rollers[3].OutPort.T[3,3] = m.wheel.Rollers[3].T[3,3];
  m.wheel.Rollers[3].OutPort.omega[1] = m.wheel.Rollers[3].T[1,1] * m.wheel.Rollers[3].omega[1] + m.wheel.Rollers[3].T[1,2] * m.wheel.Rollers[3].omega[2] + m.wheel.Rollers[3].T[1,3] * m.wheel.Rollers[3].omega[3];
  m.wheel.Rollers[3].OutPort.omega[2] = m.wheel.Rollers[3].T[2,1] * m.wheel.Rollers[3].omega[1] + m.wheel.Rollers[3].T[2,2] * m.wheel.Rollers[3].omega[2] + m.wheel.Rollers[3].T[2,3] * m.wheel.Rollers[3].omega[3];
  m.wheel.Rollers[3].OutPort.omega[3] = m.wheel.Rollers[3].T[3,1] * m.wheel.Rollers[3].omega[1] + m.wheel.Rollers[3].T[3,2] * m.wheel.Rollers[3].omega[2] + m.wheel.Rollers[3].T[3,3] * m.wheel.Rollers[3].omega[3];
  m.wheel.Rollers[3].OutPort.epsilon[1] = m.wheel.Rollers[3].T[1,1] * m.wheel.Rollers[3].epsilon[1] + m.wheel.Rollers[3].T[1,2] * m.wheel.Rollers[3].epsilon[2] + m.wheel.Rollers[3].T[1,3] * m.wheel.Rollers[3].epsilon[3];
  m.wheel.Rollers[3].OutPort.epsilon[2] = m.wheel.Rollers[3].T[2,1] * m.wheel.Rollers[3].epsilon[1] + m.wheel.Rollers[3].T[2,2] * m.wheel.Rollers[3].epsilon[2] + m.wheel.Rollers[3].T[2,3] * m.wheel.Rollers[3].epsilon[3];
  m.wheel.Rollers[3].OutPort.epsilon[3] = m.wheel.Rollers[3].T[3,1] * m.wheel.Rollers[3].epsilon[1] + m.wheel.Rollers[3].T[3,2] * m.wheel.Rollers[3].epsilon[2] + m.wheel.Rollers[3].T[3,3] * m.wheel.Rollers[3].epsilon[3];
  m.wheel.Rollers[4].crosses[1,1] = (m.wheel.Rollers[4].InPorts[1].P[2] - m.wheel.Rollers[4].r[2]) * m.wheel.Rollers[4].InPorts[1].F[3] - (m.wheel.Rollers[4].InPorts[1].P[3] - m.wheel.Rollers[4].r[3]) * m.wheel.Rollers[4].InPorts[1].F[2];
  m.wheel.Rollers[4].crosses[1,2] = (m.wheel.Rollers[4].InPorts[1].P[3] - m.wheel.Rollers[4].r[3]) * m.wheel.Rollers[4].InPorts[1].F[1] - (m.wheel.Rollers[4].InPorts[1].P[1] - m.wheel.Rollers[4].r[1]) * m.wheel.Rollers[4].InPorts[1].F[3];
  m.wheel.Rollers[4].crosses[1,3] = (m.wheel.Rollers[4].InPorts[1].P[1] - m.wheel.Rollers[4].r[1]) * m.wheel.Rollers[4].InPorts[1].F[2] - (m.wheel.Rollers[4].InPorts[1].P[2] - m.wheel.Rollers[4].r[2]) * m.wheel.Rollers[4].InPorts[1].F[1];
  m.wheel.Rollers[4].crosses[2,1] = (m.wheel.Rollers[4].InPorts[2].P[2] - m.wheel.Rollers[4].r[2]) * m.wheel.Rollers[4].InPorts[2].F[3] - (m.wheel.Rollers[4].InPorts[2].P[3] - m.wheel.Rollers[4].r[3]) * m.wheel.Rollers[4].InPorts[2].F[2];
  m.wheel.Rollers[4].crosses[2,2] = (m.wheel.Rollers[4].InPorts[2].P[3] - m.wheel.Rollers[4].r[3]) * m.wheel.Rollers[4].InPorts[2].F[1] - (m.wheel.Rollers[4].InPorts[2].P[1] - m.wheel.Rollers[4].r[1]) * m.wheel.Rollers[4].InPorts[2].F[3];
  m.wheel.Rollers[4].crosses[2,3] = (m.wheel.Rollers[4].InPorts[2].P[1] - m.wheel.Rollers[4].r[1]) * m.wheel.Rollers[4].InPorts[2].F[2] - (m.wheel.Rollers[4].InPorts[2].P[2] - m.wheel.Rollers[4].r[2]) * m.wheel.Rollers[4].InPorts[2].F[1];
  m.wheel.Rollers[4].F[1] = m.wheel.Rollers[4].InPorts[1].F[1] + m.wheel.Rollers[4].InPorts[2].F[1];
  m.wheel.Rollers[4].F[2] = -0.05 + m.wheel.Rollers[4].InPorts[1].F[2] + m.wheel.Rollers[4].InPorts[2].F[2];
  m.wheel.Rollers[4].F[3] = m.wheel.Rollers[4].InPorts[1].F[3] + m.wheel.Rollers[4].InPorts[2].F[3];
  m.wheel.Rollers[4].M[1] = m.wheel.Rollers[4].InPorts[1].M[1] + m.wheel.Rollers[4].crosses[1,1] + m.wheel.Rollers[4].InPorts[2].M[1] + m.wheel.Rollers[4].crosses[2,1];
  m.wheel.Rollers[4].M[2] = m.wheel.Rollers[4].InPorts[1].M[2] + m.wheel.Rollers[4].crosses[1,2] + m.wheel.Rollers[4].InPorts[2].M[2] + m.wheel.Rollers[4].crosses[2,2];
  m.wheel.Rollers[4].M[3] = m.wheel.Rollers[4].InPorts[1].M[3] + m.wheel.Rollers[4].crosses[1,3] + m.wheel.Rollers[4].InPorts[2].M[3] + m.wheel.Rollers[4].crosses[2,3];
  der(m.wheel.Rollers[4].Active) = 0.0;
  der(m.wheel.Rollers[4].r[1]) = m.wheel.Rollers[4].v[1] * m.wheel.Rollers[4].Active;
  der(m.wheel.Rollers[4].r[2]) = m.wheel.Rollers[4].v[2] * m.wheel.Rollers[4].Active;
  der(m.wheel.Rollers[4].r[3]) = m.wheel.Rollers[4].v[3] * m.wheel.Rollers[4].Active;
  der(m.wheel.Rollers[4].v[1]) = m.wheel.Rollers[4].a[1] * m.wheel.Rollers[4].Active;
  der(m.wheel.Rollers[4].v[2]) = m.wheel.Rollers[4].a[2] * m.wheel.Rollers[4].Active;
  der(m.wheel.Rollers[4].v[3]) = m.wheel.Rollers[4].a[3] * m.wheel.Rollers[4].Active;
  m.wheel.Rollers[4].a[1] * 0.05 = m.wheel.Rollers[4].F[1];
  m.wheel.Rollers[4].a[2] * 0.05 = m.wheel.Rollers[4].F[2];
  m.wheel.Rollers[4].a[3] * 0.05 = m.wheel.Rollers[4].F[3];
  {der(m.wheel.Rollers[4].q[1]), der(m.wheel.Rollers[4].q[2]), der(m.wheel.Rollers[4].q[3]), der(m.wheel.Rollers[4].q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Rollers[4].q[1], m.wheel.Rollers[4].q[2], m.wheel.Rollers[4].q[3], m.wheel.Rollers[4].q[4]}, {0.0, m.wheel.Rollers[4].omega[1], m.wheel.Rollers[4].omega[2], m.wheel.Rollers[4].omega[3]}) * 0.5 * m.wheel.Rollers[4].Active;
  der(m.wheel.Rollers[4].omega[1]) = m.wheel.Rollers[4].epsilon[1] * m.wheel.Rollers[4].Active;
  der(m.wheel.Rollers[4].omega[2]) = m.wheel.Rollers[4].epsilon[2] * m.wheel.Rollers[4].Active;
  der(m.wheel.Rollers[4].omega[3]) = m.wheel.Rollers[4].epsilon[3] * m.wheel.Rollers[4].Active;
  m.wheel.Rollers[4].T = MbsLite.Util.Quaternions.QToT({m.wheel.Rollers[4].q[1], m.wheel.Rollers[4].q[2], m.wheel.Rollers[4].q[3], m.wheel.Rollers[4].q[4]});
  5.699141943371693e-07 * m.wheel.Rollers[4].epsilon[1] = m.wheel.Rollers[4].T[1,1] * m.wheel.Rollers[4].M[1] + m.wheel.Rollers[4].T[2,1] * m.wheel.Rollers[4].M[2] + m.wheel.Rollers[4].T[3,1] * m.wheel.Rollers[4].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[4].epsilon[2] + m.wheel.Rollers[4].omega[3] * 5.699141943371693e-07 * m.wheel.Rollers[4].omega[1] - m.wheel.Rollers[4].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[4].omega[3] = m.wheel.Rollers[4].T[1,2] * m.wheel.Rollers[4].M[1] + m.wheel.Rollers[4].T[2,2] * m.wheel.Rollers[4].M[2] + m.wheel.Rollers[4].T[3,2] * m.wheel.Rollers[4].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[4].epsilon[3] + m.wheel.Rollers[4].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[4].omega[2] - m.wheel.Rollers[4].omega[2] * 5.699141943371693e-07 * m.wheel.Rollers[4].omega[1] = m.wheel.Rollers[4].T[1,3] * m.wheel.Rollers[4].M[1] + m.wheel.Rollers[4].T[2,3] * m.wheel.Rollers[4].M[2] + m.wheel.Rollers[4].T[3,3] * m.wheel.Rollers[4].M[3];
  m.wheel.Rollers[4].OutPort.r[1] = m.wheel.Rollers[4].r[1];
  m.wheel.Rollers[4].OutPort.r[2] = m.wheel.Rollers[4].r[2];
  m.wheel.Rollers[4].OutPort.r[3] = m.wheel.Rollers[4].r[3];
  m.wheel.Rollers[4].OutPort.v[1] = m.wheel.Rollers[4].v[1];
  m.wheel.Rollers[4].OutPort.v[2] = m.wheel.Rollers[4].v[2];
  m.wheel.Rollers[4].OutPort.v[3] = m.wheel.Rollers[4].v[3];
  m.wheel.Rollers[4].OutPort.a[1] = m.wheel.Rollers[4].a[1];
  m.wheel.Rollers[4].OutPort.a[2] = m.wheel.Rollers[4].a[2];
  m.wheel.Rollers[4].OutPort.a[3] = m.wheel.Rollers[4].a[3];
  m.wheel.Rollers[4].OutPort.T[1,1] = m.wheel.Rollers[4].T[1,1];
  m.wheel.Rollers[4].OutPort.T[1,2] = m.wheel.Rollers[4].T[1,2];
  m.wheel.Rollers[4].OutPort.T[1,3] = m.wheel.Rollers[4].T[1,3];
  m.wheel.Rollers[4].OutPort.T[2,1] = m.wheel.Rollers[4].T[2,1];
  m.wheel.Rollers[4].OutPort.T[2,2] = m.wheel.Rollers[4].T[2,2];
  m.wheel.Rollers[4].OutPort.T[2,3] = m.wheel.Rollers[4].T[2,3];
  m.wheel.Rollers[4].OutPort.T[3,1] = m.wheel.Rollers[4].T[3,1];
  m.wheel.Rollers[4].OutPort.T[3,2] = m.wheel.Rollers[4].T[3,2];
  m.wheel.Rollers[4].OutPort.T[3,3] = m.wheel.Rollers[4].T[3,3];
  m.wheel.Rollers[4].OutPort.omega[1] = m.wheel.Rollers[4].T[1,1] * m.wheel.Rollers[4].omega[1] + m.wheel.Rollers[4].T[1,2] * m.wheel.Rollers[4].omega[2] + m.wheel.Rollers[4].T[1,3] * m.wheel.Rollers[4].omega[3];
  m.wheel.Rollers[4].OutPort.omega[2] = m.wheel.Rollers[4].T[2,1] * m.wheel.Rollers[4].omega[1] + m.wheel.Rollers[4].T[2,2] * m.wheel.Rollers[4].omega[2] + m.wheel.Rollers[4].T[2,3] * m.wheel.Rollers[4].omega[3];
  m.wheel.Rollers[4].OutPort.omega[3] = m.wheel.Rollers[4].T[3,1] * m.wheel.Rollers[4].omega[1] + m.wheel.Rollers[4].T[3,2] * m.wheel.Rollers[4].omega[2] + m.wheel.Rollers[4].T[3,3] * m.wheel.Rollers[4].omega[3];
  m.wheel.Rollers[4].OutPort.epsilon[1] = m.wheel.Rollers[4].T[1,1] * m.wheel.Rollers[4].epsilon[1] + m.wheel.Rollers[4].T[1,2] * m.wheel.Rollers[4].epsilon[2] + m.wheel.Rollers[4].T[1,3] * m.wheel.Rollers[4].epsilon[3];
  m.wheel.Rollers[4].OutPort.epsilon[2] = m.wheel.Rollers[4].T[2,1] * m.wheel.Rollers[4].epsilon[1] + m.wheel.Rollers[4].T[2,2] * m.wheel.Rollers[4].epsilon[2] + m.wheel.Rollers[4].T[2,3] * m.wheel.Rollers[4].epsilon[3];
  m.wheel.Rollers[4].OutPort.epsilon[3] = m.wheel.Rollers[4].T[3,1] * m.wheel.Rollers[4].epsilon[1] + m.wheel.Rollers[4].T[3,2] * m.wheel.Rollers[4].epsilon[2] + m.wheel.Rollers[4].T[3,3] * m.wheel.Rollers[4].epsilon[3];
  m.wheel.Rollers[5].crosses[1,1] = (m.wheel.Rollers[5].InPorts[1].P[2] - m.wheel.Rollers[5].r[2]) * m.wheel.Rollers[5].InPorts[1].F[3] - (m.wheel.Rollers[5].InPorts[1].P[3] - m.wheel.Rollers[5].r[3]) * m.wheel.Rollers[5].InPorts[1].F[2];
  m.wheel.Rollers[5].crosses[1,2] = (m.wheel.Rollers[5].InPorts[1].P[3] - m.wheel.Rollers[5].r[3]) * m.wheel.Rollers[5].InPorts[1].F[1] - (m.wheel.Rollers[5].InPorts[1].P[1] - m.wheel.Rollers[5].r[1]) * m.wheel.Rollers[5].InPorts[1].F[3];
  m.wheel.Rollers[5].crosses[1,3] = (m.wheel.Rollers[5].InPorts[1].P[1] - m.wheel.Rollers[5].r[1]) * m.wheel.Rollers[5].InPorts[1].F[2] - (m.wheel.Rollers[5].InPorts[1].P[2] - m.wheel.Rollers[5].r[2]) * m.wheel.Rollers[5].InPorts[1].F[1];
  m.wheel.Rollers[5].crosses[2,1] = (m.wheel.Rollers[5].InPorts[2].P[2] - m.wheel.Rollers[5].r[2]) * m.wheel.Rollers[5].InPorts[2].F[3] - (m.wheel.Rollers[5].InPorts[2].P[3] - m.wheel.Rollers[5].r[3]) * m.wheel.Rollers[5].InPorts[2].F[2];
  m.wheel.Rollers[5].crosses[2,2] = (m.wheel.Rollers[5].InPorts[2].P[3] - m.wheel.Rollers[5].r[3]) * m.wheel.Rollers[5].InPorts[2].F[1] - (m.wheel.Rollers[5].InPorts[2].P[1] - m.wheel.Rollers[5].r[1]) * m.wheel.Rollers[5].InPorts[2].F[3];
  m.wheel.Rollers[5].crosses[2,3] = (m.wheel.Rollers[5].InPorts[2].P[1] - m.wheel.Rollers[5].r[1]) * m.wheel.Rollers[5].InPorts[2].F[2] - (m.wheel.Rollers[5].InPorts[2].P[2] - m.wheel.Rollers[5].r[2]) * m.wheel.Rollers[5].InPorts[2].F[1];
  m.wheel.Rollers[5].F[1] = m.wheel.Rollers[5].InPorts[1].F[1] + m.wheel.Rollers[5].InPorts[2].F[1];
  m.wheel.Rollers[5].F[2] = -0.05 + m.wheel.Rollers[5].InPorts[1].F[2] + m.wheel.Rollers[5].InPorts[2].F[2];
  m.wheel.Rollers[5].F[3] = m.wheel.Rollers[5].InPorts[1].F[3] + m.wheel.Rollers[5].InPorts[2].F[3];
  m.wheel.Rollers[5].M[1] = m.wheel.Rollers[5].InPorts[1].M[1] + m.wheel.Rollers[5].crosses[1,1] + m.wheel.Rollers[5].InPorts[2].M[1] + m.wheel.Rollers[5].crosses[2,1];
  m.wheel.Rollers[5].M[2] = m.wheel.Rollers[5].InPorts[1].M[2] + m.wheel.Rollers[5].crosses[1,2] + m.wheel.Rollers[5].InPorts[2].M[2] + m.wheel.Rollers[5].crosses[2,2];
  m.wheel.Rollers[5].M[3] = m.wheel.Rollers[5].InPorts[1].M[3] + m.wheel.Rollers[5].crosses[1,3] + m.wheel.Rollers[5].InPorts[2].M[3] + m.wheel.Rollers[5].crosses[2,3];
  der(m.wheel.Rollers[5].Active) = 0.0;
  der(m.wheel.Rollers[5].r[1]) = m.wheel.Rollers[5].v[1] * m.wheel.Rollers[5].Active;
  der(m.wheel.Rollers[5].r[2]) = m.wheel.Rollers[5].v[2] * m.wheel.Rollers[5].Active;
  der(m.wheel.Rollers[5].r[3]) = m.wheel.Rollers[5].v[3] * m.wheel.Rollers[5].Active;
  der(m.wheel.Rollers[5].v[1]) = m.wheel.Rollers[5].a[1] * m.wheel.Rollers[5].Active;
  der(m.wheel.Rollers[5].v[2]) = m.wheel.Rollers[5].a[2] * m.wheel.Rollers[5].Active;
  der(m.wheel.Rollers[5].v[3]) = m.wheel.Rollers[5].a[3] * m.wheel.Rollers[5].Active;
  m.wheel.Rollers[5].a[1] * 0.05 = m.wheel.Rollers[5].F[1];
  m.wheel.Rollers[5].a[2] * 0.05 = m.wheel.Rollers[5].F[2];
  m.wheel.Rollers[5].a[3] * 0.05 = m.wheel.Rollers[5].F[3];
  {der(m.wheel.Rollers[5].q[1]), der(m.wheel.Rollers[5].q[2]), der(m.wheel.Rollers[5].q[3]), der(m.wheel.Rollers[5].q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Rollers[5].q[1], m.wheel.Rollers[5].q[2], m.wheel.Rollers[5].q[3], m.wheel.Rollers[5].q[4]}, {0.0, m.wheel.Rollers[5].omega[1], m.wheel.Rollers[5].omega[2], m.wheel.Rollers[5].omega[3]}) * 0.5 * m.wheel.Rollers[5].Active;
  der(m.wheel.Rollers[5].omega[1]) = m.wheel.Rollers[5].epsilon[1] * m.wheel.Rollers[5].Active;
  der(m.wheel.Rollers[5].omega[2]) = m.wheel.Rollers[5].epsilon[2] * m.wheel.Rollers[5].Active;
  der(m.wheel.Rollers[5].omega[3]) = m.wheel.Rollers[5].epsilon[3] * m.wheel.Rollers[5].Active;
  m.wheel.Rollers[5].T = MbsLite.Util.Quaternions.QToT({m.wheel.Rollers[5].q[1], m.wheel.Rollers[5].q[2], m.wheel.Rollers[5].q[3], m.wheel.Rollers[5].q[4]});
  5.699141943371693e-07 * m.wheel.Rollers[5].epsilon[1] = m.wheel.Rollers[5].T[1,1] * m.wheel.Rollers[5].M[1] + m.wheel.Rollers[5].T[2,1] * m.wheel.Rollers[5].M[2] + m.wheel.Rollers[5].T[3,1] * m.wheel.Rollers[5].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[5].epsilon[2] + m.wheel.Rollers[5].omega[3] * 5.699141943371693e-07 * m.wheel.Rollers[5].omega[1] - m.wheel.Rollers[5].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[5].omega[3] = m.wheel.Rollers[5].T[1,2] * m.wheel.Rollers[5].M[1] + m.wheel.Rollers[5].T[2,2] * m.wheel.Rollers[5].M[2] + m.wheel.Rollers[5].T[3,2] * m.wheel.Rollers[5].M[3];
  3.8838269181324e-06 * m.wheel.Rollers[5].epsilon[3] + m.wheel.Rollers[5].omega[1] * 3.8838269181324e-06 * m.wheel.Rollers[5].omega[2] - m.wheel.Rollers[5].omega[2] * 5.699141943371693e-07 * m.wheel.Rollers[5].omega[1] = m.wheel.Rollers[5].T[1,3] * m.wheel.Rollers[5].M[1] + m.wheel.Rollers[5].T[2,3] * m.wheel.Rollers[5].M[2] + m.wheel.Rollers[5].T[3,3] * m.wheel.Rollers[5].M[3];
  m.wheel.Rollers[5].OutPort.r[1] = m.wheel.Rollers[5].r[1];
  m.wheel.Rollers[5].OutPort.r[2] = m.wheel.Rollers[5].r[2];
  m.wheel.Rollers[5].OutPort.r[3] = m.wheel.Rollers[5].r[3];
  m.wheel.Rollers[5].OutPort.v[1] = m.wheel.Rollers[5].v[1];
  m.wheel.Rollers[5].OutPort.v[2] = m.wheel.Rollers[5].v[2];
  m.wheel.Rollers[5].OutPort.v[3] = m.wheel.Rollers[5].v[3];
  m.wheel.Rollers[5].OutPort.a[1] = m.wheel.Rollers[5].a[1];
  m.wheel.Rollers[5].OutPort.a[2] = m.wheel.Rollers[5].a[2];
  m.wheel.Rollers[5].OutPort.a[3] = m.wheel.Rollers[5].a[3];
  m.wheel.Rollers[5].OutPort.T[1,1] = m.wheel.Rollers[5].T[1,1];
  m.wheel.Rollers[5].OutPort.T[1,2] = m.wheel.Rollers[5].T[1,2];
  m.wheel.Rollers[5].OutPort.T[1,3] = m.wheel.Rollers[5].T[1,3];
  m.wheel.Rollers[5].OutPort.T[2,1] = m.wheel.Rollers[5].T[2,1];
  m.wheel.Rollers[5].OutPort.T[2,2] = m.wheel.Rollers[5].T[2,2];
  m.wheel.Rollers[5].OutPort.T[2,3] = m.wheel.Rollers[5].T[2,3];
  m.wheel.Rollers[5].OutPort.T[3,1] = m.wheel.Rollers[5].T[3,1];
  m.wheel.Rollers[5].OutPort.T[3,2] = m.wheel.Rollers[5].T[3,2];
  m.wheel.Rollers[5].OutPort.T[3,3] = m.wheel.Rollers[5].T[3,3];
  m.wheel.Rollers[5].OutPort.omega[1] = m.wheel.Rollers[5].T[1,1] * m.wheel.Rollers[5].omega[1] + m.wheel.Rollers[5].T[1,2] * m.wheel.Rollers[5].omega[2] + m.wheel.Rollers[5].T[1,3] * m.wheel.Rollers[5].omega[3];
  m.wheel.Rollers[5].OutPort.omega[2] = m.wheel.Rollers[5].T[2,1] * m.wheel.Rollers[5].omega[1] + m.wheel.Rollers[5].T[2,2] * m.wheel.Rollers[5].omega[2] + m.wheel.Rollers[5].T[2,3] * m.wheel.Rollers[5].omega[3];
  m.wheel.Rollers[5].OutPort.omega[3] = m.wheel.Rollers[5].T[3,1] * m.wheel.Rollers[5].omega[1] + m.wheel.Rollers[5].T[3,2] * m.wheel.Rollers[5].omega[2] + m.wheel.Rollers[5].T[3,3] * m.wheel.Rollers[5].omega[3];
  m.wheel.Rollers[5].OutPort.epsilon[1] = m.wheel.Rollers[5].T[1,1] * m.wheel.Rollers[5].epsilon[1] + m.wheel.Rollers[5].T[1,2] * m.wheel.Rollers[5].epsilon[2] + m.wheel.Rollers[5].T[1,3] * m.wheel.Rollers[5].epsilon[3];
  m.wheel.Rollers[5].OutPort.epsilon[2] = m.wheel.Rollers[5].T[2,1] * m.wheel.Rollers[5].epsilon[1] + m.wheel.Rollers[5].T[2,2] * m.wheel.Rollers[5].epsilon[2] + m.wheel.Rollers[5].T[2,3] * m.wheel.Rollers[5].epsilon[3];
  m.wheel.Rollers[5].OutPort.epsilon[3] = m.wheel.Rollers[5].T[3,1] * m.wheel.Rollers[5].epsilon[1] + m.wheel.Rollers[5].T[3,2] * m.wheel.Rollers[5].epsilon[2] + m.wheel.Rollers[5].T[3,3] * m.wheel.Rollers[5].epsilon[3];
  m.wheel.Joints[1].RA[1] = m.wheel.Joints[1].InPortA.r[1];
  m.wheel.Joints[1].RA[2] = m.wheel.Joints[1].InPortA.r[2];
  m.wheel.Joints[1].RA[3] = m.wheel.Joints[1].InPortA.r[3];
  m.wheel.Joints[1].RB[1] = m.wheel.Joints[1].InPortB.r[1] + m.wheel.Joints[1].InPortB.T[1,2] * -0.04045084971874738;
  m.wheel.Joints[1].RB[2] = m.wheel.Joints[1].InPortB.r[2] + m.wheel.Joints[1].InPortB.T[2,2] * -0.04045084971874738;
  m.wheel.Joints[1].RB[3] = m.wheel.Joints[1].InPortB.r[3] + m.wheel.Joints[1].InPortB.T[3,2] * -0.04045084971874738;
  m.wheel.Joints[1].vA = MbsLite.Util.Euler({m.wheel.Joints[1].InPortA.r[1], m.wheel.Joints[1].InPortA.r[2], m.wheel.Joints[1].InPortA.r[3]}, {m.wheel.Joints[1].RA[1], m.wheel.Joints[1].RA[2], m.wheel.Joints[1].RA[3]}, {m.wheel.Joints[1].InPortA.v[1], m.wheel.Joints[1].InPortA.v[2], m.wheel.Joints[1].InPortA.v[3]}, {m.wheel.Joints[1].InPortA.omega[1], m.wheel.Joints[1].InPortA.omega[2], m.wheel.Joints[1].InPortA.omega[3]});
  m.wheel.Joints[1].vB = MbsLite.Util.Euler({m.wheel.Joints[1].InPortB.r[1], m.wheel.Joints[1].InPortB.r[2], m.wheel.Joints[1].InPortB.r[3]}, {m.wheel.Joints[1].RB[1], m.wheel.Joints[1].RB[2], m.wheel.Joints[1].RB[3]}, {m.wheel.Joints[1].InPortB.v[1], m.wheel.Joints[1].InPortB.v[2], m.wheel.Joints[1].InPortB.v[3]}, {m.wheel.Joints[1].InPortB.omega[1], m.wheel.Joints[1].InPortB.omega[2], m.wheel.Joints[1].InPortB.omega[3]});
  m.wheel.Joints[1].vA[1] = m.wheel.Joints[1].vB[1];
  m.wheel.Joints[1].vA[2] = m.wheel.Joints[1].vB[2];
  m.wheel.Joints[1].vA[3] = m.wheel.Joints[1].vB[3];
  m.wheel.Joints[1].nAi[1] = m.wheel.Joints[1].InPortA.T[1,1];
  m.wheel.Joints[1].nAi[2] = m.wheel.Joints[1].InPortA.T[2,1];
  m.wheel.Joints[1].nAi[3] = m.wheel.Joints[1].InPortA.T[3,1];
  m.wheel.Joints[1].nBi[1] = m.wheel.Joints[1].InPortB.T[1,1];
  m.wheel.Joints[1].nBi[2] = m.wheel.Joints[1].InPortB.T[2,1];
  m.wheel.Joints[1].nBi[3] = m.wheel.Joints[1].InPortB.T[3,1];
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nBi[1], 0.01, 1e-05), \"looks like joint joint1 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1], m.wheel.Joints[1].nBi[2], m.wheel.Joints[1].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1] - m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nBi[2] - m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nBi[3] - m.wheel.Joints[1].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nBi[2], 0.01, 1e-05), \"looks like joint joint1 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1], m.wheel.Joints[1].nBi[2], m.wheel.Joints[1].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1] - m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nBi[2] - m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nBi[3] - m.wheel.Joints[1].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[1].nAi[3], m.wheel.Joints[1].nBi[3], 0.01, 1e-05), \"looks like joint joint1 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1], m.wheel.Joints[1].nBi[2], m.wheel.Joints[1].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1] - m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nBi[2] - m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nBi[3] - m.wheel.Joints[1].nAi[3]}, \", \"));
  m.wheel.Joints[1].epsilonr[1] = m.wheel.Joints[1].InPortB.epsilon[1] - m.wheel.Joints[1].InPortA.epsilon[1] - (m.wheel.Joints[1].InPortA.omega[2] * m.wheel.Joints[1].InPortB.omega[3] - m.wheel.Joints[1].InPortA.omega[3] * m.wheel.Joints[1].InPortB.omega[2]);
  m.wheel.Joints[1].epsilonr[2] = m.wheel.Joints[1].InPortB.epsilon[2] - m.wheel.Joints[1].InPortA.epsilon[2] - (m.wheel.Joints[1].InPortA.omega[3] * m.wheel.Joints[1].InPortB.omega[1] - m.wheel.Joints[1].InPortA.omega[1] * m.wheel.Joints[1].InPortB.omega[3]);
  m.wheel.Joints[1].epsilonr[3] = m.wheel.Joints[1].InPortB.epsilon[3] - m.wheel.Joints[1].InPortA.epsilon[3] - (m.wheel.Joints[1].InPortA.omega[1] * m.wheel.Joints[1].InPortB.omega[2] - m.wheel.Joints[1].InPortA.omega[2] * m.wheel.Joints[1].InPortB.omega[1]);
  m.wheel.Joints[1].epsilonr[1] = m.wheel.Joints[1].nAi[1] * m.wheel.Joints[1].lambda;
  m.wheel.Joints[1].epsilonr[2] = m.wheel.Joints[1].nAi[2] * m.wheel.Joints[1].lambda;
  m.wheel.Joints[1].epsilonr[3] = m.wheel.Joints[1].nAi[3] * m.wheel.Joints[1].lambda;
  m.wheel.Joints[1].M = m.wheel.Joints[1].OutPortA.M[1] * m.wheel.Joints[1].nAi[1] + m.wheel.Joints[1].OutPortA.M[2] * m.wheel.Joints[1].nAi[2] + m.wheel.Joints[1].OutPortA.M[3] * m.wheel.Joints[1].nAi[3];
  m.wheel.Joints[1].M = 0.0;
  m.wheel.Joints[1].OutPortA.P[1] = m.wheel.Joints[1].RA[1];
  m.wheel.Joints[1].OutPortA.P[2] = m.wheel.Joints[1].RA[2];
  m.wheel.Joints[1].OutPortA.P[3] = m.wheel.Joints[1].RA[3];
  m.wheel.Joints[1].OutPortB.P[1] = m.wheel.Joints[1].RB[1];
  m.wheel.Joints[1].OutPortB.P[2] = m.wheel.Joints[1].RB[2];
  m.wheel.Joints[1].OutPortB.P[3] = m.wheel.Joints[1].RB[3];
  der(m.wheel.Joints[1].mu) = m.wheel.Joints[1].lambda;
  der(m.wheel.Joints[1].angle) = m.wheel.Joints[1].mu;
  m.wheel.Joints[1].OutPortA.F[1] + m.wheel.Joints[1].OutPortB.F[1] = 0.0;
  m.wheel.Joints[1].OutPortA.F[2] + m.wheel.Joints[1].OutPortB.F[2] = 0.0;
  m.wheel.Joints[1].OutPortA.F[3] + m.wheel.Joints[1].OutPortB.F[3] = 0.0;
  m.wheel.Joints[1].OutPortA.M[1] + m.wheel.Joints[1].OutPortB.M[1] = 0.0;
  m.wheel.Joints[1].OutPortA.M[2] + m.wheel.Joints[1].OutPortB.M[2] = 0.0;
  m.wheel.Joints[1].OutPortA.M[3] + m.wheel.Joints[1].OutPortB.M[3] = 0.0;
  m.wheel.Joints[2].RA[1] = m.wheel.Joints[2].InPortA.r[1];
  m.wheel.Joints[2].RA[2] = m.wheel.Joints[2].InPortA.r[2];
  m.wheel.Joints[2].RA[3] = m.wheel.Joints[2].InPortA.r[3];
  m.wheel.Joints[2].RB[1] = m.wheel.Joints[2].InPortB.r[1] + m.wheel.Joints[2].InPortB.T[1,1] * 0.03847104421469068 + m.wheel.Joints[2].InPortB.T[1,2] * -0.0125;
  m.wheel.Joints[2].RB[2] = m.wheel.Joints[2].InPortB.r[2] + m.wheel.Joints[2].InPortB.T[2,1] * 0.03847104421469068 + m.wheel.Joints[2].InPortB.T[2,2] * -0.0125;
  m.wheel.Joints[2].RB[3] = m.wheel.Joints[2].InPortB.r[3] + m.wheel.Joints[2].InPortB.T[3,1] * 0.03847104421469068 + m.wheel.Joints[2].InPortB.T[3,2] * -0.0125;
  m.wheel.Joints[2].vA = MbsLite.Util.Euler({m.wheel.Joints[2].InPortA.r[1], m.wheel.Joints[2].InPortA.r[2], m.wheel.Joints[2].InPortA.r[3]}, {m.wheel.Joints[2].RA[1], m.wheel.Joints[2].RA[2], m.wheel.Joints[2].RA[3]}, {m.wheel.Joints[2].InPortA.v[1], m.wheel.Joints[2].InPortA.v[2], m.wheel.Joints[2].InPortA.v[3]}, {m.wheel.Joints[2].InPortA.omega[1], m.wheel.Joints[2].InPortA.omega[2], m.wheel.Joints[2].InPortA.omega[3]});
  m.wheel.Joints[2].vB = MbsLite.Util.Euler({m.wheel.Joints[2].InPortB.r[1], m.wheel.Joints[2].InPortB.r[2], m.wheel.Joints[2].InPortB.r[3]}, {m.wheel.Joints[2].RB[1], m.wheel.Joints[2].RB[2], m.wheel.Joints[2].RB[3]}, {m.wheel.Joints[2].InPortB.v[1], m.wheel.Joints[2].InPortB.v[2], m.wheel.Joints[2].InPortB.v[3]}, {m.wheel.Joints[2].InPortB.omega[1], m.wheel.Joints[2].InPortB.omega[2], m.wheel.Joints[2].InPortB.omega[3]});
  m.wheel.Joints[2].vA[1] = m.wheel.Joints[2].vB[1];
  m.wheel.Joints[2].vA[2] = m.wheel.Joints[2].vB[2];
  m.wheel.Joints[2].vA[3] = m.wheel.Joints[2].vB[3];
  m.wheel.Joints[2].nAi[1] = m.wheel.Joints[2].InPortA.T[1,1];
  m.wheel.Joints[2].nAi[2] = m.wheel.Joints[2].InPortA.T[2,1];
  m.wheel.Joints[2].nAi[3] = m.wheel.Joints[2].InPortA.T[3,1];
  m.wheel.Joints[2].nBi[1] = m.wheel.Joints[2].InPortB.T[1,1] * 0.3090169943749475 + m.wheel.Joints[2].InPortB.T[1,2] * 0.9510565162951536;
  m.wheel.Joints[2].nBi[2] = m.wheel.Joints[2].InPortB.T[2,1] * 0.3090169943749475 + m.wheel.Joints[2].InPortB.T[2,2] * 0.9510565162951536;
  m.wheel.Joints[2].nBi[3] = m.wheel.Joints[2].InPortB.T[3,1] * 0.3090169943749475 + m.wheel.Joints[2].InPortB.T[3,2] * 0.9510565162951536;
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nBi[1], 0.01, 1e-05), \"looks like joint joint2 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1], m.wheel.Joints[2].nBi[2], m.wheel.Joints[2].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1] - m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nBi[2] - m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nBi[3] - m.wheel.Joints[2].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nBi[2], 0.01, 1e-05), \"looks like joint joint2 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1], m.wheel.Joints[2].nBi[2], m.wheel.Joints[2].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1] - m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nBi[2] - m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nBi[3] - m.wheel.Joints[2].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[2].nAi[3], m.wheel.Joints[2].nBi[3], 0.01, 1e-05), \"looks like joint joint2 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1], m.wheel.Joints[2].nBi[2], m.wheel.Joints[2].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1] - m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nBi[2] - m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nBi[3] - m.wheel.Joints[2].nAi[3]}, \", \"));
  m.wheel.Joints[2].epsilonr[1] = m.wheel.Joints[2].InPortB.epsilon[1] - m.wheel.Joints[2].InPortA.epsilon[1] - (m.wheel.Joints[2].InPortA.omega[2] * m.wheel.Joints[2].InPortB.omega[3] - m.wheel.Joints[2].InPortA.omega[3] * m.wheel.Joints[2].InPortB.omega[2]);
  m.wheel.Joints[2].epsilonr[2] = m.wheel.Joints[2].InPortB.epsilon[2] - m.wheel.Joints[2].InPortA.epsilon[2] - (m.wheel.Joints[2].InPortA.omega[3] * m.wheel.Joints[2].InPortB.omega[1] - m.wheel.Joints[2].InPortA.omega[1] * m.wheel.Joints[2].InPortB.omega[3]);
  m.wheel.Joints[2].epsilonr[3] = m.wheel.Joints[2].InPortB.epsilon[3] - m.wheel.Joints[2].InPortA.epsilon[3] - (m.wheel.Joints[2].InPortA.omega[1] * m.wheel.Joints[2].InPortB.omega[2] - m.wheel.Joints[2].InPortA.omega[2] * m.wheel.Joints[2].InPortB.omega[1]);
  m.wheel.Joints[2].epsilonr[1] = m.wheel.Joints[2].nAi[1] * m.wheel.Joints[2].lambda;
  m.wheel.Joints[2].epsilonr[2] = m.wheel.Joints[2].nAi[2] * m.wheel.Joints[2].lambda;
  m.wheel.Joints[2].epsilonr[3] = m.wheel.Joints[2].nAi[3] * m.wheel.Joints[2].lambda;
  m.wheel.Joints[2].M = m.wheel.Joints[2].OutPortA.M[1] * m.wheel.Joints[2].nAi[1] + m.wheel.Joints[2].OutPortA.M[2] * m.wheel.Joints[2].nAi[2] + m.wheel.Joints[2].OutPortA.M[3] * m.wheel.Joints[2].nAi[3];
  m.wheel.Joints[2].M = 0.0;
  m.wheel.Joints[2].OutPortA.P[1] = m.wheel.Joints[2].RA[1];
  m.wheel.Joints[2].OutPortA.P[2] = m.wheel.Joints[2].RA[2];
  m.wheel.Joints[2].OutPortA.P[3] = m.wheel.Joints[2].RA[3];
  m.wheel.Joints[2].OutPortB.P[1] = m.wheel.Joints[2].RB[1];
  m.wheel.Joints[2].OutPortB.P[2] = m.wheel.Joints[2].RB[2];
  m.wheel.Joints[2].OutPortB.P[3] = m.wheel.Joints[2].RB[3];
  der(m.wheel.Joints[2].mu) = m.wheel.Joints[2].lambda;
  der(m.wheel.Joints[2].angle) = m.wheel.Joints[2].mu;
  m.wheel.Joints[2].OutPortA.F[1] + m.wheel.Joints[2].OutPortB.F[1] = 0.0;
  m.wheel.Joints[2].OutPortA.F[2] + m.wheel.Joints[2].OutPortB.F[2] = 0.0;
  m.wheel.Joints[2].OutPortA.F[3] + m.wheel.Joints[2].OutPortB.F[3] = 0.0;
  m.wheel.Joints[2].OutPortA.M[1] + m.wheel.Joints[2].OutPortB.M[1] = 0.0;
  m.wheel.Joints[2].OutPortA.M[2] + m.wheel.Joints[2].OutPortB.M[2] = 0.0;
  m.wheel.Joints[2].OutPortA.M[3] + m.wheel.Joints[2].OutPortB.M[3] = 0.0;
  m.wheel.Joints[3].RA[1] = m.wheel.Joints[3].InPortA.r[1];
  m.wheel.Joints[3].RA[2] = m.wheel.Joints[3].InPortA.r[2];
  m.wheel.Joints[3].RA[3] = m.wheel.Joints[3].InPortA.r[3];
  m.wheel.Joints[3].RB[1] = m.wheel.Joints[3].InPortB.r[1] + m.wheel.Joints[3].InPortB.T[1,1] * 0.02377641290737885 + m.wheel.Joints[3].InPortB.T[1,2] * 0.03272542485937369;
  m.wheel.Joints[3].RB[2] = m.wheel.Joints[3].InPortB.r[2] + m.wheel.Joints[3].InPortB.T[2,1] * 0.02377641290737885 + m.wheel.Joints[3].InPortB.T[2,2] * 0.03272542485937369;
  m.wheel.Joints[3].RB[3] = m.wheel.Joints[3].InPortB.r[3] + m.wheel.Joints[3].InPortB.T[3,1] * 0.02377641290737885 + m.wheel.Joints[3].InPortB.T[3,2] * 0.03272542485937369;
  m.wheel.Joints[3].vA = MbsLite.Util.Euler({m.wheel.Joints[3].InPortA.r[1], m.wheel.Joints[3].InPortA.r[2], m.wheel.Joints[3].InPortA.r[3]}, {m.wheel.Joints[3].RA[1], m.wheel.Joints[3].RA[2], m.wheel.Joints[3].RA[3]}, {m.wheel.Joints[3].InPortA.v[1], m.wheel.Joints[3].InPortA.v[2], m.wheel.Joints[3].InPortA.v[3]}, {m.wheel.Joints[3].InPortA.omega[1], m.wheel.Joints[3].InPortA.omega[2], m.wheel.Joints[3].InPortA.omega[3]});
  m.wheel.Joints[3].vB = MbsLite.Util.Euler({m.wheel.Joints[3].InPortB.r[1], m.wheel.Joints[3].InPortB.r[2], m.wheel.Joints[3].InPortB.r[3]}, {m.wheel.Joints[3].RB[1], m.wheel.Joints[3].RB[2], m.wheel.Joints[3].RB[3]}, {m.wheel.Joints[3].InPortB.v[1], m.wheel.Joints[3].InPortB.v[2], m.wheel.Joints[3].InPortB.v[3]}, {m.wheel.Joints[3].InPortB.omega[1], m.wheel.Joints[3].InPortB.omega[2], m.wheel.Joints[3].InPortB.omega[3]});
  m.wheel.Joints[3].vA[1] = m.wheel.Joints[3].vB[1];
  m.wheel.Joints[3].vA[2] = m.wheel.Joints[3].vB[2];
  m.wheel.Joints[3].vA[3] = m.wheel.Joints[3].vB[3];
  m.wheel.Joints[3].nAi[1] = m.wheel.Joints[3].InPortA.T[1,1];
  m.wheel.Joints[3].nAi[2] = m.wheel.Joints[3].InPortA.T[2,1];
  m.wheel.Joints[3].nAi[3] = m.wheel.Joints[3].InPortA.T[3,1];
  m.wheel.Joints[3].nBi[1] = m.wheel.Joints[3].InPortB.T[1,1] * -0.8090169943749475 + m.wheel.Joints[3].InPortB.T[1,2] * 0.5877852522924732;
  m.wheel.Joints[3].nBi[2] = m.wheel.Joints[3].InPortB.T[2,1] * -0.8090169943749475 + m.wheel.Joints[3].InPortB.T[2,2] * 0.5877852522924732;
  m.wheel.Joints[3].nBi[3] = m.wheel.Joints[3].InPortB.T[3,1] * -0.8090169943749475 + m.wheel.Joints[3].InPortB.T[3,2] * 0.5877852522924732;
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[3].nAi[1], m.wheel.Joints[3].nBi[1], 0.01, 1e-05), \"looks like joint joint3 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nAi[1], m.wheel.Joints[3].nAi[2], m.wheel.Joints[3].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nBi[1], m.wheel.Joints[3].nBi[2], m.wheel.Joints[3].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nBi[1] - m.wheel.Joints[3].nAi[1], m.wheel.Joints[3].nBi[2] - m.wheel.Joints[3].nAi[2], m.wheel.Joints[3].nBi[3] - m.wheel.Joints[3].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[3].nAi[2], m.wheel.Joints[3].nBi[2], 0.01, 1e-05), \"looks like joint joint3 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nAi[1], m.wheel.Joints[3].nAi[2], m.wheel.Joints[3].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nBi[1], m.wheel.Joints[3].nBi[2], m.wheel.Joints[3].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nBi[1] - m.wheel.Joints[3].nAi[1], m.wheel.Joints[3].nBi[2] - m.wheel.Joints[3].nAi[2], m.wheel.Joints[3].nBi[3] - m.wheel.Joints[3].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[3].nAi[3], m.wheel.Joints[3].nBi[3], 0.01, 1e-05), \"looks like joint joint3 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nAi[1], m.wheel.Joints[3].nAi[2], m.wheel.Joints[3].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nBi[1], m.wheel.Joints[3].nBi[2], m.wheel.Joints[3].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[3].nBi[1] - m.wheel.Joints[3].nAi[1], m.wheel.Joints[3].nBi[2] - m.wheel.Joints[3].nAi[2], m.wheel.Joints[3].nBi[3] - m.wheel.Joints[3].nAi[3]}, \", \"));
  m.wheel.Joints[3].epsilonr[1] = m.wheel.Joints[3].InPortB.epsilon[1] - m.wheel.Joints[3].InPortA.epsilon[1] - (m.wheel.Joints[3].InPortA.omega[2] * m.wheel.Joints[3].InPortB.omega[3] - m.wheel.Joints[3].InPortA.omega[3] * m.wheel.Joints[3].InPortB.omega[2]);
  m.wheel.Joints[3].epsilonr[2] = m.wheel.Joints[3].InPortB.epsilon[2] - m.wheel.Joints[3].InPortA.epsilon[2] - (m.wheel.Joints[3].InPortA.omega[3] * m.wheel.Joints[3].InPortB.omega[1] - m.wheel.Joints[3].InPortA.omega[1] * m.wheel.Joints[3].InPortB.omega[3]);
  m.wheel.Joints[3].epsilonr[3] = m.wheel.Joints[3].InPortB.epsilon[3] - m.wheel.Joints[3].InPortA.epsilon[3] - (m.wheel.Joints[3].InPortA.omega[1] * m.wheel.Joints[3].InPortB.omega[2] - m.wheel.Joints[3].InPortA.omega[2] * m.wheel.Joints[3].InPortB.omega[1]);
  m.wheel.Joints[3].epsilonr[1] = m.wheel.Joints[3].nAi[1] * m.wheel.Joints[3].lambda;
  m.wheel.Joints[3].epsilonr[2] = m.wheel.Joints[3].nAi[2] * m.wheel.Joints[3].lambda;
  m.wheel.Joints[3].epsilonr[3] = m.wheel.Joints[3].nAi[3] * m.wheel.Joints[3].lambda;
  m.wheel.Joints[3].M = m.wheel.Joints[3].OutPortA.M[1] * m.wheel.Joints[3].nAi[1] + m.wheel.Joints[3].OutPortA.M[2] * m.wheel.Joints[3].nAi[2] + m.wheel.Joints[3].OutPortA.M[3] * m.wheel.Joints[3].nAi[3];
  m.wheel.Joints[3].M = 0.0;
  m.wheel.Joints[3].OutPortA.P[1] = m.wheel.Joints[3].RA[1];
  m.wheel.Joints[3].OutPortA.P[2] = m.wheel.Joints[3].RA[2];
  m.wheel.Joints[3].OutPortA.P[3] = m.wheel.Joints[3].RA[3];
  m.wheel.Joints[3].OutPortB.P[1] = m.wheel.Joints[3].RB[1];
  m.wheel.Joints[3].OutPortB.P[2] = m.wheel.Joints[3].RB[2];
  m.wheel.Joints[3].OutPortB.P[3] = m.wheel.Joints[3].RB[3];
  der(m.wheel.Joints[3].mu) = m.wheel.Joints[3].lambda;
  der(m.wheel.Joints[3].angle) = m.wheel.Joints[3].mu;
  m.wheel.Joints[3].OutPortA.F[1] + m.wheel.Joints[3].OutPortB.F[1] = 0.0;
  m.wheel.Joints[3].OutPortA.F[2] + m.wheel.Joints[3].OutPortB.F[2] = 0.0;
  m.wheel.Joints[3].OutPortA.F[3] + m.wheel.Joints[3].OutPortB.F[3] = 0.0;
  m.wheel.Joints[3].OutPortA.M[1] + m.wheel.Joints[3].OutPortB.M[1] = 0.0;
  m.wheel.Joints[3].OutPortA.M[2] + m.wheel.Joints[3].OutPortB.M[2] = 0.0;
  m.wheel.Joints[3].OutPortA.M[3] + m.wheel.Joints[3].OutPortB.M[3] = 0.0;
  m.wheel.Joints[4].RA[1] = m.wheel.Joints[4].InPortA.r[1];
  m.wheel.Joints[4].RA[2] = m.wheel.Joints[4].InPortA.r[2];
  m.wheel.Joints[4].RA[3] = m.wheel.Joints[4].InPortA.r[3];
  m.wheel.Joints[4].RB[1] = m.wheel.Joints[4].InPortB.r[1] + m.wheel.Joints[4].InPortB.T[1,1] * -0.02377641290737884 + m.wheel.Joints[4].InPortB.T[1,2] * 0.0327254248593737;
  m.wheel.Joints[4].RB[2] = m.wheel.Joints[4].InPortB.r[2] + m.wheel.Joints[4].InPortB.T[2,1] * -0.02377641290737884 + m.wheel.Joints[4].InPortB.T[2,2] * 0.0327254248593737;
  m.wheel.Joints[4].RB[3] = m.wheel.Joints[4].InPortB.r[3] + m.wheel.Joints[4].InPortB.T[3,1] * -0.02377641290737884 + m.wheel.Joints[4].InPortB.T[3,2] * 0.0327254248593737;
  m.wheel.Joints[4].vA = MbsLite.Util.Euler({m.wheel.Joints[4].InPortA.r[1], m.wheel.Joints[4].InPortA.r[2], m.wheel.Joints[4].InPortA.r[3]}, {m.wheel.Joints[4].RA[1], m.wheel.Joints[4].RA[2], m.wheel.Joints[4].RA[3]}, {m.wheel.Joints[4].InPortA.v[1], m.wheel.Joints[4].InPortA.v[2], m.wheel.Joints[4].InPortA.v[3]}, {m.wheel.Joints[4].InPortA.omega[1], m.wheel.Joints[4].InPortA.omega[2], m.wheel.Joints[4].InPortA.omega[3]});
  m.wheel.Joints[4].vB = MbsLite.Util.Euler({m.wheel.Joints[4].InPortB.r[1], m.wheel.Joints[4].InPortB.r[2], m.wheel.Joints[4].InPortB.r[3]}, {m.wheel.Joints[4].RB[1], m.wheel.Joints[4].RB[2], m.wheel.Joints[4].RB[3]}, {m.wheel.Joints[4].InPortB.v[1], m.wheel.Joints[4].InPortB.v[2], m.wheel.Joints[4].InPortB.v[3]}, {m.wheel.Joints[4].InPortB.omega[1], m.wheel.Joints[4].InPortB.omega[2], m.wheel.Joints[4].InPortB.omega[3]});
  m.wheel.Joints[4].vA[1] = m.wheel.Joints[4].vB[1];
  m.wheel.Joints[4].vA[2] = m.wheel.Joints[4].vB[2];
  m.wheel.Joints[4].vA[3] = m.wheel.Joints[4].vB[3];
  m.wheel.Joints[4].nAi[1] = m.wheel.Joints[4].InPortA.T[1,1];
  m.wheel.Joints[4].nAi[2] = m.wheel.Joints[4].InPortA.T[2,1];
  m.wheel.Joints[4].nAi[3] = m.wheel.Joints[4].InPortA.T[3,1];
  m.wheel.Joints[4].nBi[1] = m.wheel.Joints[4].InPortB.T[1,1] * -0.8090169943749476 + m.wheel.Joints[4].InPortB.T[1,2] * -0.587785252292473;
  m.wheel.Joints[4].nBi[2] = m.wheel.Joints[4].InPortB.T[2,1] * -0.8090169943749476 + m.wheel.Joints[4].InPortB.T[2,2] * -0.587785252292473;
  m.wheel.Joints[4].nBi[3] = m.wheel.Joints[4].InPortB.T[3,1] * -0.8090169943749476 + m.wheel.Joints[4].InPortB.T[3,2] * -0.587785252292473;
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[4].nAi[1], m.wheel.Joints[4].nBi[1], 0.01, 1e-05), \"looks like joint joint4 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nAi[1], m.wheel.Joints[4].nAi[2], m.wheel.Joints[4].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nBi[1], m.wheel.Joints[4].nBi[2], m.wheel.Joints[4].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nBi[1] - m.wheel.Joints[4].nAi[1], m.wheel.Joints[4].nBi[2] - m.wheel.Joints[4].nAi[2], m.wheel.Joints[4].nBi[3] - m.wheel.Joints[4].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[4].nAi[2], m.wheel.Joints[4].nBi[2], 0.01, 1e-05), \"looks like joint joint4 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nAi[1], m.wheel.Joints[4].nAi[2], m.wheel.Joints[4].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nBi[1], m.wheel.Joints[4].nBi[2], m.wheel.Joints[4].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nBi[1] - m.wheel.Joints[4].nAi[1], m.wheel.Joints[4].nBi[2] - m.wheel.Joints[4].nAi[2], m.wheel.Joints[4].nBi[3] - m.wheel.Joints[4].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[4].nAi[3], m.wheel.Joints[4].nBi[3], 0.01, 1e-05), \"looks like joint joint4 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nAi[1], m.wheel.Joints[4].nAi[2], m.wheel.Joints[4].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nBi[1], m.wheel.Joints[4].nBi[2], m.wheel.Joints[4].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[4].nBi[1] - m.wheel.Joints[4].nAi[1], m.wheel.Joints[4].nBi[2] - m.wheel.Joints[4].nAi[2], m.wheel.Joints[4].nBi[3] - m.wheel.Joints[4].nAi[3]}, \", \"));
  m.wheel.Joints[4].epsilonr[1] = m.wheel.Joints[4].InPortB.epsilon[1] - m.wheel.Joints[4].InPortA.epsilon[1] - (m.wheel.Joints[4].InPortA.omega[2] * m.wheel.Joints[4].InPortB.omega[3] - m.wheel.Joints[4].InPortA.omega[3] * m.wheel.Joints[4].InPortB.omega[2]);
  m.wheel.Joints[4].epsilonr[2] = m.wheel.Joints[4].InPortB.epsilon[2] - m.wheel.Joints[4].InPortA.epsilon[2] - (m.wheel.Joints[4].InPortA.omega[3] * m.wheel.Joints[4].InPortB.omega[1] - m.wheel.Joints[4].InPortA.omega[1] * m.wheel.Joints[4].InPortB.omega[3]);
  m.wheel.Joints[4].epsilonr[3] = m.wheel.Joints[4].InPortB.epsilon[3] - m.wheel.Joints[4].InPortA.epsilon[3] - (m.wheel.Joints[4].InPortA.omega[1] * m.wheel.Joints[4].InPortB.omega[2] - m.wheel.Joints[4].InPortA.omega[2] * m.wheel.Joints[4].InPortB.omega[1]);
  m.wheel.Joints[4].epsilonr[1] = m.wheel.Joints[4].nAi[1] * m.wheel.Joints[4].lambda;
  m.wheel.Joints[4].epsilonr[2] = m.wheel.Joints[4].nAi[2] * m.wheel.Joints[4].lambda;
  m.wheel.Joints[4].epsilonr[3] = m.wheel.Joints[4].nAi[3] * m.wheel.Joints[4].lambda;
  m.wheel.Joints[4].M = m.wheel.Joints[4].OutPortA.M[1] * m.wheel.Joints[4].nAi[1] + m.wheel.Joints[4].OutPortA.M[2] * m.wheel.Joints[4].nAi[2] + m.wheel.Joints[4].OutPortA.M[3] * m.wheel.Joints[4].nAi[3];
  m.wheel.Joints[4].M = 0.0;
  m.wheel.Joints[4].OutPortA.P[1] = m.wheel.Joints[4].RA[1];
  m.wheel.Joints[4].OutPortA.P[2] = m.wheel.Joints[4].RA[2];
  m.wheel.Joints[4].OutPortA.P[3] = m.wheel.Joints[4].RA[3];
  m.wheel.Joints[4].OutPortB.P[1] = m.wheel.Joints[4].RB[1];
  m.wheel.Joints[4].OutPortB.P[2] = m.wheel.Joints[4].RB[2];
  m.wheel.Joints[4].OutPortB.P[3] = m.wheel.Joints[4].RB[3];
  der(m.wheel.Joints[4].mu) = m.wheel.Joints[4].lambda;
  der(m.wheel.Joints[4].angle) = m.wheel.Joints[4].mu;
  m.wheel.Joints[4].OutPortA.F[1] + m.wheel.Joints[4].OutPortB.F[1] = 0.0;
  m.wheel.Joints[4].OutPortA.F[2] + m.wheel.Joints[4].OutPortB.F[2] = 0.0;
  m.wheel.Joints[4].OutPortA.F[3] + m.wheel.Joints[4].OutPortB.F[3] = 0.0;
  m.wheel.Joints[4].OutPortA.M[1] + m.wheel.Joints[4].OutPortB.M[1] = 0.0;
  m.wheel.Joints[4].OutPortA.M[2] + m.wheel.Joints[4].OutPortB.M[2] = 0.0;
  m.wheel.Joints[4].OutPortA.M[3] + m.wheel.Joints[4].OutPortB.M[3] = 0.0;
  m.wheel.Joints[5].RA[1] = m.wheel.Joints[5].InPortA.r[1];
  m.wheel.Joints[5].RA[2] = m.wheel.Joints[5].InPortA.r[2];
  m.wheel.Joints[5].RA[3] = m.wheel.Joints[5].InPortA.r[3];
  m.wheel.Joints[5].RB[1] = m.wheel.Joints[5].InPortB.r[1] + m.wheel.Joints[5].InPortB.T[1,1] * -0.03847104421469068 + m.wheel.Joints[5].InPortB.T[1,2] * -0.01249999999999999;
  m.wheel.Joints[5].RB[2] = m.wheel.Joints[5].InPortB.r[2] + m.wheel.Joints[5].InPortB.T[2,1] * -0.03847104421469068 + m.wheel.Joints[5].InPortB.T[2,2] * -0.01249999999999999;
  m.wheel.Joints[5].RB[3] = m.wheel.Joints[5].InPortB.r[3] + m.wheel.Joints[5].InPortB.T[3,1] * -0.03847104421469068 + m.wheel.Joints[5].InPortB.T[3,2] * -0.01249999999999999;
  m.wheel.Joints[5].vA = MbsLite.Util.Euler({m.wheel.Joints[5].InPortA.r[1], m.wheel.Joints[5].InPortA.r[2], m.wheel.Joints[5].InPortA.r[3]}, {m.wheel.Joints[5].RA[1], m.wheel.Joints[5].RA[2], m.wheel.Joints[5].RA[3]}, {m.wheel.Joints[5].InPortA.v[1], m.wheel.Joints[5].InPortA.v[2], m.wheel.Joints[5].InPortA.v[3]}, {m.wheel.Joints[5].InPortA.omega[1], m.wheel.Joints[5].InPortA.omega[2], m.wheel.Joints[5].InPortA.omega[3]});
  m.wheel.Joints[5].vB = MbsLite.Util.Euler({m.wheel.Joints[5].InPortB.r[1], m.wheel.Joints[5].InPortB.r[2], m.wheel.Joints[5].InPortB.r[3]}, {m.wheel.Joints[5].RB[1], m.wheel.Joints[5].RB[2], m.wheel.Joints[5].RB[3]}, {m.wheel.Joints[5].InPortB.v[1], m.wheel.Joints[5].InPortB.v[2], m.wheel.Joints[5].InPortB.v[3]}, {m.wheel.Joints[5].InPortB.omega[1], m.wheel.Joints[5].InPortB.omega[2], m.wheel.Joints[5].InPortB.omega[3]});
  m.wheel.Joints[5].vA[1] = m.wheel.Joints[5].vB[1];
  m.wheel.Joints[5].vA[2] = m.wheel.Joints[5].vB[2];
  m.wheel.Joints[5].vA[3] = m.wheel.Joints[5].vB[3];
  m.wheel.Joints[5].nAi[1] = m.wheel.Joints[5].InPortA.T[1,1];
  m.wheel.Joints[5].nAi[2] = m.wheel.Joints[5].InPortA.T[2,1];
  m.wheel.Joints[5].nAi[3] = m.wheel.Joints[5].InPortA.T[3,1];
  m.wheel.Joints[5].nBi[1] = m.wheel.Joints[5].InPortB.T[1,1] * 0.3090169943749472 + m.wheel.Joints[5].InPortB.T[1,2] * -0.9510565162951536;
  m.wheel.Joints[5].nBi[2] = m.wheel.Joints[5].InPortB.T[2,1] * 0.3090169943749472 + m.wheel.Joints[5].InPortB.T[2,2] * -0.9510565162951536;
  m.wheel.Joints[5].nBi[3] = m.wheel.Joints[5].InPortB.T[3,1] * 0.3090169943749472 + m.wheel.Joints[5].InPortB.T[3,2] * -0.9510565162951536;
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[5].nAi[1], m.wheel.Joints[5].nBi[1], 0.01, 1e-05), \"looks like joint joint5 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nAi[1], m.wheel.Joints[5].nAi[2], m.wheel.Joints[5].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nBi[1], m.wheel.Joints[5].nBi[2], m.wheel.Joints[5].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nBi[1] - m.wheel.Joints[5].nAi[1], m.wheel.Joints[5].nBi[2] - m.wheel.Joints[5].nAi[2], m.wheel.Joints[5].nBi[3] - m.wheel.Joints[5].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[5].nAi[2], m.wheel.Joints[5].nBi[2], 0.01, 1e-05), \"looks like joint joint5 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nAi[1], m.wheel.Joints[5].nAi[2], m.wheel.Joints[5].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nBi[1], m.wheel.Joints[5].nBi[2], m.wheel.Joints[5].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nBi[1] - m.wheel.Joints[5].nAi[1], m.wheel.Joints[5].nBi[2] - m.wheel.Joints[5].nAi[2], m.wheel.Joints[5].nBi[3] - m.wheel.Joints[5].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[5].nAi[3], m.wheel.Joints[5].nBi[3], 0.01, 1e-05), \"looks like joint joint5 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nAi[1], m.wheel.Joints[5].nAi[2], m.wheel.Joints[5].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nBi[1], m.wheel.Joints[5].nBi[2], m.wheel.Joints[5].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[5].nBi[1] - m.wheel.Joints[5].nAi[1], m.wheel.Joints[5].nBi[2] - m.wheel.Joints[5].nAi[2], m.wheel.Joints[5].nBi[3] - m.wheel.Joints[5].nAi[3]}, \", \"));
  m.wheel.Joints[5].epsilonr[1] = m.wheel.Joints[5].InPortB.epsilon[1] - m.wheel.Joints[5].InPortA.epsilon[1] - (m.wheel.Joints[5].InPortA.omega[2] * m.wheel.Joints[5].InPortB.omega[3] - m.wheel.Joints[5].InPortA.omega[3] * m.wheel.Joints[5].InPortB.omega[2]);
  m.wheel.Joints[5].epsilonr[2] = m.wheel.Joints[5].InPortB.epsilon[2] - m.wheel.Joints[5].InPortA.epsilon[2] - (m.wheel.Joints[5].InPortA.omega[3] * m.wheel.Joints[5].InPortB.omega[1] - m.wheel.Joints[5].InPortA.omega[1] * m.wheel.Joints[5].InPortB.omega[3]);
  m.wheel.Joints[5].epsilonr[3] = m.wheel.Joints[5].InPortB.epsilon[3] - m.wheel.Joints[5].InPortA.epsilon[3] - (m.wheel.Joints[5].InPortA.omega[1] * m.wheel.Joints[5].InPortB.omega[2] - m.wheel.Joints[5].InPortA.omega[2] * m.wheel.Joints[5].InPortB.omega[1]);
  m.wheel.Joints[5].epsilonr[1] = m.wheel.Joints[5].nAi[1] * m.wheel.Joints[5].lambda;
  m.wheel.Joints[5].epsilonr[2] = m.wheel.Joints[5].nAi[2] * m.wheel.Joints[5].lambda;
  m.wheel.Joints[5].epsilonr[3] = m.wheel.Joints[5].nAi[3] * m.wheel.Joints[5].lambda;
  m.wheel.Joints[5].M = m.wheel.Joints[5].OutPortA.M[1] * m.wheel.Joints[5].nAi[1] + m.wheel.Joints[5].OutPortA.M[2] * m.wheel.Joints[5].nAi[2] + m.wheel.Joints[5].OutPortA.M[3] * m.wheel.Joints[5].nAi[3];
  m.wheel.Joints[5].M = 0.0;
  m.wheel.Joints[5].OutPortA.P[1] = m.wheel.Joints[5].RA[1];
  m.wheel.Joints[5].OutPortA.P[2] = m.wheel.Joints[5].RA[2];
  m.wheel.Joints[5].OutPortA.P[3] = m.wheel.Joints[5].RA[3];
  m.wheel.Joints[5].OutPortB.P[1] = m.wheel.Joints[5].RB[1];
  m.wheel.Joints[5].OutPortB.P[2] = m.wheel.Joints[5].RB[2];
  m.wheel.Joints[5].OutPortB.P[3] = m.wheel.Joints[5].RB[3];
  der(m.wheel.Joints[5].mu) = m.wheel.Joints[5].lambda;
  der(m.wheel.Joints[5].angle) = m.wheel.Joints[5].mu;
  m.wheel.Joints[5].OutPortA.F[1] + m.wheel.Joints[5].OutPortB.F[1] = 0.0;
  m.wheel.Joints[5].OutPortA.F[2] + m.wheel.Joints[5].OutPortB.F[2] = 0.0;
  m.wheel.Joints[5].OutPortA.F[3] + m.wheel.Joints[5].OutPortB.F[3] = 0.0;
  m.wheel.Joints[5].OutPortA.M[1] + m.wheel.Joints[5].OutPortB.M[1] = 0.0;
  m.wheel.Joints[5].OutPortA.M[2] + m.wheel.Joints[5].OutPortB.M[2] = 0.0;
  m.wheel.Joints[5].OutPortA.M[3] + m.wheel.Joints[5].OutPortB.M[3] = 0.0;
  m.wheel.Wheel.crosses[1,1] = (m.wheel.Wheel.InPorts[1].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[1].F[3] - (m.wheel.Wheel.InPorts[1].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[1].F[2];
  m.wheel.Wheel.crosses[1,2] = (m.wheel.Wheel.InPorts[1].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[1].F[1] - (m.wheel.Wheel.InPorts[1].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[1].F[3];
  m.wheel.Wheel.crosses[1,3] = (m.wheel.Wheel.InPorts[1].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[1].F[2] - (m.wheel.Wheel.InPorts[1].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[1].F[1];
  m.wheel.Wheel.crosses[2,1] = (m.wheel.Wheel.InPorts[2].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[2].F[3] - (m.wheel.Wheel.InPorts[2].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[2].F[2];
  m.wheel.Wheel.crosses[2,2] = (m.wheel.Wheel.InPorts[2].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[2].F[1] - (m.wheel.Wheel.InPorts[2].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[2].F[3];
  m.wheel.Wheel.crosses[2,3] = (m.wheel.Wheel.InPorts[2].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[2].F[2] - (m.wheel.Wheel.InPorts[2].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[2].F[1];
  m.wheel.Wheel.crosses[3,1] = (m.wheel.Wheel.InPorts[3].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[3].F[3] - (m.wheel.Wheel.InPorts[3].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[3].F[2];
  m.wheel.Wheel.crosses[3,2] = (m.wheel.Wheel.InPorts[3].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[3].F[1] - (m.wheel.Wheel.InPorts[3].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[3].F[3];
  m.wheel.Wheel.crosses[3,3] = (m.wheel.Wheel.InPorts[3].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[3].F[2] - (m.wheel.Wheel.InPorts[3].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[3].F[1];
  m.wheel.Wheel.crosses[4,1] = (m.wheel.Wheel.InPorts[4].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[4].F[3] - (m.wheel.Wheel.InPorts[4].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[4].F[2];
  m.wheel.Wheel.crosses[4,2] = (m.wheel.Wheel.InPorts[4].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[4].F[1] - (m.wheel.Wheel.InPorts[4].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[4].F[3];
  m.wheel.Wheel.crosses[4,3] = (m.wheel.Wheel.InPorts[4].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[4].F[2] - (m.wheel.Wheel.InPorts[4].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[4].F[1];
  m.wheel.Wheel.crosses[5,1] = (m.wheel.Wheel.InPorts[5].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[5].F[3] - (m.wheel.Wheel.InPorts[5].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[5].F[2];
  m.wheel.Wheel.crosses[5,2] = (m.wheel.Wheel.InPorts[5].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[5].F[1] - (m.wheel.Wheel.InPorts[5].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[5].F[3];
  m.wheel.Wheel.crosses[5,3] = (m.wheel.Wheel.InPorts[5].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[5].F[2] - (m.wheel.Wheel.InPorts[5].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[5].F[1];
  m.wheel.Wheel.crosses[6,1] = (m.wheel.Wheel.InPorts[6].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[6].F[3] - (m.wheel.Wheel.InPorts[6].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[6].F[2];
  m.wheel.Wheel.crosses[6,2] = (m.wheel.Wheel.InPorts[6].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[6].F[1] - (m.wheel.Wheel.InPorts[6].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[6].F[3];
  m.wheel.Wheel.crosses[6,3] = (m.wheel.Wheel.InPorts[6].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[6].F[2] - (m.wheel.Wheel.InPorts[6].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[6].F[1];
  m.wheel.Wheel.F[1] = m.wheel.Wheel.InPorts[1].F[1] + m.wheel.Wheel.InPorts[2].F[1] + m.wheel.Wheel.InPorts[3].F[1] + m.wheel.Wheel.InPorts[4].F[1] + m.wheel.Wheel.InPorts[5].F[1] + m.wheel.Wheel.InPorts[6].F[1];
  m.wheel.Wheel.F[2] = -0.15 + m.wheel.Wheel.InPorts[1].F[2] + m.wheel.Wheel.InPorts[2].F[2] + m.wheel.Wheel.InPorts[3].F[2] + m.wheel.Wheel.InPorts[4].F[2] + m.wheel.Wheel.InPorts[5].F[2] + m.wheel.Wheel.InPorts[6].F[2];
  m.wheel.Wheel.F[3] = m.wheel.Wheel.InPorts[1].F[3] + m.wheel.Wheel.InPorts[2].F[3] + m.wheel.Wheel.InPorts[3].F[3] + m.wheel.Wheel.InPorts[4].F[3] + m.wheel.Wheel.InPorts[5].F[3] + m.wheel.Wheel.InPorts[6].F[3];
  m.wheel.Wheel.M[1] = m.wheel.Wheel.InPorts[1].M[1] + m.wheel.Wheel.crosses[1,1] + m.wheel.Wheel.InPorts[2].M[1] + m.wheel.Wheel.crosses[2,1] + m.wheel.Wheel.InPorts[3].M[1] + m.wheel.Wheel.crosses[3,1] + m.wheel.Wheel.InPorts[4].M[1] + m.wheel.Wheel.crosses[4,1] + m.wheel.Wheel.InPorts[5].M[1] + m.wheel.Wheel.crosses[5,1] + m.wheel.Wheel.InPorts[6].M[1] + m.wheel.Wheel.crosses[6,1];
  m.wheel.Wheel.M[2] = m.wheel.Wheel.InPorts[1].M[2] + m.wheel.Wheel.crosses[1,2] + m.wheel.Wheel.InPorts[2].M[2] + m.wheel.Wheel.crosses[2,2] + m.wheel.Wheel.InPorts[3].M[2] + m.wheel.Wheel.crosses[3,2] + m.wheel.Wheel.InPorts[4].M[2] + m.wheel.Wheel.crosses[4,2] + m.wheel.Wheel.InPorts[5].M[2] + m.wheel.Wheel.crosses[5,2] + m.wheel.Wheel.InPorts[6].M[2] + m.wheel.Wheel.crosses[6,2];
  m.wheel.Wheel.M[3] = m.wheel.Wheel.InPorts[1].M[3] + m.wheel.Wheel.crosses[1,3] + m.wheel.Wheel.InPorts[2].M[3] + m.wheel.Wheel.crosses[2,3] + m.wheel.Wheel.InPorts[3].M[3] + m.wheel.Wheel.crosses[3,3] + m.wheel.Wheel.InPorts[4].M[3] + m.wheel.Wheel.crosses[4,3] + m.wheel.Wheel.InPorts[5].M[3] + m.wheel.Wheel.crosses[5,3] + m.wheel.Wheel.InPorts[6].M[3] + m.wheel.Wheel.crosses[6,3];
  der(m.wheel.Wheel.Active) = 0.0;
  der(m.wheel.Wheel.r[1]) = m.wheel.Wheel.v[1] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.r[2]) = m.wheel.Wheel.v[2] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.r[3]) = m.wheel.Wheel.v[3] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.v[1]) = m.wheel.Wheel.a[1] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.v[2]) = m.wheel.Wheel.a[2] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.v[3]) = m.wheel.Wheel.a[3] * m.wheel.Wheel.Active;
  m.wheel.Wheel.a[1] * 0.15 = m.wheel.Wheel.F[1];
  m.wheel.Wheel.a[2] * 0.15 = m.wheel.Wheel.F[2];
  m.wheel.Wheel.a[3] * 0.15 = m.wheel.Wheel.F[3];
  {der(m.wheel.Wheel.q[1]), der(m.wheel.Wheel.q[2]), der(m.wheel.Wheel.q[3]), der(m.wheel.Wheel.q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Wheel.q[1], m.wheel.Wheel.q[2], m.wheel.Wheel.q[3], m.wheel.Wheel.q[4]}, {0.0, m.wheel.Wheel.omega[1], m.wheel.Wheel.omega[2], m.wheel.Wheel.omega[3]}) * 0.5 * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.omega[1]) = m.wheel.Wheel.epsilon[1] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.omega[2]) = m.wheel.Wheel.epsilon[2] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.omega[3]) = m.wheel.Wheel.epsilon[3] * m.wheel.Wheel.Active;
  m.wheel.Wheel.T = MbsLite.Util.Quaternions.QToT({m.wheel.Wheel.q[1], m.wheel.Wheel.q[2], m.wheel.Wheel.q[3], m.wheel.Wheel.q[4]});
  6.261017161132568e-05 * m.wheel.Wheel.epsilon[1] + m.wheel.Wheel.omega[2] * 0.0001227203432226514 * m.wheel.Wheel.omega[3] - m.wheel.Wheel.omega[3] * 6.261017161132568e-05 * m.wheel.Wheel.omega[2] = m.wheel.Wheel.T[1,1] * m.wheel.Wheel.M[1] + m.wheel.Wheel.T[2,1] * m.wheel.Wheel.M[2] + m.wheel.Wheel.T[3,1] * m.wheel.Wheel.M[3];
  6.261017161132568e-05 * m.wheel.Wheel.epsilon[2] + m.wheel.Wheel.omega[3] * 6.261017161132568e-05 * m.wheel.Wheel.omega[1] - m.wheel.Wheel.omega[1] * 0.0001227203432226514 * m.wheel.Wheel.omega[3] = m.wheel.Wheel.T[1,2] * m.wheel.Wheel.M[1] + m.wheel.Wheel.T[2,2] * m.wheel.Wheel.M[2] + m.wheel.Wheel.T[3,2] * m.wheel.Wheel.M[3];
  0.0001227203432226514 * m.wheel.Wheel.epsilon[3] = m.wheel.Wheel.T[1,3] * m.wheel.Wheel.M[1] + m.wheel.Wheel.T[2,3] * m.wheel.Wheel.M[2] + m.wheel.Wheel.T[3,3] * m.wheel.Wheel.M[3];
  m.wheel.Wheel.OutPort.r[1] = m.wheel.Wheel.r[1];
  m.wheel.Wheel.OutPort.r[2] = m.wheel.Wheel.r[2];
  m.wheel.Wheel.OutPort.r[3] = m.wheel.Wheel.r[3];
  m.wheel.Wheel.OutPort.v[1] = m.wheel.Wheel.v[1];
  m.wheel.Wheel.OutPort.v[2] = m.wheel.Wheel.v[2];
  m.wheel.Wheel.OutPort.v[3] = m.wheel.Wheel.v[3];
  m.wheel.Wheel.OutPort.a[1] = m.wheel.Wheel.a[1];
  m.wheel.Wheel.OutPort.a[2] = m.wheel.Wheel.a[2];
  m.wheel.Wheel.OutPort.a[3] = m.wheel.Wheel.a[3];
  m.wheel.Wheel.OutPort.T[1,1] = m.wheel.Wheel.T[1,1];
  m.wheel.Wheel.OutPort.T[1,2] = m.wheel.Wheel.T[1,2];
  m.wheel.Wheel.OutPort.T[1,3] = m.wheel.Wheel.T[1,3];
  m.wheel.Wheel.OutPort.T[2,1] = m.wheel.Wheel.T[2,1];
  m.wheel.Wheel.OutPort.T[2,2] = m.wheel.Wheel.T[2,2];
  m.wheel.Wheel.OutPort.T[2,3] = m.wheel.Wheel.T[2,3];
  m.wheel.Wheel.OutPort.T[3,1] = m.wheel.Wheel.T[3,1];
  m.wheel.Wheel.OutPort.T[3,2] = m.wheel.Wheel.T[3,2];
  m.wheel.Wheel.OutPort.T[3,3] = m.wheel.Wheel.T[3,3];
  m.wheel.Wheel.OutPort.omega[1] = m.wheel.Wheel.T[1,1] * m.wheel.Wheel.omega[1] + m.wheel.Wheel.T[1,2] * m.wheel.Wheel.omega[2] + m.wheel.Wheel.T[1,3] * m.wheel.Wheel.omega[3];
  m.wheel.Wheel.OutPort.omega[2] = m.wheel.Wheel.T[2,1] * m.wheel.Wheel.omega[1] + m.wheel.Wheel.T[2,2] * m.wheel.Wheel.omega[2] + m.wheel.Wheel.T[2,3] * m.wheel.Wheel.omega[3];
  m.wheel.Wheel.OutPort.omega[3] = m.wheel.Wheel.T[3,1] * m.wheel.Wheel.omega[1] + m.wheel.Wheel.T[3,2] * m.wheel.Wheel.omega[2] + m.wheel.Wheel.T[3,3] * m.wheel.Wheel.omega[3];
  m.wheel.Wheel.OutPort.epsilon[1] = m.wheel.Wheel.T[1,1] * m.wheel.Wheel.epsilon[1] + m.wheel.Wheel.T[1,2] * m.wheel.Wheel.epsilon[2] + m.wheel.Wheel.T[1,3] * m.wheel.Wheel.epsilon[3];
  m.wheel.Wheel.OutPort.epsilon[2] = m.wheel.Wheel.T[2,1] * m.wheel.Wheel.epsilon[1] + m.wheel.Wheel.T[2,2] * m.wheel.Wheel.epsilon[2] + m.wheel.Wheel.T[2,3] * m.wheel.Wheel.epsilon[3];
  m.wheel.Wheel.OutPort.epsilon[3] = m.wheel.Wheel.T[3,1] * m.wheel.Wheel.epsilon[1] + m.wheel.Wheel.T[3,2] * m.wheel.Wheel.epsilon[2] + m.wheel.Wheel.T[3,3] * m.wheel.Wheel.epsilon[3];
  m.contacts[1].cosBetweenRollerVerticalAndGlobalVertical = m.contacts[1].InPortB.T[2,2];
  m.contacts[1].isInContact = m.contacts[1].cosBetweenRollerVerticalAndGlobalVertical > 0.8090169943749475 and m.contacts[1].InPortB.r[2] < 0.05;
  m.contacts[1].contactPointCoords[1] = if m.contacts[1].isInContact then m.contacts[1].InPortB.r[1] + m.contacts[1].InPortB.T[1,2] * 0.04045084971874738 else 0.0;
  m.contacts[1].contactPointCoords[2] = if m.contacts[1].isInContact then m.contacts[1].InPortB.r[2] + m.contacts[1].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0;
  m.contacts[1].contactPointCoords[3] = if m.contacts[1].isInContact then m.contacts[1].InPortB.r[3] + m.contacts[1].InPortB.T[3,2] * 0.04045084971874738 else 0.0;
  when m.contacts[1].isInContact <> pre(m.contacts[1].isInContact) then
    reinit(m.contacts[1].contactPointCoords[1], if m.contacts[1].isInContact then m.contacts[1].InPortB.r[1] + m.contacts[1].InPortB.T[1,2] * 0.04045084971874738 else 0.0);
    reinit(m.contacts[1].contactPointCoords[2], if m.contacts[1].isInContact then m.contacts[1].InPortB.r[2] + m.contacts[1].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0);
    reinit(m.contacts[1].contactPointCoords[3], if m.contacts[1].isInContact then m.contacts[1].InPortB.r[3] + m.contacts[1].InPortB.T[3,2] * 0.04045084971874738 else 0.0);
  end when;
  m.contacts[1].contactPointVelocity = MbsLite.Util.Euler({m.contacts[1].InPortB.r[1], m.contacts[1].InPortB.r[2], m.contacts[1].InPortB.r[3]}, {m.contacts[1].contactPointCoords[1], m.contacts[1].contactPointCoords[2], m.contacts[1].contactPointCoords[3]}, {m.contacts[1].InPortB.v[1], m.contacts[1].InPortB.v[2], m.contacts[1].InPortB.v[3]}, {m.contacts[1].InPortB.omega[1], m.contacts[1].InPortB.omega[2], m.contacts[1].InPortB.omega[3]});
  m.contacts[1].OutPortA.P[1] = m.contacts[1].contactPointCoords[1];
  m.contacts[1].OutPortA.P[2] = m.contacts[1].contactPointCoords[2];
  m.contacts[1].OutPortA.P[3] = m.contacts[1].contactPointCoords[3];
  m.contacts[1].OutPortB.P[1] = m.contacts[1].contactPointCoords[1];
  m.contacts[1].OutPortB.P[2] = m.contacts[1].contactPointCoords[2];
  m.contacts[1].OutPortB.P[3] = m.contacts[1].contactPointCoords[3];
  m.contacts[1].OutPortB.F[1] = 0.0;
  m.contacts[1].OutPortB.F[2] = 0.0;
  m.contacts[1].OutPortB.F[3] = 0.0;
  m.contacts[1].OutPortB.M[1] = 0.0;
  m.contacts[1].OutPortB.M[2] = 0.0;
  m.contacts[1].OutPortB.M[3] = 0.0;
  m.contacts[1].OutPortA.F[1] + m.contacts[1].OutPortB.F[1] = 0.0;
  m.contacts[1].OutPortA.F[2] + m.contacts[1].OutPortB.F[2] = 0.0;
  m.contacts[1].OutPortA.F[3] + m.contacts[1].OutPortB.F[3] = 0.0;
  m.contacts[1].OutPortA.M[1] + m.contacts[1].OutPortB.M[1] = 0.0;
  m.contacts[1].OutPortA.M[2] + m.contacts[1].OutPortB.M[2] = 0.0;
  m.contacts[1].OutPortA.M[3] + m.contacts[1].OutPortB.M[3] = 0.0;
  m.contacts[2].cosBetweenRollerVerticalAndGlobalVertical = m.contacts[2].InPortB.T[2,2];
  m.contacts[2].isInContact = m.contacts[2].cosBetweenRollerVerticalAndGlobalVertical > 0.8090169943749475 and m.contacts[2].InPortB.r[2] < 0.05;
  m.contacts[2].contactPointCoords[1] = if m.contacts[2].isInContact then m.contacts[2].InPortB.r[1] + m.contacts[2].InPortB.T[1,2] * 0.04045084971874738 else 0.0;
  m.contacts[2].contactPointCoords[2] = if m.contacts[2].isInContact then m.contacts[2].InPortB.r[2] + m.contacts[2].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0;
  m.contacts[2].contactPointCoords[3] = if m.contacts[2].isInContact then m.contacts[2].InPortB.r[3] + m.contacts[2].InPortB.T[3,2] * 0.04045084971874738 else 0.0;
  when m.contacts[2].isInContact <> pre(m.contacts[2].isInContact) then
    reinit(m.contacts[2].contactPointCoords[1], if m.contacts[2].isInContact then m.contacts[2].InPortB.r[1] + m.contacts[2].InPortB.T[1,2] * 0.04045084971874738 else 0.0);
    reinit(m.contacts[2].contactPointCoords[2], if m.contacts[2].isInContact then m.contacts[2].InPortB.r[2] + m.contacts[2].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0);
    reinit(m.contacts[2].contactPointCoords[3], if m.contacts[2].isInContact then m.contacts[2].InPortB.r[3] + m.contacts[2].InPortB.T[3,2] * 0.04045084971874738 else 0.0);
  end when;
  m.contacts[2].contactPointVelocity = MbsLite.Util.Euler({m.contacts[2].InPortB.r[1], m.contacts[2].InPortB.r[2], m.contacts[2].InPortB.r[3]}, {m.contacts[2].contactPointCoords[1], m.contacts[2].contactPointCoords[2], m.contacts[2].contactPointCoords[3]}, {m.contacts[2].InPortB.v[1], m.contacts[2].InPortB.v[2], m.contacts[2].InPortB.v[3]}, {m.contacts[2].InPortB.omega[1], m.contacts[2].InPortB.omega[2], m.contacts[2].InPortB.omega[3]});
  m.contacts[2].OutPortA.P[1] = m.contacts[2].contactPointCoords[1];
  m.contacts[2].OutPortA.P[2] = m.contacts[2].contactPointCoords[2];
  m.contacts[2].OutPortA.P[3] = m.contacts[2].contactPointCoords[3];
  m.contacts[2].OutPortB.P[1] = m.contacts[2].contactPointCoords[1];
  m.contacts[2].OutPortB.P[2] = m.contacts[2].contactPointCoords[2];
  m.contacts[2].OutPortB.P[3] = m.contacts[2].contactPointCoords[3];
  m.contacts[2].OutPortB.F[1] = 0.0;
  m.contacts[2].OutPortB.F[2] = 0.0;
  m.contacts[2].OutPortB.F[3] = 0.0;
  m.contacts[2].OutPortB.M[1] = 0.0;
  m.contacts[2].OutPortB.M[2] = 0.0;
  m.contacts[2].OutPortB.M[3] = 0.0;
  m.contacts[2].OutPortA.F[1] + m.contacts[2].OutPortB.F[1] = 0.0;
  m.contacts[2].OutPortA.F[2] + m.contacts[2].OutPortB.F[2] = 0.0;
  m.contacts[2].OutPortA.F[3] + m.contacts[2].OutPortB.F[3] = 0.0;
  m.contacts[2].OutPortA.M[1] + m.contacts[2].OutPortB.M[1] = 0.0;
  m.contacts[2].OutPortA.M[2] + m.contacts[2].OutPortB.M[2] = 0.0;
  m.contacts[2].OutPortA.M[3] + m.contacts[2].OutPortB.M[3] = 0.0;
  m.contacts[3].cosBetweenRollerVerticalAndGlobalVertical = m.contacts[3].InPortB.T[2,2];
  m.contacts[3].isInContact = m.contacts[3].cosBetweenRollerVerticalAndGlobalVertical > 0.8090169943749475 and m.contacts[3].InPortB.r[2] < 0.05;
  m.contacts[3].contactPointCoords[1] = if m.contacts[3].isInContact then m.contacts[3].InPortB.r[1] + m.contacts[3].InPortB.T[1,2] * 0.04045084971874738 else 0.0;
  m.contacts[3].contactPointCoords[2] = if m.contacts[3].isInContact then m.contacts[3].InPortB.r[2] + m.contacts[3].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0;
  m.contacts[3].contactPointCoords[3] = if m.contacts[3].isInContact then m.contacts[3].InPortB.r[3] + m.contacts[3].InPortB.T[3,2] * 0.04045084971874738 else 0.0;
  when m.contacts[3].isInContact <> pre(m.contacts[3].isInContact) then
    reinit(m.contacts[3].contactPointCoords[1], if m.contacts[3].isInContact then m.contacts[3].InPortB.r[1] + m.contacts[3].InPortB.T[1,2] * 0.04045084971874738 else 0.0);
    reinit(m.contacts[3].contactPointCoords[2], if m.contacts[3].isInContact then m.contacts[3].InPortB.r[2] + m.contacts[3].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0);
    reinit(m.contacts[3].contactPointCoords[3], if m.contacts[3].isInContact then m.contacts[3].InPortB.r[3] + m.contacts[3].InPortB.T[3,2] * 0.04045084971874738 else 0.0);
  end when;
  m.contacts[3].contactPointVelocity = MbsLite.Util.Euler({m.contacts[3].InPortB.r[1], m.contacts[3].InPortB.r[2], m.contacts[3].InPortB.r[3]}, {m.contacts[3].contactPointCoords[1], m.contacts[3].contactPointCoords[2], m.contacts[3].contactPointCoords[3]}, {m.contacts[3].InPortB.v[1], m.contacts[3].InPortB.v[2], m.contacts[3].InPortB.v[3]}, {m.contacts[3].InPortB.omega[1], m.contacts[3].InPortB.omega[2], m.contacts[3].InPortB.omega[3]});
  m.contacts[3].OutPortA.P[1] = m.contacts[3].contactPointCoords[1];
  m.contacts[3].OutPortA.P[2] = m.contacts[3].contactPointCoords[2];
  m.contacts[3].OutPortA.P[3] = m.contacts[3].contactPointCoords[3];
  m.contacts[3].OutPortB.P[1] = m.contacts[3].contactPointCoords[1];
  m.contacts[3].OutPortB.P[2] = m.contacts[3].contactPointCoords[2];
  m.contacts[3].OutPortB.P[3] = m.contacts[3].contactPointCoords[3];
  m.contacts[3].OutPortB.F[1] = 0.0;
  m.contacts[3].OutPortB.F[2] = 0.0;
  m.contacts[3].OutPortB.F[3] = 0.0;
  m.contacts[3].OutPortB.M[1] = 0.0;
  m.contacts[3].OutPortB.M[2] = 0.0;
  m.contacts[3].OutPortB.M[3] = 0.0;
  m.contacts[3].OutPortA.F[1] + m.contacts[3].OutPortB.F[1] = 0.0;
  m.contacts[3].OutPortA.F[2] + m.contacts[3].OutPortB.F[2] = 0.0;
  m.contacts[3].OutPortA.F[3] + m.contacts[3].OutPortB.F[3] = 0.0;
  m.contacts[3].OutPortA.M[1] + m.contacts[3].OutPortB.M[1] = 0.0;
  m.contacts[3].OutPortA.M[2] + m.contacts[3].OutPortB.M[2] = 0.0;
  m.contacts[3].OutPortA.M[3] + m.contacts[3].OutPortB.M[3] = 0.0;
  m.contacts[4].cosBetweenRollerVerticalAndGlobalVertical = m.contacts[4].InPortB.T[2,2];
  m.contacts[4].isInContact = m.contacts[4].cosBetweenRollerVerticalAndGlobalVertical > 0.8090169943749475 and m.contacts[4].InPortB.r[2] < 0.05;
  m.contacts[4].contactPointCoords[1] = if m.contacts[4].isInContact then m.contacts[4].InPortB.r[1] + m.contacts[4].InPortB.T[1,2] * 0.04045084971874738 else 0.0;
  m.contacts[4].contactPointCoords[2] = if m.contacts[4].isInContact then m.contacts[4].InPortB.r[2] + m.contacts[4].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0;
  m.contacts[4].contactPointCoords[3] = if m.contacts[4].isInContact then m.contacts[4].InPortB.r[3] + m.contacts[4].InPortB.T[3,2] * 0.04045084971874738 else 0.0;
  when m.contacts[4].isInContact <> pre(m.contacts[4].isInContact) then
    reinit(m.contacts[4].contactPointCoords[1], if m.contacts[4].isInContact then m.contacts[4].InPortB.r[1] + m.contacts[4].InPortB.T[1,2] * 0.04045084971874738 else 0.0);
    reinit(m.contacts[4].contactPointCoords[2], if m.contacts[4].isInContact then m.contacts[4].InPortB.r[2] + m.contacts[4].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0);
    reinit(m.contacts[4].contactPointCoords[3], if m.contacts[4].isInContact then m.contacts[4].InPortB.r[3] + m.contacts[4].InPortB.T[3,2] * 0.04045084971874738 else 0.0);
  end when;
  m.contacts[4].contactPointVelocity = MbsLite.Util.Euler({m.contacts[4].InPortB.r[1], m.contacts[4].InPortB.r[2], m.contacts[4].InPortB.r[3]}, {m.contacts[4].contactPointCoords[1], m.contacts[4].contactPointCoords[2], m.contacts[4].contactPointCoords[3]}, {m.contacts[4].InPortB.v[1], m.contacts[4].InPortB.v[2], m.contacts[4].InPortB.v[3]}, {m.contacts[4].InPortB.omega[1], m.contacts[4].InPortB.omega[2], m.contacts[4].InPortB.omega[3]});
  m.contacts[4].OutPortA.P[1] = m.contacts[4].contactPointCoords[1];
  m.contacts[4].OutPortA.P[2] = m.contacts[4].contactPointCoords[2];
  m.contacts[4].OutPortA.P[3] = m.contacts[4].contactPointCoords[3];
  m.contacts[4].OutPortB.P[1] = m.contacts[4].contactPointCoords[1];
  m.contacts[4].OutPortB.P[2] = m.contacts[4].contactPointCoords[2];
  m.contacts[4].OutPortB.P[3] = m.contacts[4].contactPointCoords[3];
  m.contacts[4].OutPortB.F[1] = 0.0;
  m.contacts[4].OutPortB.F[2] = 0.0;
  m.contacts[4].OutPortB.F[3] = 0.0;
  m.contacts[4].OutPortB.M[1] = 0.0;
  m.contacts[4].OutPortB.M[2] = 0.0;
  m.contacts[4].OutPortB.M[3] = 0.0;
  m.contacts[4].OutPortA.F[1] + m.contacts[4].OutPortB.F[1] = 0.0;
  m.contacts[4].OutPortA.F[2] + m.contacts[4].OutPortB.F[2] = 0.0;
  m.contacts[4].OutPortA.F[3] + m.contacts[4].OutPortB.F[3] = 0.0;
  m.contacts[4].OutPortA.M[1] + m.contacts[4].OutPortB.M[1] = 0.0;
  m.contacts[4].OutPortA.M[2] + m.contacts[4].OutPortB.M[2] = 0.0;
  m.contacts[4].OutPortA.M[3] + m.contacts[4].OutPortB.M[3] = 0.0;
  m.contacts[5].cosBetweenRollerVerticalAndGlobalVertical = m.contacts[5].InPortB.T[2,2];
  m.contacts[5].isInContact = m.contacts[5].cosBetweenRollerVerticalAndGlobalVertical > 0.8090169943749475 and m.contacts[5].InPortB.r[2] < 0.05;
  m.contacts[5].contactPointCoords[1] = if m.contacts[5].isInContact then m.contacts[5].InPortB.r[1] + m.contacts[5].InPortB.T[1,2] * 0.04045084971874738 else 0.0;
  m.contacts[5].contactPointCoords[2] = if m.contacts[5].isInContact then m.contacts[5].InPortB.r[2] + m.contacts[5].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0;
  m.contacts[5].contactPointCoords[3] = if m.contacts[5].isInContact then m.contacts[5].InPortB.r[3] + m.contacts[5].InPortB.T[3,2] * 0.04045084971874738 else 0.0;
  when m.contacts[5].isInContact <> pre(m.contacts[5].isInContact) then
    reinit(m.contacts[5].contactPointCoords[1], if m.contacts[5].isInContact then m.contacts[5].InPortB.r[1] + m.contacts[5].InPortB.T[1,2] * 0.04045084971874738 else 0.0);
    reinit(m.contacts[5].contactPointCoords[2], if m.contacts[5].isInContact then m.contacts[5].InPortB.r[2] + m.contacts[5].InPortB.T[2,2] * 0.04045084971874738 - 0.05 else 0.0);
    reinit(m.contacts[5].contactPointCoords[3], if m.contacts[5].isInContact then m.contacts[5].InPortB.r[3] + m.contacts[5].InPortB.T[3,2] * 0.04045084971874738 else 0.0);
  end when;
  m.contacts[5].contactPointVelocity = MbsLite.Util.Euler({m.contacts[5].InPortB.r[1], m.contacts[5].InPortB.r[2], m.contacts[5].InPortB.r[3]}, {m.contacts[5].contactPointCoords[1], m.contacts[5].contactPointCoords[2], m.contacts[5].contactPointCoords[3]}, {m.contacts[5].InPortB.v[1], m.contacts[5].InPortB.v[2], m.contacts[5].InPortB.v[3]}, {m.contacts[5].InPortB.omega[1], m.contacts[5].InPortB.omega[2], m.contacts[5].InPortB.omega[3]});
  m.contacts[5].OutPortA.P[1] = m.contacts[5].contactPointCoords[1];
  m.contacts[5].OutPortA.P[2] = m.contacts[5].contactPointCoords[2];
  m.contacts[5].OutPortA.P[3] = m.contacts[5].contactPointCoords[3];
  m.contacts[5].OutPortB.P[1] = m.contacts[5].contactPointCoords[1];
  m.contacts[5].OutPortB.P[2] = m.contacts[5].contactPointCoords[2];
  m.contacts[5].OutPortB.P[3] = m.contacts[5].contactPointCoords[3];
  m.contacts[5].OutPortB.F[1] = 0.0;
  m.contacts[5].OutPortB.F[2] = 0.0;
  m.contacts[5].OutPortB.F[3] = 0.0;
  m.contacts[5].OutPortB.M[1] = 0.0;
  m.contacts[5].OutPortB.M[2] = 0.0;
  m.contacts[5].OutPortB.M[3] = 0.0;
  m.contacts[5].OutPortA.F[1] + m.contacts[5].OutPortB.F[1] = 0.0;
  m.contacts[5].OutPortA.F[2] + m.contacts[5].OutPortB.F[2] = 0.0;
  m.contacts[5].OutPortA.F[3] + m.contacts[5].OutPortB.F[3] = 0.0;
  m.contacts[5].OutPortA.M[1] + m.contacts[5].OutPortB.M[1] = 0.0;
  m.contacts[5].OutPortA.M[2] + m.contacts[5].OutPortB.M[2] = 0.0;
  m.contacts[5].OutPortA.M[3] + m.contacts[5].OutPortB.M[3] = 0.0;
  m.wheel.InPortF.P[1] = m.wheel.OutPortK.r[1];
  m.wheel.InPortF.P[2] = m.wheel.OutPortK.r[2];
  m.wheel.InPortF.P[3] = m.wheel.OutPortK.r[3];
  m.wheel.InPortF.F[1] = 0.0;
  m.wheel.InPortF.F[2] = 0.0;
  m.wheel.InPortF.F[3] = 0.0;
  m.wheel.InPortF.M[1] = 0.0;
  m.wheel.InPortF.M[2] = 0.0;
  m.wheel.InPortF.M[3] = 0.0;
  when time == 1.0 then
    assert(true, \"zero should be zero, was: 0\");
  end when;
  m.wheel.Joints[1].OutPortA.F[1] = m.wheel.Rollers[1].InPorts[2].F[1];
  m.wheel.Joints[1].OutPortA.F[2] = m.wheel.Rollers[1].InPorts[2].F[2];
  m.wheel.Joints[1].OutPortA.F[3] = m.wheel.Rollers[1].InPorts[2].F[3];
  m.wheel.Joints[1].OutPortA.M[1] = m.wheel.Rollers[1].InPorts[2].M[1];
  m.wheel.Joints[1].OutPortA.M[2] = m.wheel.Rollers[1].InPorts[2].M[2];
  m.wheel.Joints[1].OutPortA.M[3] = m.wheel.Rollers[1].InPorts[2].M[3];
  m.wheel.Joints[1].OutPortA.P[1] = m.wheel.Rollers[1].InPorts[2].P[1];
  m.wheel.Joints[1].OutPortA.P[2] = m.wheel.Rollers[1].InPorts[2].P[2];
  m.wheel.Joints[1].OutPortA.P[3] = m.wheel.Rollers[1].InPorts[2].P[3];
  m.contacts[1].InPortB.T[1,1] = m.wheel.Joints[1].InPortA.T[1,1];
  m.contacts[1].InPortB.T[1,1] = m.wheel.Rollers[1].OutPort.T[1,1];
  m.contacts[1].InPortB.T[1,2] = m.wheel.Joints[1].InPortA.T[1,2];
  m.contacts[1].InPortB.T[1,2] = m.wheel.Rollers[1].OutPort.T[1,2];
  m.contacts[1].InPortB.T[1,3] = m.wheel.Joints[1].InPortA.T[1,3];
  m.contacts[1].InPortB.T[1,3] = m.wheel.Rollers[1].OutPort.T[1,3];
  m.contacts[1].InPortB.T[2,1] = m.wheel.Joints[1].InPortA.T[2,1];
  m.contacts[1].InPortB.T[2,1] = m.wheel.Rollers[1].OutPort.T[2,1];
  m.contacts[1].InPortB.T[2,2] = m.wheel.Joints[1].InPortA.T[2,2];
  m.contacts[1].InPortB.T[2,2] = m.wheel.Rollers[1].OutPort.T[2,2];
  m.contacts[1].InPortB.T[2,3] = m.wheel.Joints[1].InPortA.T[2,3];
  m.contacts[1].InPortB.T[2,3] = m.wheel.Rollers[1].OutPort.T[2,3];
  m.contacts[1].InPortB.T[3,1] = m.wheel.Joints[1].InPortA.T[3,1];
  m.contacts[1].InPortB.T[3,1] = m.wheel.Rollers[1].OutPort.T[3,1];
  m.contacts[1].InPortB.T[3,2] = m.wheel.Joints[1].InPortA.T[3,2];
  m.contacts[1].InPortB.T[3,2] = m.wheel.Rollers[1].OutPort.T[3,2];
  m.contacts[1].InPortB.T[3,3] = m.wheel.Joints[1].InPortA.T[3,3];
  m.contacts[1].InPortB.T[3,3] = m.wheel.Rollers[1].OutPort.T[3,3];
  m.contacts[1].InPortB.a[1] = m.wheel.Joints[1].InPortA.a[1];
  m.contacts[1].InPortB.a[1] = m.wheel.Rollers[1].OutPort.a[1];
  m.contacts[1].InPortB.a[2] = m.wheel.Joints[1].InPortA.a[2];
  m.contacts[1].InPortB.a[2] = m.wheel.Rollers[1].OutPort.a[2];
  m.contacts[1].InPortB.a[3] = m.wheel.Joints[1].InPortA.a[3];
  m.contacts[1].InPortB.a[3] = m.wheel.Rollers[1].OutPort.a[3];
  m.contacts[1].InPortB.epsilon[1] = m.wheel.Joints[1].InPortA.epsilon[1];
  m.contacts[1].InPortB.epsilon[1] = m.wheel.Rollers[1].OutPort.epsilon[1];
  m.contacts[1].InPortB.epsilon[2] = m.wheel.Joints[1].InPortA.epsilon[2];
  m.contacts[1].InPortB.epsilon[2] = m.wheel.Rollers[1].OutPort.epsilon[2];
  m.contacts[1].InPortB.epsilon[3] = m.wheel.Joints[1].InPortA.epsilon[3];
  m.contacts[1].InPortB.epsilon[3] = m.wheel.Rollers[1].OutPort.epsilon[3];
  m.contacts[1].InPortB.omega[1] = m.wheel.Joints[1].InPortA.omega[1];
  m.contacts[1].InPortB.omega[1] = m.wheel.Rollers[1].OutPort.omega[1];
  m.contacts[1].InPortB.omega[2] = m.wheel.Joints[1].InPortA.omega[2];
  m.contacts[1].InPortB.omega[2] = m.wheel.Rollers[1].OutPort.omega[2];
  m.contacts[1].InPortB.omega[3] = m.wheel.Joints[1].InPortA.omega[3];
  m.contacts[1].InPortB.omega[3] = m.wheel.Rollers[1].OutPort.omega[3];
  m.contacts[1].InPortB.r[1] = m.wheel.Joints[1].InPortA.r[1];
  m.contacts[1].InPortB.r[1] = m.wheel.Rollers[1].OutPort.r[1];
  m.contacts[1].InPortB.r[2] = m.wheel.Joints[1].InPortA.r[2];
  m.contacts[1].InPortB.r[2] = m.wheel.Rollers[1].OutPort.r[2];
  m.contacts[1].InPortB.r[3] = m.wheel.Joints[1].InPortA.r[3];
  m.contacts[1].InPortB.r[3] = m.wheel.Rollers[1].OutPort.r[3];
  m.contacts[1].InPortB.v[1] = m.wheel.Joints[1].InPortA.v[1];
  m.contacts[1].InPortB.v[1] = m.wheel.Rollers[1].OutPort.v[1];
  m.contacts[1].InPortB.v[2] = m.wheel.Joints[1].InPortA.v[2];
  m.contacts[1].InPortB.v[2] = m.wheel.Rollers[1].OutPort.v[2];
  m.contacts[1].InPortB.v[3] = m.wheel.Joints[1].InPortA.v[3];
  m.contacts[1].InPortB.v[3] = m.wheel.Rollers[1].OutPort.v[3];
  m.wheel.Joints[1].OutPortB.F[1] = m.wheel.Wheel.InPorts[2].F[1];
  m.wheel.Joints[1].OutPortB.F[2] = m.wheel.Wheel.InPorts[2].F[2];
  m.wheel.Joints[1].OutPortB.F[3] = m.wheel.Wheel.InPorts[2].F[3];
  m.wheel.Joints[1].OutPortB.M[1] = m.wheel.Wheel.InPorts[2].M[1];
  m.wheel.Joints[1].OutPortB.M[2] = m.wheel.Wheel.InPorts[2].M[2];
  m.wheel.Joints[1].OutPortB.M[3] = m.wheel.Wheel.InPorts[2].M[3];
  m.wheel.Joints[1].OutPortB.P[1] = m.wheel.Wheel.InPorts[2].P[1];
  m.wheel.Joints[1].OutPortB.P[2] = m.wheel.Wheel.InPorts[2].P[2];
  m.wheel.Joints[1].OutPortB.P[3] = m.wheel.Wheel.InPorts[2].P[3];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.Joints[2].InPortB.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.Joints[3].InPortB.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.Joints[4].InPortB.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.Joints[5].InPortB.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.OutPortK.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.Wheel.OutPort.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.Joints[2].InPortB.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.Joints[3].InPortB.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.Joints[4].InPortB.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.Joints[5].InPortB.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.OutPortK.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.Wheel.OutPort.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.Joints[2].InPortB.T[1,3];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.Joints[3].InPortB.T[1,3];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.Joints[4].InPortB.T[1,3];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.Joints[5].InPortB.T[1,3];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.OutPortK.T[1,3];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.Wheel.OutPort.T[1,3];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.Joints[2].InPortB.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.Joints[3].InPortB.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.Joints[4].InPortB.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.Joints[5].InPortB.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.OutPortK.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.Wheel.OutPort.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.Joints[2].InPortB.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.Joints[3].InPortB.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.Joints[4].InPortB.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.Joints[5].InPortB.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.OutPortK.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.Wheel.OutPort.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.Joints[2].InPortB.T[2,3];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.Joints[3].InPortB.T[2,3];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.Joints[4].InPortB.T[2,3];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.Joints[5].InPortB.T[2,3];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.OutPortK.T[2,3];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.Wheel.OutPort.T[2,3];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.Joints[2].InPortB.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.Joints[3].InPortB.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.Joints[4].InPortB.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.Joints[5].InPortB.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.OutPortK.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.Wheel.OutPort.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.Joints[2].InPortB.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.Joints[3].InPortB.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.Joints[4].InPortB.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.Joints[5].InPortB.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.OutPortK.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.Wheel.OutPort.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.Joints[2].InPortB.T[3,3];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.Joints[3].InPortB.T[3,3];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.Joints[4].InPortB.T[3,3];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.Joints[5].InPortB.T[3,3];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.OutPortK.T[3,3];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.Wheel.OutPort.T[3,3];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.Joints[2].InPortB.a[1];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.Joints[3].InPortB.a[1];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.Joints[4].InPortB.a[1];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.Joints[5].InPortB.a[1];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.OutPortK.a[1];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.Wheel.OutPort.a[1];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.Joints[2].InPortB.a[2];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.Joints[3].InPortB.a[2];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.Joints[4].InPortB.a[2];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.Joints[5].InPortB.a[2];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.OutPortK.a[2];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.Wheel.OutPort.a[2];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.Joints[2].InPortB.a[3];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.Joints[3].InPortB.a[3];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.Joints[4].InPortB.a[3];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.Joints[5].InPortB.a[3];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.OutPortK.a[3];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.Wheel.OutPort.a[3];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.Joints[2].InPortB.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.Joints[3].InPortB.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.Joints[4].InPortB.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.Joints[5].InPortB.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.OutPortK.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.Wheel.OutPort.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.Joints[2].InPortB.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.Joints[3].InPortB.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.Joints[4].InPortB.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.Joints[5].InPortB.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.OutPortK.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.Wheel.OutPort.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.Joints[2].InPortB.epsilon[3];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.Joints[3].InPortB.epsilon[3];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.Joints[4].InPortB.epsilon[3];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.Joints[5].InPortB.epsilon[3];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.OutPortK.epsilon[3];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.Wheel.OutPort.epsilon[3];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.Joints[2].InPortB.omega[1];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.Joints[3].InPortB.omega[1];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.Joints[4].InPortB.omega[1];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.Joints[5].InPortB.omega[1];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.OutPortK.omega[1];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.Wheel.OutPort.omega[1];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.Joints[2].InPortB.omega[2];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.Joints[3].InPortB.omega[2];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.Joints[4].InPortB.omega[2];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.Joints[5].InPortB.omega[2];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.OutPortK.omega[2];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.Wheel.OutPort.omega[2];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.Joints[2].InPortB.omega[3];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.Joints[3].InPortB.omega[3];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.Joints[4].InPortB.omega[3];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.Joints[5].InPortB.omega[3];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.OutPortK.omega[3];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.Wheel.OutPort.omega[3];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.Joints[2].InPortB.r[1];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.Joints[3].InPortB.r[1];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.Joints[4].InPortB.r[1];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.Joints[5].InPortB.r[1];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.OutPortK.r[1];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.Wheel.OutPort.r[1];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.Joints[2].InPortB.r[2];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.Joints[3].InPortB.r[2];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.Joints[4].InPortB.r[2];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.Joints[5].InPortB.r[2];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.OutPortK.r[2];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.Wheel.OutPort.r[2];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.Joints[2].InPortB.r[3];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.Joints[3].InPortB.r[3];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.Joints[4].InPortB.r[3];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.Joints[5].InPortB.r[3];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.OutPortK.r[3];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.Wheel.OutPort.r[3];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.Joints[2].InPortB.v[1];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.Joints[3].InPortB.v[1];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.Joints[4].InPortB.v[1];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.Joints[5].InPortB.v[1];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.OutPortK.v[1];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.Wheel.OutPort.v[1];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.Joints[2].InPortB.v[2];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.Joints[3].InPortB.v[2];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.Joints[4].InPortB.v[2];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.Joints[5].InPortB.v[2];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.OutPortK.v[2];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.Wheel.OutPort.v[2];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.Joints[2].InPortB.v[3];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.Joints[3].InPortB.v[3];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.Joints[4].InPortB.v[3];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.Joints[5].InPortB.v[3];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.OutPortK.v[3];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.Wheel.OutPort.v[3];
  m.wheel.Joints[2].OutPortA.F[1] = m.wheel.Rollers[2].InPorts[2].F[1];
  m.wheel.Joints[2].OutPortA.F[2] = m.wheel.Rollers[2].InPorts[2].F[2];
  m.wheel.Joints[2].OutPortA.F[3] = m.wheel.Rollers[2].InPorts[2].F[3];
  m.wheel.Joints[2].OutPortA.M[1] = m.wheel.Rollers[2].InPorts[2].M[1];
  m.wheel.Joints[2].OutPortA.M[2] = m.wheel.Rollers[2].InPorts[2].M[2];
  m.wheel.Joints[2].OutPortA.M[3] = m.wheel.Rollers[2].InPorts[2].M[3];
  m.wheel.Joints[2].OutPortA.P[1] = m.wheel.Rollers[2].InPorts[2].P[1];
  m.wheel.Joints[2].OutPortA.P[2] = m.wheel.Rollers[2].InPorts[2].P[2];
  m.wheel.Joints[2].OutPortA.P[3] = m.wheel.Rollers[2].InPorts[2].P[3];
  m.contacts[2].InPortB.T[1,1] = m.wheel.Joints[2].InPortA.T[1,1];
  m.contacts[2].InPortB.T[1,1] = m.wheel.Rollers[2].OutPort.T[1,1];
  m.contacts[2].InPortB.T[1,2] = m.wheel.Joints[2].InPortA.T[1,2];
  m.contacts[2].InPortB.T[1,2] = m.wheel.Rollers[2].OutPort.T[1,2];
  m.contacts[2].InPortB.T[1,3] = m.wheel.Joints[2].InPortA.T[1,3];
  m.contacts[2].InPortB.T[1,3] = m.wheel.Rollers[2].OutPort.T[1,3];
  m.contacts[2].InPortB.T[2,1] = m.wheel.Joints[2].InPortA.T[2,1];
  m.contacts[2].InPortB.T[2,1] = m.wheel.Rollers[2].OutPort.T[2,1];
  m.contacts[2].InPortB.T[2,2] = m.wheel.Joints[2].InPortA.T[2,2];
  m.contacts[2].InPortB.T[2,2] = m.wheel.Rollers[2].OutPort.T[2,2];
  m.contacts[2].InPortB.T[2,3] = m.wheel.Joints[2].InPortA.T[2,3];
  m.contacts[2].InPortB.T[2,3] = m.wheel.Rollers[2].OutPort.T[2,3];
  m.contacts[2].InPortB.T[3,1] = m.wheel.Joints[2].InPortA.T[3,1];
  m.contacts[2].InPortB.T[3,1] = m.wheel.Rollers[2].OutPort.T[3,1];
  m.contacts[2].InPortB.T[3,2] = m.wheel.Joints[2].InPortA.T[3,2];
  m.contacts[2].InPortB.T[3,2] = m.wheel.Rollers[2].OutPort.T[3,2];
  m.contacts[2].InPortB.T[3,3] = m.wheel.Joints[2].InPortA.T[3,3];
  m.contacts[2].InPortB.T[3,3] = m.wheel.Rollers[2].OutPort.T[3,3];
  m.contacts[2].InPortB.a[1] = m.wheel.Joints[2].InPortA.a[1];
  m.contacts[2].InPortB.a[1] = m.wheel.Rollers[2].OutPort.a[1];
  m.contacts[2].InPortB.a[2] = m.wheel.Joints[2].InPortA.a[2];
  m.contacts[2].InPortB.a[2] = m.wheel.Rollers[2].OutPort.a[2];
  m.contacts[2].InPortB.a[3] = m.wheel.Joints[2].InPortA.a[3];
  m.contacts[2].InPortB.a[3] = m.wheel.Rollers[2].OutPort.a[3];
  m.contacts[2].InPortB.epsilon[1] = m.wheel.Joints[2].InPortA.epsilon[1];
  m.contacts[2].InPortB.epsilon[1] = m.wheel.Rollers[2].OutPort.epsilon[1];
  m.contacts[2].InPortB.epsilon[2] = m.wheel.Joints[2].InPortA.epsilon[2];
  m.contacts[2].InPortB.epsilon[2] = m.wheel.Rollers[2].OutPort.epsilon[2];
  m.contacts[2].InPortB.epsilon[3] = m.wheel.Joints[2].InPortA.epsilon[3];
  m.contacts[2].InPortB.epsilon[3] = m.wheel.Rollers[2].OutPort.epsilon[3];
  m.contacts[2].InPortB.omega[1] = m.wheel.Joints[2].InPortA.omega[1];
  m.contacts[2].InPortB.omega[1] = m.wheel.Rollers[2].OutPort.omega[1];
  m.contacts[2].InPortB.omega[2] = m.wheel.Joints[2].InPortA.omega[2];
  m.contacts[2].InPortB.omega[2] = m.wheel.Rollers[2].OutPort.omega[2];
  m.contacts[2].InPortB.omega[3] = m.wheel.Joints[2].InPortA.omega[3];
  m.contacts[2].InPortB.omega[3] = m.wheel.Rollers[2].OutPort.omega[3];
  m.contacts[2].InPortB.r[1] = m.wheel.Joints[2].InPortA.r[1];
  m.contacts[2].InPortB.r[1] = m.wheel.Rollers[2].OutPort.r[1];
  m.contacts[2].InPortB.r[2] = m.wheel.Joints[2].InPortA.r[2];
  m.contacts[2].InPortB.r[2] = m.wheel.Rollers[2].OutPort.r[2];
  m.contacts[2].InPortB.r[3] = m.wheel.Joints[2].InPortA.r[3];
  m.contacts[2].InPortB.r[3] = m.wheel.Rollers[2].OutPort.r[3];
  m.contacts[2].InPortB.v[1] = m.wheel.Joints[2].InPortA.v[1];
  m.contacts[2].InPortB.v[1] = m.wheel.Rollers[2].OutPort.v[1];
  m.contacts[2].InPortB.v[2] = m.wheel.Joints[2].InPortA.v[2];
  m.contacts[2].InPortB.v[2] = m.wheel.Rollers[2].OutPort.v[2];
  m.contacts[2].InPortB.v[3] = m.wheel.Joints[2].InPortA.v[3];
  m.contacts[2].InPortB.v[3] = m.wheel.Rollers[2].OutPort.v[3];
  m.wheel.Joints[2].OutPortB.F[1] = m.wheel.Wheel.InPorts[3].F[1];
  m.wheel.Joints[2].OutPortB.F[2] = m.wheel.Wheel.InPorts[3].F[2];
  m.wheel.Joints[2].OutPortB.F[3] = m.wheel.Wheel.InPorts[3].F[3];
  m.wheel.Joints[2].OutPortB.M[1] = m.wheel.Wheel.InPorts[3].M[1];
  m.wheel.Joints[2].OutPortB.M[2] = m.wheel.Wheel.InPorts[3].M[2];
  m.wheel.Joints[2].OutPortB.M[3] = m.wheel.Wheel.InPorts[3].M[3];
  m.wheel.Joints[2].OutPortB.P[1] = m.wheel.Wheel.InPorts[3].P[1];
  m.wheel.Joints[2].OutPortB.P[2] = m.wheel.Wheel.InPorts[3].P[2];
  m.wheel.Joints[2].OutPortB.P[3] = m.wheel.Wheel.InPorts[3].P[3];
  m.wheel.Joints[3].OutPortA.F[1] = m.wheel.Rollers[3].InPorts[2].F[1];
  m.wheel.Joints[3].OutPortA.F[2] = m.wheel.Rollers[3].InPorts[2].F[2];
  m.wheel.Joints[3].OutPortA.F[3] = m.wheel.Rollers[3].InPorts[2].F[3];
  m.wheel.Joints[3].OutPortA.M[1] = m.wheel.Rollers[3].InPorts[2].M[1];
  m.wheel.Joints[3].OutPortA.M[2] = m.wheel.Rollers[3].InPorts[2].M[2];
  m.wheel.Joints[3].OutPortA.M[3] = m.wheel.Rollers[3].InPorts[2].M[3];
  m.wheel.Joints[3].OutPortA.P[1] = m.wheel.Rollers[3].InPorts[2].P[1];
  m.wheel.Joints[3].OutPortA.P[2] = m.wheel.Rollers[3].InPorts[2].P[2];
  m.wheel.Joints[3].OutPortA.P[3] = m.wheel.Rollers[3].InPorts[2].P[3];
  m.contacts[3].InPortB.T[1,1] = m.wheel.Joints[3].InPortA.T[1,1];
  m.contacts[3].InPortB.T[1,1] = m.wheel.Rollers[3].OutPort.T[1,1];
  m.contacts[3].InPortB.T[1,2] = m.wheel.Joints[3].InPortA.T[1,2];
  m.contacts[3].InPortB.T[1,2] = m.wheel.Rollers[3].OutPort.T[1,2];
  m.contacts[3].InPortB.T[1,3] = m.wheel.Joints[3].InPortA.T[1,3];
  m.contacts[3].InPortB.T[1,3] = m.wheel.Rollers[3].OutPort.T[1,3];
  m.contacts[3].InPortB.T[2,1] = m.wheel.Joints[3].InPortA.T[2,1];
  m.contacts[3].InPortB.T[2,1] = m.wheel.Rollers[3].OutPort.T[2,1];
  m.contacts[3].InPortB.T[2,2] = m.wheel.Joints[3].InPortA.T[2,2];
  m.contacts[3].InPortB.T[2,2] = m.wheel.Rollers[3].OutPort.T[2,2];
  m.contacts[3].InPortB.T[2,3] = m.wheel.Joints[3].InPortA.T[2,3];
  m.contacts[3].InPortB.T[2,3] = m.wheel.Rollers[3].OutPort.T[2,3];
  m.contacts[3].InPortB.T[3,1] = m.wheel.Joints[3].InPortA.T[3,1];
  m.contacts[3].InPortB.T[3,1] = m.wheel.Rollers[3].OutPort.T[3,1];
  m.contacts[3].InPortB.T[3,2] = m.wheel.Joints[3].InPortA.T[3,2];
  m.contacts[3].InPortB.T[3,2] = m.wheel.Rollers[3].OutPort.T[3,2];
  m.contacts[3].InPortB.T[3,3] = m.wheel.Joints[3].InPortA.T[3,3];
  m.contacts[3].InPortB.T[3,3] = m.wheel.Rollers[3].OutPort.T[3,3];
  m.contacts[3].InPortB.a[1] = m.wheel.Joints[3].InPortA.a[1];
  m.contacts[3].InPortB.a[1] = m.wheel.Rollers[3].OutPort.a[1];
  m.contacts[3].InPortB.a[2] = m.wheel.Joints[3].InPortA.a[2];
  m.contacts[3].InPortB.a[2] = m.wheel.Rollers[3].OutPort.a[2];
  m.contacts[3].InPortB.a[3] = m.wheel.Joints[3].InPortA.a[3];
  m.contacts[3].InPortB.a[3] = m.wheel.Rollers[3].OutPort.a[3];
  m.contacts[3].InPortB.epsilon[1] = m.wheel.Joints[3].InPortA.epsilon[1];
  m.contacts[3].InPortB.epsilon[1] = m.wheel.Rollers[3].OutPort.epsilon[1];
  m.contacts[3].InPortB.epsilon[2] = m.wheel.Joints[3].InPortA.epsilon[2];
  m.contacts[3].InPortB.epsilon[2] = m.wheel.Rollers[3].OutPort.epsilon[2];
  m.contacts[3].InPortB.epsilon[3] = m.wheel.Joints[3].InPortA.epsilon[3];
  m.contacts[3].InPortB.epsilon[3] = m.wheel.Rollers[3].OutPort.epsilon[3];
  m.contacts[3].InPortB.omega[1] = m.wheel.Joints[3].InPortA.omega[1];
  m.contacts[3].InPortB.omega[1] = m.wheel.Rollers[3].OutPort.omega[1];
  m.contacts[3].InPortB.omega[2] = m.wheel.Joints[3].InPortA.omega[2];
  m.contacts[3].InPortB.omega[2] = m.wheel.Rollers[3].OutPort.omega[2];
  m.contacts[3].InPortB.omega[3] = m.wheel.Joints[3].InPortA.omega[3];
  m.contacts[3].InPortB.omega[3] = m.wheel.Rollers[3].OutPort.omega[3];
  m.contacts[3].InPortB.r[1] = m.wheel.Joints[3].InPortA.r[1];
  m.contacts[3].InPortB.r[1] = m.wheel.Rollers[3].OutPort.r[1];
  m.contacts[3].InPortB.r[2] = m.wheel.Joints[3].InPortA.r[2];
  m.contacts[3].InPortB.r[2] = m.wheel.Rollers[3].OutPort.r[2];
  m.contacts[3].InPortB.r[3] = m.wheel.Joints[3].InPortA.r[3];
  m.contacts[3].InPortB.r[3] = m.wheel.Rollers[3].OutPort.r[3];
  m.contacts[3].InPortB.v[1] = m.wheel.Joints[3].InPortA.v[1];
  m.contacts[3].InPortB.v[1] = m.wheel.Rollers[3].OutPort.v[1];
  m.contacts[3].InPortB.v[2] = m.wheel.Joints[3].InPortA.v[2];
  m.contacts[3].InPortB.v[2] = m.wheel.Rollers[3].OutPort.v[2];
  m.contacts[3].InPortB.v[3] = m.wheel.Joints[3].InPortA.v[3];
  m.contacts[3].InPortB.v[3] = m.wheel.Rollers[3].OutPort.v[3];
  m.wheel.Joints[3].OutPortB.F[1] = m.wheel.Wheel.InPorts[4].F[1];
  m.wheel.Joints[3].OutPortB.F[2] = m.wheel.Wheel.InPorts[4].F[2];
  m.wheel.Joints[3].OutPortB.F[3] = m.wheel.Wheel.InPorts[4].F[3];
  m.wheel.Joints[3].OutPortB.M[1] = m.wheel.Wheel.InPorts[4].M[1];
  m.wheel.Joints[3].OutPortB.M[2] = m.wheel.Wheel.InPorts[4].M[2];
  m.wheel.Joints[3].OutPortB.M[3] = m.wheel.Wheel.InPorts[4].M[3];
  m.wheel.Joints[3].OutPortB.P[1] = m.wheel.Wheel.InPorts[4].P[1];
  m.wheel.Joints[3].OutPortB.P[2] = m.wheel.Wheel.InPorts[4].P[2];
  m.wheel.Joints[3].OutPortB.P[3] = m.wheel.Wheel.InPorts[4].P[3];
  m.wheel.Joints[4].OutPortA.F[1] = m.wheel.Rollers[4].InPorts[2].F[1];
  m.wheel.Joints[4].OutPortA.F[2] = m.wheel.Rollers[4].InPorts[2].F[2];
  m.wheel.Joints[4].OutPortA.F[3] = m.wheel.Rollers[4].InPorts[2].F[3];
  m.wheel.Joints[4].OutPortA.M[1] = m.wheel.Rollers[4].InPorts[2].M[1];
  m.wheel.Joints[4].OutPortA.M[2] = m.wheel.Rollers[4].InPorts[2].M[2];
  m.wheel.Joints[4].OutPortA.M[3] = m.wheel.Rollers[4].InPorts[2].M[3];
  m.wheel.Joints[4].OutPortA.P[1] = m.wheel.Rollers[4].InPorts[2].P[1];
  m.wheel.Joints[4].OutPortA.P[2] = m.wheel.Rollers[4].InPorts[2].P[2];
  m.wheel.Joints[4].OutPortA.P[3] = m.wheel.Rollers[4].InPorts[2].P[3];
  m.contacts[4].InPortB.T[1,1] = m.wheel.Joints[4].InPortA.T[1,1];
  m.contacts[4].InPortB.T[1,1] = m.wheel.Rollers[4].OutPort.T[1,1];
  m.contacts[4].InPortB.T[1,2] = m.wheel.Joints[4].InPortA.T[1,2];
  m.contacts[4].InPortB.T[1,2] = m.wheel.Rollers[4].OutPort.T[1,2];
  m.contacts[4].InPortB.T[1,3] = m.wheel.Joints[4].InPortA.T[1,3];
  m.contacts[4].InPortB.T[1,3] = m.wheel.Rollers[4].OutPort.T[1,3];
  m.contacts[4].InPortB.T[2,1] = m.wheel.Joints[4].InPortA.T[2,1];
  m.contacts[4].InPortB.T[2,1] = m.wheel.Rollers[4].OutPort.T[2,1];
  m.contacts[4].InPortB.T[2,2] = m.wheel.Joints[4].InPortA.T[2,2];
  m.contacts[4].InPortB.T[2,2] = m.wheel.Rollers[4].OutPort.T[2,2];
  m.contacts[4].InPortB.T[2,3] = m.wheel.Joints[4].InPortA.T[2,3];
  m.contacts[4].InPortB.T[2,3] = m.wheel.Rollers[4].OutPort.T[2,3];
  m.contacts[4].InPortB.T[3,1] = m.wheel.Joints[4].InPortA.T[3,1];
  m.contacts[4].InPortB.T[3,1] = m.wheel.Rollers[4].OutPort.T[3,1];
  m.contacts[4].InPortB.T[3,2] = m.wheel.Joints[4].InPortA.T[3,2];
  m.contacts[4].InPortB.T[3,2] = m.wheel.Rollers[4].OutPort.T[3,2];
  m.contacts[4].InPortB.T[3,3] = m.wheel.Joints[4].InPortA.T[3,3];
  m.contacts[4].InPortB.T[3,3] = m.wheel.Rollers[4].OutPort.T[3,3];
  m.contacts[4].InPortB.a[1] = m.wheel.Joints[4].InPortA.a[1];
  m.contacts[4].InPortB.a[1] = m.wheel.Rollers[4].OutPort.a[1];
  m.contacts[4].InPortB.a[2] = m.wheel.Joints[4].InPortA.a[2];
  m.contacts[4].InPortB.a[2] = m.wheel.Rollers[4].OutPort.a[2];
  m.contacts[4].InPortB.a[3] = m.wheel.Joints[4].InPortA.a[3];
  m.contacts[4].InPortB.a[3] = m.wheel.Rollers[4].OutPort.a[3];
  m.contacts[4].InPortB.epsilon[1] = m.wheel.Joints[4].InPortA.epsilon[1];
  m.contacts[4].InPortB.epsilon[1] = m.wheel.Rollers[4].OutPort.epsilon[1];
  m.contacts[4].InPortB.epsilon[2] = m.wheel.Joints[4].InPortA.epsilon[2];
  m.contacts[4].InPortB.epsilon[2] = m.wheel.Rollers[4].OutPort.epsilon[2];
  m.contacts[4].InPortB.epsilon[3] = m.wheel.Joints[4].InPortA.epsilon[3];
  m.contacts[4].InPortB.epsilon[3] = m.wheel.Rollers[4].OutPort.epsilon[3];
  m.contacts[4].InPortB.omega[1] = m.wheel.Joints[4].InPortA.omega[1];
  m.contacts[4].InPortB.omega[1] = m.wheel.Rollers[4].OutPort.omega[1];
  m.contacts[4].InPortB.omega[2] = m.wheel.Joints[4].InPortA.omega[2];
  m.contacts[4].InPortB.omega[2] = m.wheel.Rollers[4].OutPort.omega[2];
  m.contacts[4].InPortB.omega[3] = m.wheel.Joints[4].InPortA.omega[3];
  m.contacts[4].InPortB.omega[3] = m.wheel.Rollers[4].OutPort.omega[3];
  m.contacts[4].InPortB.r[1] = m.wheel.Joints[4].InPortA.r[1];
  m.contacts[4].InPortB.r[1] = m.wheel.Rollers[4].OutPort.r[1];
  m.contacts[4].InPortB.r[2] = m.wheel.Joints[4].InPortA.r[2];
  m.contacts[4].InPortB.r[2] = m.wheel.Rollers[4].OutPort.r[2];
  m.contacts[4].InPortB.r[3] = m.wheel.Joints[4].InPortA.r[3];
  m.contacts[4].InPortB.r[3] = m.wheel.Rollers[4].OutPort.r[3];
  m.contacts[4].InPortB.v[1] = m.wheel.Joints[4].InPortA.v[1];
  m.contacts[4].InPortB.v[1] = m.wheel.Rollers[4].OutPort.v[1];
  m.contacts[4].InPortB.v[2] = m.wheel.Joints[4].InPortA.v[2];
  m.contacts[4].InPortB.v[2] = m.wheel.Rollers[4].OutPort.v[2];
  m.contacts[4].InPortB.v[3] = m.wheel.Joints[4].InPortA.v[3];
  m.contacts[4].InPortB.v[3] = m.wheel.Rollers[4].OutPort.v[3];
  m.wheel.Joints[4].OutPortB.F[1] = m.wheel.Wheel.InPorts[5].F[1];
  m.wheel.Joints[4].OutPortB.F[2] = m.wheel.Wheel.InPorts[5].F[2];
  m.wheel.Joints[4].OutPortB.F[3] = m.wheel.Wheel.InPorts[5].F[3];
  m.wheel.Joints[4].OutPortB.M[1] = m.wheel.Wheel.InPorts[5].M[1];
  m.wheel.Joints[4].OutPortB.M[2] = m.wheel.Wheel.InPorts[5].M[2];
  m.wheel.Joints[4].OutPortB.M[3] = m.wheel.Wheel.InPorts[5].M[3];
  m.wheel.Joints[4].OutPortB.P[1] = m.wheel.Wheel.InPorts[5].P[1];
  m.wheel.Joints[4].OutPortB.P[2] = m.wheel.Wheel.InPorts[5].P[2];
  m.wheel.Joints[4].OutPortB.P[3] = m.wheel.Wheel.InPorts[5].P[3];
  m.wheel.Joints[5].OutPortA.F[1] = m.wheel.Rollers[5].InPorts[2].F[1];
  m.wheel.Joints[5].OutPortA.F[2] = m.wheel.Rollers[5].InPorts[2].F[2];
  m.wheel.Joints[5].OutPortA.F[3] = m.wheel.Rollers[5].InPorts[2].F[3];
  m.wheel.Joints[5].OutPortA.M[1] = m.wheel.Rollers[5].InPorts[2].M[1];
  m.wheel.Joints[5].OutPortA.M[2] = m.wheel.Rollers[5].InPorts[2].M[2];
  m.wheel.Joints[5].OutPortA.M[3] = m.wheel.Rollers[5].InPorts[2].M[3];
  m.wheel.Joints[5].OutPortA.P[1] = m.wheel.Rollers[5].InPorts[2].P[1];
  m.wheel.Joints[5].OutPortA.P[2] = m.wheel.Rollers[5].InPorts[2].P[2];
  m.wheel.Joints[5].OutPortA.P[3] = m.wheel.Rollers[5].InPorts[2].P[3];
  m.contacts[5].InPortB.T[1,1] = m.wheel.Joints[5].InPortA.T[1,1];
  m.contacts[5].InPortB.T[1,1] = m.wheel.Rollers[5].OutPort.T[1,1];
  m.contacts[5].InPortB.T[1,2] = m.wheel.Joints[5].InPortA.T[1,2];
  m.contacts[5].InPortB.T[1,2] = m.wheel.Rollers[5].OutPort.T[1,2];
  m.contacts[5].InPortB.T[1,3] = m.wheel.Joints[5].InPortA.T[1,3];
  m.contacts[5].InPortB.T[1,3] = m.wheel.Rollers[5].OutPort.T[1,3];
  m.contacts[5].InPortB.T[2,1] = m.wheel.Joints[5].InPortA.T[2,1];
  m.contacts[5].InPortB.T[2,1] = m.wheel.Rollers[5].OutPort.T[2,1];
  m.contacts[5].InPortB.T[2,2] = m.wheel.Joints[5].InPortA.T[2,2];
  m.contacts[5].InPortB.T[2,2] = m.wheel.Rollers[5].OutPort.T[2,2];
  m.contacts[5].InPortB.T[2,3] = m.wheel.Joints[5].InPortA.T[2,3];
  m.contacts[5].InPortB.T[2,3] = m.wheel.Rollers[5].OutPort.T[2,3];
  m.contacts[5].InPortB.T[3,1] = m.wheel.Joints[5].InPortA.T[3,1];
  m.contacts[5].InPortB.T[3,1] = m.wheel.Rollers[5].OutPort.T[3,1];
  m.contacts[5].InPortB.T[3,2] = m.wheel.Joints[5].InPortA.T[3,2];
  m.contacts[5].InPortB.T[3,2] = m.wheel.Rollers[5].OutPort.T[3,2];
  m.contacts[5].InPortB.T[3,3] = m.wheel.Joints[5].InPortA.T[3,3];
  m.contacts[5].InPortB.T[3,3] = m.wheel.Rollers[5].OutPort.T[3,3];
  m.contacts[5].InPortB.a[1] = m.wheel.Joints[5].InPortA.a[1];
  m.contacts[5].InPortB.a[1] = m.wheel.Rollers[5].OutPort.a[1];
  m.contacts[5].InPortB.a[2] = m.wheel.Joints[5].InPortA.a[2];
  m.contacts[5].InPortB.a[2] = m.wheel.Rollers[5].OutPort.a[2];
  m.contacts[5].InPortB.a[3] = m.wheel.Joints[5].InPortA.a[3];
  m.contacts[5].InPortB.a[3] = m.wheel.Rollers[5].OutPort.a[3];
  m.contacts[5].InPortB.epsilon[1] = m.wheel.Joints[5].InPortA.epsilon[1];
  m.contacts[5].InPortB.epsilon[1] = m.wheel.Rollers[5].OutPort.epsilon[1];
  m.contacts[5].InPortB.epsilon[2] = m.wheel.Joints[5].InPortA.epsilon[2];
  m.contacts[5].InPortB.epsilon[2] = m.wheel.Rollers[5].OutPort.epsilon[2];
  m.contacts[5].InPortB.epsilon[3] = m.wheel.Joints[5].InPortA.epsilon[3];
  m.contacts[5].InPortB.epsilon[3] = m.wheel.Rollers[5].OutPort.epsilon[3];
  m.contacts[5].InPortB.omega[1] = m.wheel.Joints[5].InPortA.omega[1];
  m.contacts[5].InPortB.omega[1] = m.wheel.Rollers[5].OutPort.omega[1];
  m.contacts[5].InPortB.omega[2] = m.wheel.Joints[5].InPortA.omega[2];
  m.contacts[5].InPortB.omega[2] = m.wheel.Rollers[5].OutPort.omega[2];
  m.contacts[5].InPortB.omega[3] = m.wheel.Joints[5].InPortA.omega[3];
  m.contacts[5].InPortB.omega[3] = m.wheel.Rollers[5].OutPort.omega[3];
  m.contacts[5].InPortB.r[1] = m.wheel.Joints[5].InPortA.r[1];
  m.contacts[5].InPortB.r[1] = m.wheel.Rollers[5].OutPort.r[1];
  m.contacts[5].InPortB.r[2] = m.wheel.Joints[5].InPortA.r[2];
  m.contacts[5].InPortB.r[2] = m.wheel.Rollers[5].OutPort.r[2];
  m.contacts[5].InPortB.r[3] = m.wheel.Joints[5].InPortA.r[3];
  m.contacts[5].InPortB.r[3] = m.wheel.Rollers[5].OutPort.r[3];
  m.contacts[5].InPortB.v[1] = m.wheel.Joints[5].InPortA.v[1];
  m.contacts[5].InPortB.v[1] = m.wheel.Rollers[5].OutPort.v[1];
  m.contacts[5].InPortB.v[2] = m.wheel.Joints[5].InPortA.v[2];
  m.contacts[5].InPortB.v[2] = m.wheel.Rollers[5].OutPort.v[2];
  m.contacts[5].InPortB.v[3] = m.wheel.Joints[5].InPortA.v[3];
  m.contacts[5].InPortB.v[3] = m.wheel.Rollers[5].OutPort.v[3];
  m.wheel.Joints[5].OutPortB.F[1] = m.wheel.Wheel.InPorts[6].F[1];
  m.wheel.Joints[5].OutPortB.F[2] = m.wheel.Wheel.InPorts[6].F[2];
  m.wheel.Joints[5].OutPortB.F[3] = m.wheel.Wheel.InPorts[6].F[3];
  m.wheel.Joints[5].OutPortB.M[1] = m.wheel.Wheel.InPorts[6].M[1];
  m.wheel.Joints[5].OutPortB.M[2] = m.wheel.Wheel.InPorts[6].M[2];
  m.wheel.Joints[5].OutPortB.M[3] = m.wheel.Wheel.InPorts[6].M[3];
  m.wheel.Joints[5].OutPortB.P[1] = m.wheel.Wheel.InPorts[6].P[1];
  m.wheel.Joints[5].OutPortB.P[2] = m.wheel.Wheel.InPorts[6].P[2];
  m.wheel.Joints[5].OutPortB.P[3] = m.wheel.Wheel.InPorts[6].P[3];
  m.wheel.InPortF.F[1] = m.wheel.Wheel.InPorts[1].F[1];
  m.wheel.InPortF.F[2] = m.wheel.Wheel.InPorts[1].F[2];
  m.wheel.InPortF.F[3] = m.wheel.Wheel.InPorts[1].F[3];
  m.wheel.InPortF.M[1] = m.wheel.Wheel.InPorts[1].M[1];
  m.wheel.InPortF.M[2] = m.wheel.Wheel.InPorts[1].M[2];
  m.wheel.InPortF.M[3] = m.wheel.Wheel.InPorts[1].M[3];
  m.wheel.InPortF.P[1] = m.wheel.Wheel.InPorts[1].P[1];
  m.wheel.InPortF.P[2] = m.wheel.Wheel.InPorts[1].P[2];
  m.wheel.InPortF.P[3] = m.wheel.Wheel.InPorts[1].P[3];
  m.base.OutPort.T[1,1] = m.contacts[1].InPortA.T[1,1];
  m.base.OutPort.T[1,1] = m.contacts[2].InPortA.T[1,1];
  m.base.OutPort.T[1,1] = m.contacts[3].InPortA.T[1,1];
  m.base.OutPort.T[1,1] = m.contacts[4].InPortA.T[1,1];
  m.base.OutPort.T[1,1] = m.contacts[5].InPortA.T[1,1];
  m.base.OutPort.T[1,2] = m.contacts[1].InPortA.T[1,2];
  m.base.OutPort.T[1,2] = m.contacts[2].InPortA.T[1,2];
  m.base.OutPort.T[1,2] = m.contacts[3].InPortA.T[1,2];
  m.base.OutPort.T[1,2] = m.contacts[4].InPortA.T[1,2];
  m.base.OutPort.T[1,2] = m.contacts[5].InPortA.T[1,2];
  m.base.OutPort.T[1,3] = m.contacts[1].InPortA.T[1,3];
  m.base.OutPort.T[1,3] = m.contacts[2].InPortA.T[1,3];
  m.base.OutPort.T[1,3] = m.contacts[3].InPortA.T[1,3];
  m.base.OutPort.T[1,3] = m.contacts[4].InPortA.T[1,3];
  m.base.OutPort.T[1,3] = m.contacts[5].InPortA.T[1,3];
  m.base.OutPort.T[2,1] = m.contacts[1].InPortA.T[2,1];
  m.base.OutPort.T[2,1] = m.contacts[2].InPortA.T[2,1];
  m.base.OutPort.T[2,1] = m.contacts[3].InPortA.T[2,1];
  m.base.OutPort.T[2,1] = m.contacts[4].InPortA.T[2,1];
  m.base.OutPort.T[2,1] = m.contacts[5].InPortA.T[2,1];
  m.base.OutPort.T[2,2] = m.contacts[1].InPortA.T[2,2];
  m.base.OutPort.T[2,2] = m.contacts[2].InPortA.T[2,2];
  m.base.OutPort.T[2,2] = m.contacts[3].InPortA.T[2,2];
  m.base.OutPort.T[2,2] = m.contacts[4].InPortA.T[2,2];
  m.base.OutPort.T[2,2] = m.contacts[5].InPortA.T[2,2];
  m.base.OutPort.T[2,3] = m.contacts[1].InPortA.T[2,3];
  m.base.OutPort.T[2,3] = m.contacts[2].InPortA.T[2,3];
  m.base.OutPort.T[2,3] = m.contacts[3].InPortA.T[2,3];
  m.base.OutPort.T[2,3] = m.contacts[4].InPortA.T[2,3];
  m.base.OutPort.T[2,3] = m.contacts[5].InPortA.T[2,3];
  m.base.OutPort.T[3,1] = m.contacts[1].InPortA.T[3,1];
  m.base.OutPort.T[3,1] = m.contacts[2].InPortA.T[3,1];
  m.base.OutPort.T[3,1] = m.contacts[3].InPortA.T[3,1];
  m.base.OutPort.T[3,1] = m.contacts[4].InPortA.T[3,1];
  m.base.OutPort.T[3,1] = m.contacts[5].InPortA.T[3,1];
  m.base.OutPort.T[3,2] = m.contacts[1].InPortA.T[3,2];
  m.base.OutPort.T[3,2] = m.contacts[2].InPortA.T[3,2];
  m.base.OutPort.T[3,2] = m.contacts[3].InPortA.T[3,2];
  m.base.OutPort.T[3,2] = m.contacts[4].InPortA.T[3,2];
  m.base.OutPort.T[3,2] = m.contacts[5].InPortA.T[3,2];
  m.base.OutPort.T[3,3] = m.contacts[1].InPortA.T[3,3];
  m.base.OutPort.T[3,3] = m.contacts[2].InPortA.T[3,3];
  m.base.OutPort.T[3,3] = m.contacts[3].InPortA.T[3,3];
  m.base.OutPort.T[3,3] = m.contacts[4].InPortA.T[3,3];
  m.base.OutPort.T[3,3] = m.contacts[5].InPortA.T[3,3];
  m.base.OutPort.a[1] = m.contacts[1].InPortA.a[1];
  m.base.OutPort.a[1] = m.contacts[2].InPortA.a[1];
  m.base.OutPort.a[1] = m.contacts[3].InPortA.a[1];
  m.base.OutPort.a[1] = m.contacts[4].InPortA.a[1];
  m.base.OutPort.a[1] = m.contacts[5].InPortA.a[1];
  m.base.OutPort.a[2] = m.contacts[1].InPortA.a[2];
  m.base.OutPort.a[2] = m.contacts[2].InPortA.a[2];
  m.base.OutPort.a[2] = m.contacts[3].InPortA.a[2];
  m.base.OutPort.a[2] = m.contacts[4].InPortA.a[2];
  m.base.OutPort.a[2] = m.contacts[5].InPortA.a[2];
  m.base.OutPort.a[3] = m.contacts[1].InPortA.a[3];
  m.base.OutPort.a[3] = m.contacts[2].InPortA.a[3];
  m.base.OutPort.a[3] = m.contacts[3].InPortA.a[3];
  m.base.OutPort.a[3] = m.contacts[4].InPortA.a[3];
  m.base.OutPort.a[3] = m.contacts[5].InPortA.a[3];
  m.base.OutPort.epsilon[1] = m.contacts[1].InPortA.epsilon[1];
  m.base.OutPort.epsilon[1] = m.contacts[2].InPortA.epsilon[1];
  m.base.OutPort.epsilon[1] = m.contacts[3].InPortA.epsilon[1];
  m.base.OutPort.epsilon[1] = m.contacts[4].InPortA.epsilon[1];
  m.base.OutPort.epsilon[1] = m.contacts[5].InPortA.epsilon[1];
  m.base.OutPort.epsilon[2] = m.contacts[1].InPortA.epsilon[2];
  m.base.OutPort.epsilon[2] = m.contacts[2].InPortA.epsilon[2];
  m.base.OutPort.epsilon[2] = m.contacts[3].InPortA.epsilon[2];
  m.base.OutPort.epsilon[2] = m.contacts[4].InPortA.epsilon[2];
  m.base.OutPort.epsilon[2] = m.contacts[5].InPortA.epsilon[2];
  m.base.OutPort.epsilon[3] = m.contacts[1].InPortA.epsilon[3];
  m.base.OutPort.epsilon[3] = m.contacts[2].InPortA.epsilon[3];
  m.base.OutPort.epsilon[3] = m.contacts[3].InPortA.epsilon[3];
  m.base.OutPort.epsilon[3] = m.contacts[4].InPortA.epsilon[3];
  m.base.OutPort.epsilon[3] = m.contacts[5].InPortA.epsilon[3];
  m.base.OutPort.omega[1] = m.contacts[1].InPortA.omega[1];
  m.base.OutPort.omega[1] = m.contacts[2].InPortA.omega[1];
  m.base.OutPort.omega[1] = m.contacts[3].InPortA.omega[1];
  m.base.OutPort.omega[1] = m.contacts[4].InPortA.omega[1];
  m.base.OutPort.omega[1] = m.contacts[5].InPortA.omega[1];
  m.base.OutPort.omega[2] = m.contacts[1].InPortA.omega[2];
  m.base.OutPort.omega[2] = m.contacts[2].InPortA.omega[2];
  m.base.OutPort.omega[2] = m.contacts[3].InPortA.omega[2];
  m.base.OutPort.omega[2] = m.contacts[4].InPortA.omega[2];
  m.base.OutPort.omega[2] = m.contacts[5].InPortA.omega[2];
  m.base.OutPort.omega[3] = m.contacts[1].InPortA.omega[3];
  m.base.OutPort.omega[3] = m.contacts[2].InPortA.omega[3];
  m.base.OutPort.omega[3] = m.contacts[3].InPortA.omega[3];
  m.base.OutPort.omega[3] = m.contacts[4].InPortA.omega[3];
  m.base.OutPort.omega[3] = m.contacts[5].InPortA.omega[3];
  m.base.OutPort.r[1] = m.contacts[1].InPortA.r[1];
  m.base.OutPort.r[1] = m.contacts[2].InPortA.r[1];
  m.base.OutPort.r[1] = m.contacts[3].InPortA.r[1];
  m.base.OutPort.r[1] = m.contacts[4].InPortA.r[1];
  m.base.OutPort.r[1] = m.contacts[5].InPortA.r[1];
  m.base.OutPort.r[2] = m.contacts[1].InPortA.r[2];
  m.base.OutPort.r[2] = m.contacts[2].InPortA.r[2];
  m.base.OutPort.r[2] = m.contacts[3].InPortA.r[2];
  m.base.OutPort.r[2] = m.contacts[4].InPortA.r[2];
  m.base.OutPort.r[2] = m.contacts[5].InPortA.r[2];
  m.base.OutPort.r[3] = m.contacts[1].InPortA.r[3];
  m.base.OutPort.r[3] = m.contacts[2].InPortA.r[3];
  m.base.OutPort.r[3] = m.contacts[3].InPortA.r[3];
  m.base.OutPort.r[3] = m.contacts[4].InPortA.r[3];
  m.base.OutPort.r[3] = m.contacts[5].InPortA.r[3];
  m.base.OutPort.v[1] = m.contacts[1].InPortA.v[1];
  m.base.OutPort.v[1] = m.contacts[2].InPortA.v[1];
  m.base.OutPort.v[1] = m.contacts[3].InPortA.v[1];
  m.base.OutPort.v[1] = m.contacts[4].InPortA.v[1];
  m.base.OutPort.v[1] = m.contacts[5].InPortA.v[1];
  m.base.OutPort.v[2] = m.contacts[1].InPortA.v[2];
  m.base.OutPort.v[2] = m.contacts[2].InPortA.v[2];
  m.base.OutPort.v[2] = m.contacts[3].InPortA.v[2];
  m.base.OutPort.v[2] = m.contacts[4].InPortA.v[2];
  m.base.OutPort.v[2] = m.contacts[5].InPortA.v[2];
  m.base.OutPort.v[3] = m.contacts[1].InPortA.v[3];
  m.base.OutPort.v[3] = m.contacts[2].InPortA.v[3];
  m.base.OutPort.v[3] = m.contacts[3].InPortA.v[3];
  m.base.OutPort.v[3] = m.contacts[4].InPortA.v[3];
  m.base.OutPort.v[3] = m.contacts[5].InPortA.v[3];
  m.contacts[1].OutPortB.F[1] = m.wheel.Rollers[1].InPorts[1].F[1];
  m.contacts[1].OutPortB.F[2] = m.wheel.Rollers[1].InPorts[1].F[2];
  m.contacts[1].OutPortB.F[3] = m.wheel.Rollers[1].InPorts[1].F[3];
  m.contacts[1].OutPortB.M[1] = m.wheel.Rollers[1].InPorts[1].M[1];
  m.contacts[1].OutPortB.M[2] = m.wheel.Rollers[1].InPorts[1].M[2];
  m.contacts[1].OutPortB.M[3] = m.wheel.Rollers[1].InPorts[1].M[3];
  m.contacts[1].OutPortB.P[1] = m.wheel.Rollers[1].InPorts[1].P[1];
  m.contacts[1].OutPortB.P[2] = m.wheel.Rollers[1].InPorts[1].P[2];
  m.contacts[1].OutPortB.P[3] = m.wheel.Rollers[1].InPorts[1].P[3];
  m.contacts[2].OutPortB.F[1] = m.wheel.Rollers[2].InPorts[1].F[1];
  m.contacts[2].OutPortB.F[2] = m.wheel.Rollers[2].InPorts[1].F[2];
  m.contacts[2].OutPortB.F[3] = m.wheel.Rollers[2].InPorts[1].F[3];
  m.contacts[2].OutPortB.M[1] = m.wheel.Rollers[2].InPorts[1].M[1];
  m.contacts[2].OutPortB.M[2] = m.wheel.Rollers[2].InPorts[1].M[2];
  m.contacts[2].OutPortB.M[3] = m.wheel.Rollers[2].InPorts[1].M[3];
  m.contacts[2].OutPortB.P[1] = m.wheel.Rollers[2].InPorts[1].P[1];
  m.contacts[2].OutPortB.P[2] = m.wheel.Rollers[2].InPorts[1].P[2];
  m.contacts[2].OutPortB.P[3] = m.wheel.Rollers[2].InPorts[1].P[3];
  m.contacts[3].OutPortB.F[1] = m.wheel.Rollers[3].InPorts[1].F[1];
  m.contacts[3].OutPortB.F[2] = m.wheel.Rollers[3].InPorts[1].F[2];
  m.contacts[3].OutPortB.F[3] = m.wheel.Rollers[3].InPorts[1].F[3];
  m.contacts[3].OutPortB.M[1] = m.wheel.Rollers[3].InPorts[1].M[1];
  m.contacts[3].OutPortB.M[2] = m.wheel.Rollers[3].InPorts[1].M[2];
  m.contacts[3].OutPortB.M[3] = m.wheel.Rollers[3].InPorts[1].M[3];
  m.contacts[3].OutPortB.P[1] = m.wheel.Rollers[3].InPorts[1].P[1];
  m.contacts[3].OutPortB.P[2] = m.wheel.Rollers[3].InPorts[1].P[2];
  m.contacts[3].OutPortB.P[3] = m.wheel.Rollers[3].InPorts[1].P[3];
  m.contacts[4].OutPortB.F[1] = m.wheel.Rollers[4].InPorts[1].F[1];
  m.contacts[4].OutPortB.F[2] = m.wheel.Rollers[4].InPorts[1].F[2];
  m.contacts[4].OutPortB.F[3] = m.wheel.Rollers[4].InPorts[1].F[3];
  m.contacts[4].OutPortB.M[1] = m.wheel.Rollers[4].InPorts[1].M[1];
  m.contacts[4].OutPortB.M[2] = m.wheel.Rollers[4].InPorts[1].M[2];
  m.contacts[4].OutPortB.M[3] = m.wheel.Rollers[4].InPorts[1].M[3];
  m.contacts[4].OutPortB.P[1] = m.wheel.Rollers[4].InPorts[1].P[1];
  m.contacts[4].OutPortB.P[2] = m.wheel.Rollers[4].InPorts[1].P[2];
  m.contacts[4].OutPortB.P[3] = m.wheel.Rollers[4].InPorts[1].P[3];
  m.contacts[5].OutPortB.F[1] = m.wheel.Rollers[5].InPorts[1].F[1];
  m.contacts[5].OutPortB.F[2] = m.wheel.Rollers[5].InPorts[1].F[2];
  m.contacts[5].OutPortB.F[3] = m.wheel.Rollers[5].InPorts[1].F[3];
  m.contacts[5].OutPortB.M[1] = m.wheel.Rollers[5].InPorts[1].M[1];
  m.contacts[5].OutPortB.M[2] = m.wheel.Rollers[5].InPorts[1].M[2];
  m.contacts[5].OutPortB.M[3] = m.wheel.Rollers[5].InPorts[1].M[3];
  m.contacts[5].OutPortB.P[1] = m.wheel.Rollers[5].InPorts[1].P[1];
  m.contacts[5].OutPortB.P[2] = m.wheel.Rollers[5].InPorts[1].P[2];
  m.contacts[5].OutPortB.P[3] = m.wheel.Rollers[5].InPorts[1].P[3];
end MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest;
"
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Test/Omni/OmniWheelOnPlaneOldSchoolTest.mo:28:3-33:11:writable] Warning: In component <NO COMPONENT>, in relation time == 1.0,  ==  on Real numbers is only allowed inside functions.
"
====================================
Checking MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest
"Check of MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest completed successfully.
Class MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest has 1428 equation(s) and 1428 variable(s).
1013 of these are trivial equation(s)."
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Test/Omni/OmniWheelOnPlaneOldSchoolTest.mo:28:3-33:11:writable] Warning: In component <NO COMPONENT>, in relation time == 1.0,  ==  on Real numbers is only allowed inside functions.
"
====================================
Simulating MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest
record SimulationResult
    resultFile = "/home/vf/om/models/omni/test/out/MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest_res.csv",
    simulationOptions = "startTime = 0.0, stopTime = 10.0, numberOfIntervals = 1000, tolerance = 1e-09, method = 'dassl', fileNamePrefix = 'MbsLite.Test.Omni.OmniWheelOnPlaneOldSchoolTest', options = '', outputFormat = 'csv', variableFilter = '.*', cflags = '', simflags = ''",
    messages = "stdout            | info    | The initialization finished successfully without homotopy method.
stdout            | info    | The simulation finished successfully.
",
    timeFrontend = 1.878720082,
    timeBackend = 3.166763169,
    timeSimCode = 0.4030321699999999,
    timeTemplates = 1.226023509,
    timeCompile = 15.283584668,
    timeSimulation = 3.025603791,
    timeTotal = 24.984622455
end SimulationResult;
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Examples/OmniVehicle/Full/OmniWheelOnPlaneOldSchool.mo:31:13-32:5:writable] Warning: Non-array modification 'MbsLite.Examples.OmniVehicle.Params("params used in the PMM paper", 3, 5, 0.0, 0.15, 0.05, 1.0, 0.15, 0.05, 0.6283185307179586, 0.04045084971874738, 0.004774575140626312, 0.02938926261462366, 0.01125, 0.005633333333333334, 0.0001227203432226514, 6.261017161132568e-05, 5.699141943371693e-07, 3.8838269181324e-06)' for array component, possibly due to missing 'each'.
[/home/vf/om/models/omni/thin/lib/MbsLite/Test/Omni/OmniWheelOnPlaneOldSchoolTest.mo:28:3-33:11:writable] Warning: In component <NO COMPONENT>, in relation time == 1.0,  ==  on Real numbers is only allowed inside functions.
Warning: Assuming fixed start value for the following 84 variables:
         m.wheel.Joints[5].angle:VARIABLE()  "Relative angle. Beware numerical error accumulation!" type: Real  [5]
         m.wheel.Joints[4].angle:VARIABLE()  "Relative angle. Beware numerical error accumulation!" type: Real  [5]
         m.wheel.Joints[3].angle:VARIABLE()  "Relative angle. Beware numerical error accumulation!" type: Real  [5]
         m.wheel.Joints[2].angle:VARIABLE()  "Relative angle. Beware numerical error accumulation!" type: Real  [5]
         m.wheel.Joints[1].angle:VARIABLE()  "Relative angle. Beware numerical error accumulation!" type: Real  [5]
         m.wheel.Joints[5].mu:VARIABLE(unit = "rad/s" )  "Relative angular velocity along the axis" type: Real  [5]
         m.wheel.Joints[4].mu:VARIABLE(unit = "rad/s" )  "Relative angular velocity along the axis" type: Real  [5]
         m.wheel.Joints[3].mu:VARIABLE(unit = "rad/s" )  "Relative angular velocity along the axis" type: Real  [5]
         m.wheel.Joints[2].mu:VARIABLE(unit = "rad/s" )  "Relative angular velocity along the axis" type: Real  [5]
         m.wheel.Joints[1].mu:VARIABLE(unit = "rad/s" )  "Relative angular velocity along the axis" type: Real  [5]
         m.contacts[5].isInContact:DISCRETE(fixed = false protected = true )  type: Boolean  [5]
         m.contacts[4].isInContact:DISCRETE(fixed = false protected = true )  type: Boolean  [5]
         m.contacts[3].isInContact:DISCRETE(fixed = false protected = true )  type: Boolean  [5]
         m.contacts[2].isInContact:DISCRETE(fixed = false protected = true )  type: Boolean  [5]
         m.contacts[1].isInContact:DISCRETE(fixed = false protected = true )  type: Boolean  [5]
         m.wheel.Wheel.Active:VARIABLE(start = 1.0 )  "Flag of active dynamics" type: Real 
         m.wheel.Wheel.omega[3]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [3]
         m.wheel.Wheel.omega[2]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [3]
         m.wheel.Wheel.omega[1]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [3]
         m.wheel.Wheel.q[4]:VARIABLE(start = 0.0 )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [4]
         m.wheel.Wheel.q[3]:VARIABLE(start = 0.0 )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [4]
         m.wheel.Wheel.q[2]:VARIABLE(start = 0.0 )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [4]
         m.wheel.Wheel.q[1]:VARIABLE(start = 1.0 )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [4]
         m.wheel.Wheel.v[3]:VARIABLE(start = 0.0 unit = "m/s" )  "Velocity vector of masscenter" type: Real  [3]
         m.wheel.Wheel.v[2]:VARIABLE(start = 0.0 unit = "m/s" )  "Velocity vector of masscenter" type: Real  [3]
         m.wheel.Wheel.v[1]:VARIABLE(start = 0.0 unit = "m/s" )  "Velocity vector of masscenter" type: Real  [3]
         m.wheel.Wheel.r[3]:VARIABLE(start = 0.0 unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [3]
         m.wheel.Wheel.r[2]:VARIABLE(start = 0.05 unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [3]
         m.wheel.Wheel.r[1]:VARIABLE(start = 0.0 unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [3]
         m.wheel.Rollers[5].Active:VARIABLE(start = 1.0 )  "Flag of active dynamics" type: Real  [5]
         m.wheel.Rollers[5].omega[3]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[5].omega[2]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[5].omega[1]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[5].q[4]:VARIABLE(start = m.wheel.RollerQs[5,4] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[5].q[3]:VARIABLE(start = m.wheel.RollerQs[5,3] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[5].q[2]:VARIABLE(start = m.wheel.RollerQs[5,2] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[5].q[1]:VARIABLE(start = m.wheel.RollerQs[5,1] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[5].r[3]:VARIABLE(start = m.wheel.RollerCenters[5,3] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[5].r[2]:VARIABLE(start = 0.05 + m.wheel.RollerCenters[5,2] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[5].r[1]:VARIABLE(start = m.wheel.RollerCenters[5,1] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[4].Active:VARIABLE(start = 1.0 )  "Flag of active dynamics" type: Real  [5]
         m.wheel.Rollers[4].omega[3]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[4].omega[2]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[4].omega[1]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[4].q[4]:VARIABLE(start = m.wheel.RollerQs[4,4] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[4].q[3]:VARIABLE(start = m.wheel.RollerQs[4,3] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[4].q[2]:VARIABLE(start = m.wheel.RollerQs[4,2] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[4].q[1]:VARIABLE(start = m.wheel.RollerQs[4,1] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[4].r[3]:VARIABLE(start = m.wheel.RollerCenters[4,3] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[4].r[2]:VARIABLE(start = 0.05 + m.wheel.RollerCenters[4,2] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[4].r[1]:VARIABLE(start = m.wheel.RollerCenters[4,1] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[3].Active:VARIABLE(start = 1.0 )  "Flag of active dynamics" type: Real  [5]
         m.wheel.Rollers[3].omega[3]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[3].omega[2]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[3].omega[1]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[3].q[4]:VARIABLE(start = m.wheel.RollerQs[3,4] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[3].q[3]:VARIABLE(start = m.wheel.RollerQs[3,3] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[3].q[2]:VARIABLE(start = m.wheel.RollerQs[3,2] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[3].q[1]:VARIABLE(start = m.wheel.RollerQs[3,1] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[3].r[3]:VARIABLE(start = m.wheel.RollerCenters[3,3] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[3].r[2]:VARIABLE(start = 0.05 + m.wheel.RollerCenters[3,2] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[3].r[1]:VARIABLE(start = m.wheel.RollerCenters[3,1] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[2].Active:VARIABLE(start = 1.0 )  "Flag of active dynamics" type: Real  [5]
         m.wheel.Rollers[2].omega[3]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[2].omega[2]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[2].omega[1]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[2].q[4]:VARIABLE(start = m.wheel.RollerQs[2,4] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[2].q[3]:VARIABLE(start = m.wheel.RollerQs[2,3] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[2].q[2]:VARIABLE(start = m.wheel.RollerQs[2,2] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[2].q[1]:VARIABLE(start = m.wheel.RollerQs[2,1] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[2].r[3]:VARIABLE(start = m.wheel.RollerCenters[2,3] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[2].r[2]:VARIABLE(start = 0.05 + m.wheel.RollerCenters[2,2] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[2].r[1]:VARIABLE(start = m.wheel.RollerCenters[2,1] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[1].Active:VARIABLE(start = 1.0 )  "Flag of active dynamics" type: Real  [5]
         m.wheel.Rollers[1].omega[3]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[1].omega[2]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
         m.wheel.Rollers[1].r[1]:VARIABLE(start = m.wheel.RollerCenters[1,1] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[1].r[2]:VARIABLE(start = 0.05 + m.wheel.RollerCenters[1,2] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[1].r[3]:VARIABLE(start = m.wheel.RollerCenters[1,3] unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [5,3]
         m.wheel.Rollers[1].q[1]:VARIABLE(start = m.wheel.RollerQs[1,1] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[1].q[2]:VARIABLE(start = m.wheel.RollerQs[1,2] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[1].q[3]:VARIABLE(start = m.wheel.RollerQs[1,3] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[1].q[4]:VARIABLE(start = m.wheel.RollerQs[1,4] )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [5,4]
         m.wheel.Rollers[1].omega[1]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [5,3]
"
