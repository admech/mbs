====================================
cd to out
"/home/vf/om/models/omni/test/out"
====================================
Setting ModelicaPath
true
====================================
Loading Modelica
true
====================================
Loading MbsLite
true
====================================
Loading MbsLite.Test.PendulumTest
true
====================================
Instantiating MbsLite.Test.PendulumTest
"function MbsLite.Util.Assert.AssertInitialized
  input String modelName;
  input Real[:] value;
  input String parameterName;
algorithm
  assert(max(value) < 9.999999999999999e+59, modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitialized;

function MbsLite.Util.Assert.AssertInitializedI
  input String modelName;
  input Integer value;
  input String parameterName;
algorithm
  assert(value > -4611686018427387903, modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitializedI;

function MbsLite.Util.Assert.AssertInitializedS
  input String modelName;
  input String value;
  input String parameterName;
algorithm
  assert(value <> \"NOT INITIALIZED\", modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitializedS;

function MbsLite.Util.CompareReal
  input Real a;
  input Real b;
  input Real absTol = 1e-10 \"Absolute tolerance.\";
  input Real relTol = 1e-05 \"Relative tolerance.\";
  output Boolean equal;
  protected Real diff;
algorithm
  diff := abs(a - b);
  equal := diff < absTol or diff <= max(abs(b), abs(a)) * relTol;
end MbsLite.Util.CompareReal;

function MbsLite.Util.Euler \"Inline before index reduction\"
  input Real[3] origin;
  input Real[3] point;
  input Real[3] velocityOfOrigin;
  input Real[3] omega;
  output Real[3] velocityOfPoint;
algorithm
  velocityOfPoint := {velocityOfOrigin[1] + omega[2] * (point[3] - origin[3]) - omega[3] * (point[2] - origin[2]), velocityOfOrigin[2] + omega[3] * (point[1] - origin[1]) - omega[1] * (point[3] - origin[3]), velocityOfOrigin[3] + omega[1] * (point[2] - origin[2]) - omega[2] * (point[1] - origin[1])};
end MbsLite.Util.Euler;

function MbsLite.Util.Quaternions.QMult \"Inline before index reduction\"
  input Real[4] q1;
  input Real[4] q2;
  output Real[4] q3;
  protected Real a1;
  protected Real a2;
  protected Real[3] A1;
  protected Real[3] A2;
  protected Real[3] A3;
algorithm
  a1 := q1[1];
  a2 := q2[1];
  A1 := {q1[2], q1[3], q1[4]};
  A2 := {q2[2], q2[3], q2[4]};
  A3 := {A2[1] * a1 + A1[1] * a2 + A1[2] * A2[3] - A1[3] * A2[2], A2[2] * a1 + A1[2] * a2 + A1[3] * A2[1] - A1[1] * A2[3], A2[3] * a1 + A1[3] * a2 + A1[1] * A2[2] - A1[2] * A2[1]};
  q3 := {a1 * a2 + (-A1[2]) * A2[2] - A1[3] * A2[3] - A1[1] * A2[1], A3[1], A3[2], A3[3]};
end MbsLite.Util.Quaternions.QMult;

function MbsLite.Util.Quaternions.QRot \"Inline before index reduction\"
  input Real angle;
  input Real[3] axis;
  output Real[4] q;
  protected Real s;
algorithm
  s := sin(0.5 * angle);
  q := {cos(0.5 * angle), s * axis[1], s * axis[2], s * axis[3]};
end MbsLite.Util.Quaternions.QRot;

function MbsLite.Util.Quaternions.QToT \"Inline before index reduction\" \"Converts quaternion to Rotation matrix.\"
  input Real[4] q;
  output Real[3, 3] T;
algorithm
  T := {{(q[1] ^ 2.0 + q[2] ^ 2.0 + (-q[3] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[3] - q[1] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[4] + q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[1] * q[4] + q[2] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[3] ^ 2.0 + (-q[2] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[3] * q[4] - q[1] * q[2]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[2] * q[4] - q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[1] * q[2] + q[3] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[4] ^ 2.0 - q[3] ^ 2.0 - q[2] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}};
end MbsLite.Util.Quaternions.QToT;

function MbsLite.Util.StringA
  input Real[:] array;
  input String delim = \", \";
  output String render;
  protected String accumulator = \"\";
  protected Integer counter = 0;
algorithm
  for item in array loop
    accumulator := accumulator + String(item, 0, true, 6);
    counter := 1 + counter;
    if counter < size(array, 1) then
      accumulator := accumulator + delim;
    end if;
  end for;
  render := \"{ \" + accumulator + \" }\";
end MbsLite.Util.StringA;

function Modelica.Math.Vectors.norm \"Return the p-norm of a vector\"
  input Real[:] v \"Real vector\";
  input Real p(min = 1.0) = 2.0 \"Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)\";
  output Real result = 0.0 \"p-norm of vector v\";
  protected Real eps = 1e-14;
algorithm
  if size(v, 1) > 0 then
    if p >= 2.0 - eps and p <= 2.0 + eps then
      result := sqrt(v * v);
    elseif p >= 9.999999999999999e+59 then
      result := max(array(abs($tmpVar6) for $tmpVar6 in v));
    elseif p >= 1.0 - eps and p <= 1.0 + eps then
      result := sum(array(abs($tmpVar9) for $tmpVar9 in v));
    elseif p >= 1.0 then
      result := sum(abs(v[i]) ^ p for i in 1:size(v, 1)) ^ (1.0 / p);
    else
      assert(false, \"Optional argument \\\"p\\\" (= \" + String(p, 0, true, 6) + \") of function \\\"norm\\\" >= 1 required\");
    end if;
  end if;
end Modelica.Math.Vectors.norm;

class MbsLite.Test.PendulumTest
  parameter Real expectedAngle = -0.11127;
  parameter String p.name = \"Pendulum\";
  parameter Real p.m = 1.0;
  parameter Real p.I[1,1] = 1.0;
  parameter Real p.I[1,2] = 0.0;
  parameter Real p.I[1,3] = 0.0;
  parameter Real p.I[2,1] = 0.0;
  parameter Real p.I[2,2] = 1.0;
  parameter Real p.I[2,3] = 0.0;
  parameter Real p.I[3,1] = 0.0;
  parameter Real p.I[3,2] = 0.0;
  parameter Real p.I[3,3] = 1.0;
  parameter Real p.l = 1.0;
  parameter Real p.angle0 = 0.5235987755982988;
  parameter Real p.q0[1] = MbsLite.Util.Quaternions.QRot(p.angle0, {0.0, 0.0, 1.0})[1];
  parameter Real p.q0[2] = MbsLite.Util.Quaternions.QRot(p.angle0, {0.0, 0.0, 1.0})[2];
  parameter Real p.q0[3] = MbsLite.Util.Quaternions.QRot(p.angle0, {0.0, 0.0, 1.0})[3];
  parameter Real p.q0[4] = MbsLite.Util.Quaternions.QRot(p.angle0, {0.0, 0.0, 1.0})[4];
  parameter Real p.bodyAxisPositionLocal[1] = 0.0;
  parameter Real p.bodyAxisPositionLocal[2] = p.l;
  parameter Real p.bodyAxisPositionLocal[3] = 0.0;
  parameter Real p.bodyMassCenterGlobal[1] = (MbsLite.Util.Quaternions.QToT({p.q0[1], p.q0[2], p.q0[3], p.q0[4]}) * {-p.bodyAxisPositionLocal[1], -p.bodyAxisPositionLocal[2], -p.bodyAxisPositionLocal[3]})[1];
  parameter Real p.bodyMassCenterGlobal[2] = (MbsLite.Util.Quaternions.QToT({p.q0[1], p.q0[2], p.q0[3], p.q0[4]}) * {-p.bodyAxisPositionLocal[1], -p.bodyAxisPositionLocal[2], -p.bodyAxisPositionLocal[3]})[2];
  parameter Real p.bodyMassCenterGlobal[3] = (MbsLite.Util.Quaternions.QToT({p.q0[1], p.q0[2], p.q0[3], p.q0[4]}) * {-p.bodyAxisPositionLocal[1], -p.bodyAxisPositionLocal[2], -p.bodyAxisPositionLocal[3]})[3];
  parameter Real p.userwardNormalToTheScreen[1] = 0.0;
  parameter Real p.userwardNormalToTheScreen[2] = 0.0;
  parameter Real p.userwardNormalToTheScreen[3] = 1.0;
  Real p.F[1];
  Real p.F[2];
  Real p.F[3];
  Real p.M[1];
  Real p.M[2];
  Real p.M[3];
  Real p.base.OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.base.OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.base.OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.base.OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.base.OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.base.OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.base.OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.base.OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.base.OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.base.OutPort.T[1,1] \"Matrix of rotation\";
  Real p.base.OutPort.T[1,2] \"Matrix of rotation\";
  Real p.base.OutPort.T[1,3] \"Matrix of rotation\";
  Real p.base.OutPort.T[2,1] \"Matrix of rotation\";
  Real p.base.OutPort.T[2,2] \"Matrix of rotation\";
  Real p.base.OutPort.T[2,3] \"Matrix of rotation\";
  Real p.base.OutPort.T[3,1] \"Matrix of rotation\";
  Real p.base.OutPort.T[3,2] \"Matrix of rotation\";
  Real p.base.OutPort.T[3,3] \"Matrix of rotation\";
  Real p.base.OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.base.OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.base.OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.base.OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.base.OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.base.OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.body.OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.body.OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.body.OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.body.OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.body.OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.body.OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.body.OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.body.OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.body.OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.body.OutPort.T[1,1] \"Matrix of rotation\";
  Real p.body.OutPort.T[1,2] \"Matrix of rotation\";
  Real p.body.OutPort.T[1,3] \"Matrix of rotation\";
  Real p.body.OutPort.T[2,1] \"Matrix of rotation\";
  Real p.body.OutPort.T[2,2] \"Matrix of rotation\";
  Real p.body.OutPort.T[2,3] \"Matrix of rotation\";
  Real p.body.OutPort.T[3,1] \"Matrix of rotation\";
  Real p.body.OutPort.T[3,2] \"Matrix of rotation\";
  Real p.body.OutPort.T[3,3] \"Matrix of rotation\";
  Real p.body.OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.body.OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.body.OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.body.OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.body.OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.body.OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String p.body.name = p.name + \".body\";
  parameter Real p.body.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = p.m \"Mass of the body\";
  parameter Real p.body.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[1,1] \"Central tensor of inertia of the body\";
  parameter Real p.body.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[1,2] \"Central tensor of inertia of the body\";
  parameter Real p.body.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[1,3] \"Central tensor of inertia of the body\";
  parameter Real p.body.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[2,1] \"Central tensor of inertia of the body\";
  parameter Real p.body.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[2,2] \"Central tensor of inertia of the body\";
  parameter Real p.body.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[2,3] \"Central tensor of inertia of the body\";
  parameter Real p.body.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[3,1] \"Central tensor of inertia of the body\";
  parameter Real p.body.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[3,2] \"Central tensor of inertia of the body\";
  parameter Real p.body.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = p.I[3,3] \"Central tensor of inertia of the body\";
  Real p.body.r[1](quantity = \"Length\", unit = \"m\", start = p.bodyMassCenterGlobal[1]) \"Radius vector of masscenter in global coords\";
  Real p.body.r[2](quantity = \"Length\", unit = \"m\", start = p.bodyMassCenterGlobal[2]) \"Radius vector of masscenter in global coords\";
  Real p.body.r[3](quantity = \"Length\", unit = \"m\", start = p.bodyMassCenterGlobal[3]) \"Radius vector of masscenter in global coords\";
  Real p.body.v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real p.body.v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real p.body.v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real p.body.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.body.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.body.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.body.q[1](start = p.q0[1]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real p.body.q[2](start = p.q0[2]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real p.body.q[3](start = p.q0[3]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real p.body.q[4](start = p.q0[4]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real p.body.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real p.body.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real p.body.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real p.body.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.body.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.body.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.body.F[1](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real p.body.F[2](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real p.body.F[3](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real p.body.M[1](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real p.body.M[2](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real p.body.M[3](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real p.body.T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real p.body.Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer p.body.N = 1;
  parameter Real p.body.Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0;
  parameter Real p.body.Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real p.body.Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0;
  Real p.body.InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real p.body.InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real p.body.InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real p.body.InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real p.body.InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real p.body.InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real p.body.InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real p.body.InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real p.body.InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real p.body.crosses[1,1];
  Real p.body.crosses[1,2];
  Real p.body.crosses[1,3];
  parameter Integer p.joint.ConstraintNo = 1;
  Real p.joint.InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.joint.InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.joint.InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.joint.InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.joint.InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.joint.InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.joint.InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.joint.InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.joint.InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.joint.InPortA.T[1,1] \"Matrix of rotation\";
  Real p.joint.InPortA.T[1,2] \"Matrix of rotation\";
  Real p.joint.InPortA.T[1,3] \"Matrix of rotation\";
  Real p.joint.InPortA.T[2,1] \"Matrix of rotation\";
  Real p.joint.InPortA.T[2,2] \"Matrix of rotation\";
  Real p.joint.InPortA.T[2,3] \"Matrix of rotation\";
  Real p.joint.InPortA.T[3,1] \"Matrix of rotation\";
  Real p.joint.InPortA.T[3,2] \"Matrix of rotation\";
  Real p.joint.InPortA.T[3,3] \"Matrix of rotation\";
  Real p.joint.InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.joint.InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.joint.InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.joint.InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.joint.InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.joint.InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.joint.OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real p.joint.OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real p.joint.OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real p.joint.OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real p.joint.OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real p.joint.OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real p.joint.OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real p.joint.OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real p.joint.OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real p.joint.InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.joint.InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.joint.InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real p.joint.InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.joint.InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.joint.InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real p.joint.InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.joint.InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.joint.InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real p.joint.InPortB.T[1,1] \"Matrix of rotation\";
  Real p.joint.InPortB.T[1,2] \"Matrix of rotation\";
  Real p.joint.InPortB.T[1,3] \"Matrix of rotation\";
  Real p.joint.InPortB.T[2,1] \"Matrix of rotation\";
  Real p.joint.InPortB.T[2,2] \"Matrix of rotation\";
  Real p.joint.InPortB.T[2,3] \"Matrix of rotation\";
  Real p.joint.InPortB.T[3,1] \"Matrix of rotation\";
  Real p.joint.InPortB.T[3,2] \"Matrix of rotation\";
  Real p.joint.InPortB.T[3,3] \"Matrix of rotation\";
  Real p.joint.InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.joint.InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.joint.InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real p.joint.InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.joint.InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.joint.InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real p.joint.OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real p.joint.OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real p.joint.OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real p.joint.OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real p.joint.OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real p.joint.OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real p.joint.OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real p.joint.OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real p.joint.OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter Real p.joint.nA[1] = p.userwardNormalToTheScreen[1] \"Axis in body A local\";
  parameter Real p.joint.nA[2] = p.userwardNormalToTheScreen[2] \"Axis in body A local\";
  parameter Real p.joint.nA[3] = p.userwardNormalToTheScreen[3] \"Axis in body A local\";
  parameter Real p.joint.nB[1] = p.userwardNormalToTheScreen[1] \"Axis in body B local\";
  parameter Real p.joint.nB[2] = p.userwardNormalToTheScreen[2] \"Axis in body B local\";
  parameter Real p.joint.nB[3] = p.userwardNormalToTheScreen[3] \"Axis in body B local\";
  parameter Real p.joint.rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real p.joint.rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real p.joint.rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real p.joint.rB[1](quantity = \"Length\", unit = \"m\") = p.bodyAxisPositionLocal[1] \"Axis position in body B local\";
  parameter Real p.joint.rB[2](quantity = \"Length\", unit = \"m\") = p.bodyAxisPositionLocal[2] \"Axis position in body B local\";
  parameter Real p.joint.rB[3](quantity = \"Length\", unit = \"m\") = p.bodyAxisPositionLocal[3] \"Axis position in body B local\";
  Real p.joint.RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real p.joint.RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real p.joint.RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real p.joint.RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real p.joint.RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real p.joint.RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real p.joint.vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real p.joint.vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real p.joint.vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real p.joint.vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real p.joint.vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real p.joint.vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real p.joint.lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real p.joint.mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real p.joint.angle \"Relative angle. Beware numerical error accumulation!\";
  Real p.joint.epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real p.joint.epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real p.joint.epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real p.joint.nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real p.joint.nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real p.joint.nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real p.joint.nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real p.joint.nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real p.joint.nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real p.joint.M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
initial algorithm
  MbsLite.Util.Assert.AssertInitializedI(p.body.name, p.body.N, \"N\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.Gravity[1], p.body.Gravity[2], p.body.Gravity[3]}, \"Gravity\");
initial algorithm
  assert(MbsLite.Util.CompareReal(p.body.q[1] ^ 2.0 + p.body.q[2] ^ 2.0 + p.body.q[3] ^ 2.0 + p.body.q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(p.body.q[1] ^ 2.0 + p.body.q[2] ^ 2.0 + p.body.q[3] ^ 2.0 + p.body.q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({p.body.q[1], p.body.q[2], p.body.q[3], p.body.q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Assert.AssertInitializedS(p.body.name, p.body.name, \"name\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.m}, \"m\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.I[1,1], p.body.I[1,2], p.body.I[1,3]}, \"I[1, :]\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.I[2,1], p.body.I[2,2], p.body.I[2,3]}, \"I[2, :]\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.I[3,1], p.body.I[3,2], p.body.I[3,3]}, \"I[3, :]\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.r[1], p.body.r[2], p.body.r[3]}, \"r\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.v[1], p.body.v[2], p.body.v[3]}, \"v\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.q[1], p.body.q[2], p.body.q[3], p.body.q[4]}, \"q\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.omega[1], p.body.omega[2], p.body.omega[3]}, \"omega\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.F[1], p.body.F[2], p.body.F[3]}, \"F\");
  MbsLite.Util.Assert.AssertInitialized(p.body.name, {p.body.M[1], p.body.M[2], p.body.M[3]}, \"M\");
initial algorithm
  MbsLite.Util.Assert.AssertInitializedS(p.name, p.name, \"name\");
  MbsLite.Util.Assert.AssertInitialized(p.name, {p.m}, \"m\");
  MbsLite.Util.Assert.AssertInitialized(p.name, {p.I[1,1], p.I[1,2], p.I[1,3]}, \"I[1, :]\");
  MbsLite.Util.Assert.AssertInitialized(p.name, {p.I[2,1], p.I[2,2], p.I[2,3]}, \"I[2, :]\");
  MbsLite.Util.Assert.AssertInitialized(p.name, {p.I[3,1], p.I[3,2], p.I[3,3]}, \"I[3, :]\");
  MbsLite.Util.Assert.AssertInitialized(p.name, {p.l}, \"l\");
  MbsLite.Util.Assert.AssertInitialized(p.name, {p.angle0}, \"angle0\");
equation
  p.base.OutPort.r[1] = 0.0;
  p.base.OutPort.r[2] = 0.0;
  p.base.OutPort.r[3] = 0.0;
  p.base.OutPort.v[1] = 0.0;
  p.base.OutPort.v[2] = 0.0;
  p.base.OutPort.v[3] = 0.0;
  p.base.OutPort.a[1] = 0.0;
  p.base.OutPort.a[2] = 0.0;
  p.base.OutPort.a[3] = 0.0;
  p.base.OutPort.T[1,1] = 1.0;
  p.base.OutPort.T[1,2] = 0.0;
  p.base.OutPort.T[1,3] = 0.0;
  p.base.OutPort.T[2,1] = 0.0;
  p.base.OutPort.T[2,2] = 1.0;
  p.base.OutPort.T[2,3] = 0.0;
  p.base.OutPort.T[3,1] = 0.0;
  p.base.OutPort.T[3,2] = 0.0;
  p.base.OutPort.T[3,3] = 1.0;
  p.base.OutPort.omega[1] = 0.0;
  p.base.OutPort.omega[2] = 0.0;
  p.base.OutPort.omega[3] = 0.0;
  p.base.OutPort.epsilon[1] = 0.0;
  p.base.OutPort.epsilon[2] = 0.0;
  p.base.OutPort.epsilon[3] = 0.0;
  p.body.crosses[1,1] = (p.body.InPorts[1].P[2] - p.body.r[2]) * p.body.InPorts[1].F[3] - (p.body.InPorts[1].P[3] - p.body.r[3]) * p.body.InPorts[1].F[2];
  p.body.crosses[1,2] = (p.body.InPorts[1].P[3] - p.body.r[3]) * p.body.InPorts[1].F[1] - (p.body.InPorts[1].P[1] - p.body.r[1]) * p.body.InPorts[1].F[3];
  p.body.crosses[1,3] = (p.body.InPorts[1].P[1] - p.body.r[1]) * p.body.InPorts[1].F[2] - (p.body.InPorts[1].P[2] - p.body.r[2]) * p.body.InPorts[1].F[1];
  p.body.F[1] = p.body.Gravity[1] * p.body.m + p.body.InPorts[1].F[1];
  p.body.F[2] = p.body.Gravity[2] * p.body.m + p.body.InPorts[1].F[2];
  p.body.F[3] = p.body.Gravity[3] * p.body.m + p.body.InPorts[1].F[3];
  p.body.M[1] = p.body.InPorts[1].M[1] + p.body.crosses[1,1];
  p.body.M[2] = p.body.InPorts[1].M[2] + p.body.crosses[1,2];
  p.body.M[3] = p.body.InPorts[1].M[3] + p.body.crosses[1,3];
  der(p.body.Active) = 0.0;
  der(p.body.r[1]) = p.body.v[1] * p.body.Active;
  der(p.body.r[2]) = p.body.v[2] * p.body.Active;
  der(p.body.r[3]) = p.body.v[3] * p.body.Active;
  der(p.body.v[1]) = p.body.a[1] * p.body.Active;
  der(p.body.v[2]) = p.body.a[2] * p.body.Active;
  der(p.body.v[3]) = p.body.a[3] * p.body.Active;
  p.body.a[1] * p.body.m = p.body.F[1];
  p.body.a[2] * p.body.m = p.body.F[2];
  p.body.a[3] * p.body.m = p.body.F[3];
  {der(p.body.q[1]), der(p.body.q[2]), der(p.body.q[3]), der(p.body.q[4])} = MbsLite.Util.Quaternions.QMult({p.body.q[1], p.body.q[2], p.body.q[3], p.body.q[4]}, {0.0, p.body.omega[1], p.body.omega[2], p.body.omega[3]}) * 0.5 * p.body.Active;
  der(p.body.omega[1]) = p.body.epsilon[1] * p.body.Active;
  der(p.body.omega[2]) = p.body.epsilon[2] * p.body.Active;
  der(p.body.omega[3]) = p.body.epsilon[3] * p.body.Active;
  p.body.T = MbsLite.Util.Quaternions.QToT({p.body.q[1], p.body.q[2], p.body.q[3], p.body.q[4]});
  p.body.I[1,1] * p.body.epsilon[1] + p.body.I[1,2] * p.body.epsilon[2] + p.body.I[1,3] * p.body.epsilon[3] + p.body.omega[2] * (p.body.I[3,1] * p.body.omega[1] + p.body.I[3,2] * p.body.omega[2] + p.body.I[3,3] * p.body.omega[3]) - p.body.omega[3] * (p.body.I[2,1] * p.body.omega[1] + p.body.I[2,2] * p.body.omega[2] + p.body.I[2,3] * p.body.omega[3]) = p.body.T[1,1] * p.body.M[1] + p.body.T[2,1] * p.body.M[2] + p.body.T[3,1] * p.body.M[3];
  p.body.I[2,1] * p.body.epsilon[1] + p.body.I[2,2] * p.body.epsilon[2] + p.body.I[2,3] * p.body.epsilon[3] + p.body.omega[3] * (p.body.I[1,1] * p.body.omega[1] + p.body.I[1,2] * p.body.omega[2] + p.body.I[1,3] * p.body.omega[3]) - p.body.omega[1] * (p.body.I[3,1] * p.body.omega[1] + p.body.I[3,2] * p.body.omega[2] + p.body.I[3,3] * p.body.omega[3]) = p.body.T[1,2] * p.body.M[1] + p.body.T[2,2] * p.body.M[2] + p.body.T[3,2] * p.body.M[3];
  p.body.I[3,1] * p.body.epsilon[1] + p.body.I[3,2] * p.body.epsilon[2] + p.body.I[3,3] * p.body.epsilon[3] + p.body.omega[1] * (p.body.I[2,1] * p.body.omega[1] + p.body.I[2,2] * p.body.omega[2] + p.body.I[2,3] * p.body.omega[3]) - p.body.omega[2] * (p.body.I[1,1] * p.body.omega[1] + p.body.I[1,2] * p.body.omega[2] + p.body.I[1,3] * p.body.omega[3]) = p.body.T[1,3] * p.body.M[1] + p.body.T[2,3] * p.body.M[2] + p.body.T[3,3] * p.body.M[3];
  p.body.OutPort.r[1] = p.body.r[1];
  p.body.OutPort.r[2] = p.body.r[2];
  p.body.OutPort.r[3] = p.body.r[3];
  p.body.OutPort.v[1] = p.body.v[1];
  p.body.OutPort.v[2] = p.body.v[2];
  p.body.OutPort.v[3] = p.body.v[3];
  p.body.OutPort.a[1] = p.body.a[1];
  p.body.OutPort.a[2] = p.body.a[2];
  p.body.OutPort.a[3] = p.body.a[3];
  p.body.OutPort.T[1,1] = p.body.T[1,1];
  p.body.OutPort.T[1,2] = p.body.T[1,2];
  p.body.OutPort.T[1,3] = p.body.T[1,3];
  p.body.OutPort.T[2,1] = p.body.T[2,1];
  p.body.OutPort.T[2,2] = p.body.T[2,2];
  p.body.OutPort.T[2,3] = p.body.T[2,3];
  p.body.OutPort.T[3,1] = p.body.T[3,1];
  p.body.OutPort.T[3,2] = p.body.T[3,2];
  p.body.OutPort.T[3,3] = p.body.T[3,3];
  p.body.OutPort.omega[1] = p.body.T[1,1] * p.body.omega[1] + p.body.T[1,2] * p.body.omega[2] + p.body.T[1,3] * p.body.omega[3];
  p.body.OutPort.omega[2] = p.body.T[2,1] * p.body.omega[1] + p.body.T[2,2] * p.body.omega[2] + p.body.T[2,3] * p.body.omega[3];
  p.body.OutPort.omega[3] = p.body.T[3,1] * p.body.omega[1] + p.body.T[3,2] * p.body.omega[2] + p.body.T[3,3] * p.body.omega[3];
  p.body.OutPort.epsilon[1] = p.body.T[1,1] * p.body.epsilon[1] + p.body.T[1,2] * p.body.epsilon[2] + p.body.T[1,3] * p.body.epsilon[3];
  p.body.OutPort.epsilon[2] = p.body.T[2,1] * p.body.epsilon[1] + p.body.T[2,2] * p.body.epsilon[2] + p.body.T[2,3] * p.body.epsilon[3];
  p.body.OutPort.epsilon[3] = p.body.T[3,1] * p.body.epsilon[1] + p.body.T[3,2] * p.body.epsilon[2] + p.body.T[3,3] * p.body.epsilon[3];
  p.joint.RA[1] = p.joint.InPortA.r[1] + p.joint.InPortA.T[1,1] * p.joint.rA[1] + p.joint.InPortA.T[1,2] * p.joint.rA[2] + p.joint.InPortA.T[1,3] * p.joint.rA[3];
  p.joint.RA[2] = p.joint.InPortA.r[2] + p.joint.InPortA.T[2,1] * p.joint.rA[1] + p.joint.InPortA.T[2,2] * p.joint.rA[2] + p.joint.InPortA.T[2,3] * p.joint.rA[3];
  p.joint.RA[3] = p.joint.InPortA.r[3] + p.joint.InPortA.T[3,1] * p.joint.rA[1] + p.joint.InPortA.T[3,2] * p.joint.rA[2] + p.joint.InPortA.T[3,3] * p.joint.rA[3];
  p.joint.RB[1] = p.joint.InPortB.r[1] + p.joint.InPortB.T[1,1] * p.joint.rB[1] + p.joint.InPortB.T[1,2] * p.joint.rB[2] + p.joint.InPortB.T[1,3] * p.joint.rB[3];
  p.joint.RB[2] = p.joint.InPortB.r[2] + p.joint.InPortB.T[2,1] * p.joint.rB[1] + p.joint.InPortB.T[2,2] * p.joint.rB[2] + p.joint.InPortB.T[2,3] * p.joint.rB[3];
  p.joint.RB[3] = p.joint.InPortB.r[3] + p.joint.InPortB.T[3,1] * p.joint.rB[1] + p.joint.InPortB.T[3,2] * p.joint.rB[2] + p.joint.InPortB.T[3,3] * p.joint.rB[3];
  p.joint.RA[1] = p.joint.RB[1];
  p.joint.RA[2] = p.joint.RB[2];
  p.joint.RA[3] = p.joint.RB[3];
  p.joint.vA = MbsLite.Util.Euler({p.joint.InPortA.r[1], p.joint.InPortA.r[2], p.joint.InPortA.r[3]}, {p.joint.RA[1], p.joint.RA[2], p.joint.RA[3]}, {p.joint.InPortA.v[1], p.joint.InPortA.v[2], p.joint.InPortA.v[3]}, {p.joint.InPortA.omega[1], p.joint.InPortA.omega[2], p.joint.InPortA.omega[3]});
  p.joint.vB = MbsLite.Util.Euler({p.joint.InPortB.r[1], p.joint.InPortB.r[2], p.joint.InPortB.r[3]}, {p.joint.RB[1], p.joint.RB[2], p.joint.RB[3]}, {p.joint.InPortB.v[1], p.joint.InPortB.v[2], p.joint.InPortB.v[3]}, {p.joint.InPortB.omega[1], p.joint.InPortB.omega[2], p.joint.InPortB.omega[3]});
  p.joint.vA[1] = p.joint.vB[1];
  p.joint.vA[2] = p.joint.vB[2];
  p.joint.vA[3] = p.joint.vB[3];
  p.joint.nAi[1] = p.joint.InPortA.T[1,1] * p.joint.nA[1] + p.joint.InPortA.T[1,2] * p.joint.nA[2] + p.joint.InPortA.T[1,3] * p.joint.nA[3];
  p.joint.nAi[2] = p.joint.InPortA.T[2,1] * p.joint.nA[1] + p.joint.InPortA.T[2,2] * p.joint.nA[2] + p.joint.InPortA.T[2,3] * p.joint.nA[3];
  p.joint.nAi[3] = p.joint.InPortA.T[3,1] * p.joint.nA[1] + p.joint.InPortA.T[3,2] * p.joint.nA[2] + p.joint.InPortA.T[3,3] * p.joint.nA[3];
  p.joint.nBi[1] = p.joint.InPortB.T[1,1] * p.joint.nB[1] + p.joint.InPortB.T[1,2] * p.joint.nB[2] + p.joint.InPortB.T[1,3] * p.joint.nB[3];
  p.joint.nBi[2] = p.joint.InPortB.T[2,1] * p.joint.nB[1] + p.joint.InPortB.T[2,2] * p.joint.nB[2] + p.joint.InPortB.T[2,3] * p.joint.nB[3];
  p.joint.nBi[3] = p.joint.InPortB.T[3,1] * p.joint.nB[1] + p.joint.InPortB.T[3,2] * p.joint.nB[2] + p.joint.InPortB.T[3,3] * p.joint.nB[3];
  assert(MbsLite.Util.CompareReal(p.joint.nAi[1], p.joint.nBi[1], 1e-10, 1e-05), \"normals should be same, were: nAi = \" + MbsLite.Util.StringA({p.joint.nAi[1], p.joint.nAi[2], p.joint.nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({p.joint.nBi[1], p.joint.nBi[2], p.joint.nBi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(p.joint.nAi[2], p.joint.nBi[2], 1e-10, 1e-05), \"normals should be same, were: nAi = \" + MbsLite.Util.StringA({p.joint.nAi[1], p.joint.nAi[2], p.joint.nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({p.joint.nBi[1], p.joint.nBi[2], p.joint.nBi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(p.joint.nAi[3], p.joint.nBi[3], 1e-10, 1e-05), \"normals should be same, were: nAi = \" + MbsLite.Util.StringA({p.joint.nAi[1], p.joint.nAi[2], p.joint.nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({p.joint.nBi[1], p.joint.nBi[2], p.joint.nBi[3]}, \", \"));
  p.joint.epsilonr[1] = p.joint.InPortB.epsilon[1] - p.joint.InPortA.epsilon[1] - (p.joint.InPortA.omega[2] * p.joint.InPortB.omega[3] - p.joint.InPortA.omega[3] * p.joint.InPortB.omega[2]);
  p.joint.epsilonr[2] = p.joint.InPortB.epsilon[2] - p.joint.InPortA.epsilon[2] - (p.joint.InPortA.omega[3] * p.joint.InPortB.omega[1] - p.joint.InPortA.omega[1] * p.joint.InPortB.omega[3]);
  p.joint.epsilonr[3] = p.joint.InPortB.epsilon[3] - p.joint.InPortA.epsilon[3] - (p.joint.InPortA.omega[1] * p.joint.InPortB.omega[2] - p.joint.InPortA.omega[2] * p.joint.InPortB.omega[1]);
  p.joint.epsilonr[1] = p.joint.nAi[1] * p.joint.lambda;
  p.joint.epsilonr[2] = p.joint.nAi[2] * p.joint.lambda;
  p.joint.epsilonr[3] = p.joint.nAi[3] * p.joint.lambda;
  p.joint.M = p.joint.OutPortA.M[1] * p.joint.nAi[1] + p.joint.OutPortA.M[2] * p.joint.nAi[2] + p.joint.OutPortA.M[3] * p.joint.nAi[3];
  p.joint.M = 0.0;
  p.joint.OutPortA.P[1] = p.joint.RA[1];
  p.joint.OutPortA.P[2] = p.joint.RA[2];
  p.joint.OutPortA.P[3] = p.joint.RA[3];
  p.joint.OutPortB.P[1] = p.joint.RB[1];
  p.joint.OutPortB.P[2] = p.joint.RB[2];
  p.joint.OutPortB.P[3] = p.joint.RB[3];
  der(p.joint.mu) = p.joint.lambda;
  der(p.joint.angle) = p.joint.mu;
  p.joint.OutPortA.F[1] + p.joint.OutPortB.F[1] = 0.0;
  p.joint.OutPortA.F[2] + p.joint.OutPortB.F[2] = 0.0;
  p.joint.OutPortA.F[3] + p.joint.OutPortB.F[3] = 0.0;
  p.joint.OutPortA.M[1] + p.joint.OutPortB.M[1] = 0.0;
  p.joint.OutPortA.M[2] + p.joint.OutPortB.M[2] = 0.0;
  p.joint.OutPortA.M[3] + p.joint.OutPortB.M[3] = 0.0;
  p.joint.OutPortA.F[1] = p.F[1];
  p.joint.OutPortA.F[2] = p.F[2];
  p.joint.OutPortA.F[3] = p.F[3];
  p.joint.OutPortA.M[1] = p.M[1];
  p.joint.OutPortA.M[2] = p.M[2];
  p.joint.OutPortA.M[3] = p.M[3];
  assert(MbsLite.Util.CompareReal(1.0, Modelica.Math.Vectors.norm({p.body.r[1], p.body.r[2], p.body.r[3]}, 2.0), 1e-10, 1e-05), \"body should stay at distance of 1 from origin, was: \" + String(Modelica.Math.Vectors.norm({p.body.r[1], p.body.r[2], p.body.r[3]}, 2.0), 0, true, 6));
  assert(MbsLite.Util.CompareReal(0.0, Modelica.Math.Vectors.norm({p.joint.RA[1], p.joint.RA[2], p.joint.RA[3]}, 2.0), 1e-08, 1e-05), \"joint should be fixed at origin, was: \" + MbsLite.Util.StringA({p.joint.RA[1], p.joint.RA[2], p.joint.RA[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(0.0, Modelica.Math.Vectors.norm({p.joint.RB[1], p.joint.RB[2], p.joint.RB[3]}, 2.0), 1e-08, 1e-05), \"joint fixture point in body should coincide with origin, was: \" + MbsLite.Util.StringA({p.joint.RB[1], p.joint.RB[2], p.joint.RB[3]}, \", \"));
  when time == 10.0 then
    assert(MbsLite.Util.CompareReal(expectedAngle, p.joint.angle, 1e-10, 1e-05), \"angle should be \" + String(expectedAngle, 0, true, 6) + \", was: \" + String(p.joint.angle, 0, true, 6));
  end when;
  p.base.OutPort.T[1,1] = p.joint.InPortA.T[1,1];
  p.base.OutPort.T[1,2] = p.joint.InPortA.T[1,2];
  p.base.OutPort.T[1,3] = p.joint.InPortA.T[1,3];
  p.base.OutPort.T[2,1] = p.joint.InPortA.T[2,1];
  p.base.OutPort.T[2,2] = p.joint.InPortA.T[2,2];
  p.base.OutPort.T[2,3] = p.joint.InPortA.T[2,3];
  p.base.OutPort.T[3,1] = p.joint.InPortA.T[3,1];
  p.base.OutPort.T[3,2] = p.joint.InPortA.T[3,2];
  p.base.OutPort.T[3,3] = p.joint.InPortA.T[3,3];
  p.base.OutPort.a[1] = p.joint.InPortA.a[1];
  p.base.OutPort.a[2] = p.joint.InPortA.a[2];
  p.base.OutPort.a[3] = p.joint.InPortA.a[3];
  p.base.OutPort.epsilon[1] = p.joint.InPortA.epsilon[1];
  p.base.OutPort.epsilon[2] = p.joint.InPortA.epsilon[2];
  p.base.OutPort.epsilon[3] = p.joint.InPortA.epsilon[3];
  p.base.OutPort.omega[1] = p.joint.InPortA.omega[1];
  p.base.OutPort.omega[2] = p.joint.InPortA.omega[2];
  p.base.OutPort.omega[3] = p.joint.InPortA.omega[3];
  p.base.OutPort.r[1] = p.joint.InPortA.r[1];
  p.base.OutPort.r[2] = p.joint.InPortA.r[2];
  p.base.OutPort.r[3] = p.joint.InPortA.r[3];
  p.base.OutPort.v[1] = p.joint.InPortA.v[1];
  p.base.OutPort.v[2] = p.joint.InPortA.v[2];
  p.base.OutPort.v[3] = p.joint.InPortA.v[3];
  p.body.OutPort.T[1,1] = p.joint.InPortB.T[1,1];
  p.body.OutPort.T[1,2] = p.joint.InPortB.T[1,2];
  p.body.OutPort.T[1,3] = p.joint.InPortB.T[1,3];
  p.body.OutPort.T[2,1] = p.joint.InPortB.T[2,1];
  p.body.OutPort.T[2,2] = p.joint.InPortB.T[2,2];
  p.body.OutPort.T[2,3] = p.joint.InPortB.T[2,3];
  p.body.OutPort.T[3,1] = p.joint.InPortB.T[3,1];
  p.body.OutPort.T[3,2] = p.joint.InPortB.T[3,2];
  p.body.OutPort.T[3,3] = p.joint.InPortB.T[3,3];
  p.body.OutPort.a[1] = p.joint.InPortB.a[1];
  p.body.OutPort.a[2] = p.joint.InPortB.a[2];
  p.body.OutPort.a[3] = p.joint.InPortB.a[3];
  p.body.OutPort.epsilon[1] = p.joint.InPortB.epsilon[1];
  p.body.OutPort.epsilon[2] = p.joint.InPortB.epsilon[2];
  p.body.OutPort.epsilon[3] = p.joint.InPortB.epsilon[3];
  p.body.OutPort.omega[1] = p.joint.InPortB.omega[1];
  p.body.OutPort.omega[2] = p.joint.InPortB.omega[2];
  p.body.OutPort.omega[3] = p.joint.InPortB.omega[3];
  p.body.OutPort.r[1] = p.joint.InPortB.r[1];
  p.body.OutPort.r[2] = p.joint.InPortB.r[2];
  p.body.OutPort.r[3] = p.joint.InPortB.r[3];
  p.body.OutPort.v[1] = p.joint.InPortB.v[1];
  p.body.OutPort.v[2] = p.joint.InPortB.v[2];
  p.body.OutPort.v[3] = p.joint.InPortB.v[3];
  p.body.InPorts[1].F[1] = p.joint.OutPortB.F[1];
  p.body.InPorts[1].F[2] = p.joint.OutPortB.F[2];
  p.body.InPorts[1].F[3] = p.joint.OutPortB.F[3];
  p.body.InPorts[1].M[1] = p.joint.OutPortB.M[1];
  p.body.InPorts[1].M[2] = p.joint.OutPortB.M[2];
  p.body.InPorts[1].M[3] = p.joint.OutPortB.M[3];
  p.body.InPorts[1].P[1] = p.joint.OutPortB.P[1];
  p.body.InPorts[1].P[2] = p.joint.OutPortB.P[2];
  p.body.InPorts[1].P[3] = p.joint.OutPortB.P[3];
end MbsLite.Test.PendulumTest;
"
====================================
Checking MbsLite.Test.PendulumTest
"Check of MbsLite.Test.PendulumTest completed successfully.
Class MbsLite.Test.PendulumTest has 195 equation(s) and 192 variable(s).
127 of these are trivial equation(s)."
====================================
Simulating MbsLite.Test.PendulumTest
record SimulationResult
    resultFile = "",
    simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 100, tolerance = 1e-09, method = 'dassl', fileNamePrefix = 'MbsLite.Test.PendulumTest', options = '', outputFormat = 'csv', variableFilter = '.*', cflags = '', simflags = ''",
    messages = "Failed to build model: MbsLite.Test.PendulumTest",
    timeFrontend = 0.0,
    timeBackend = 0.0,
    timeSimCode = 0.0,
    timeTemplates = 0.0,
    timeCompile = 0.0,
    timeSimulation = 0.0,
    timeTotal = 0.0
end SimulationResult;
"[/home/vf/om/models/omni/thin/lib/MbsLite/KinematicPort.mo:3:1-12:18:writable] Warning: Connector .MbsLite.KinematicPort is not balanced: The number of potential variables (24) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/WrenchPort.mo:3:1-9:15:writable] Warning: Connector .MbsLite.WrenchPort is not balanced: The number of potential variables (9) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/KinematicPort.mo:3:1-12:18:writable] Warning: Connector .MbsLite.KinematicPort is not balanced: The number of potential variables (24) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/WrenchPort.mo:3:1-9:15:writable] Warning: Connector .MbsLite.WrenchPort is not balanced: The number of potential variables (9) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/KinematicPort.mo:3:1-12:18:writable] Warning: Connector .MbsLite.KinematicPort is not balanced: The number of potential variables (24) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/WrenchPort.mo:3:1-9:15:writable] Warning: Connector .MbsLite.WrenchPort is not balanced: The number of potential variables (9) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/Test/PendulumTest.mo:24:3-29:11:writable] Warning: In component <NO COMPONENT>, in relation time == 10.0,  ==  on Real numbers is only allowed inside functions.
Error: Too many equations, over-determined system. The model has 195 equation(s) and 192 variable(s).
"
