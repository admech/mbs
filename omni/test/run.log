====================================
cd to out
"/home/vf/om/models/omni/test/out"
====================================
Setting ModelicaPath
true
====================================
Loading Modelica
true
====================================
Loading MbsLite
true
====================================
Loading MbsLite.Test.Constraints.JointTest
true
====================================
Instantiating MbsLite.Test.Constraints.JointTest
"function MbsLite.Util.CompareReal
  input Real a;
  input Real b;
  input Real absTol = 1e-10 \"Absolute tolerance.\";
  input Real relTol = 1e-05 \"Relative tolerance.\";
  output Boolean equal;
  protected Real diff;
algorithm
  diff := abs(a - b);
  equal := diff < absTol or diff <= max(abs(b), abs(a)) * relTol;
end MbsLite.Util.CompareReal;

function MbsLite.Util.Euler \"Inline before index reduction\"
  input Real[3] origin;
  input Real[3] point;
  input Real[3] velocityOfOrigin;
  input Real[3] omega;
  output Real[3] velocityOfPoint;
algorithm
  velocityOfPoint := {velocityOfOrigin[1] + omega[2] * (point[3] - origin[3]) - omega[3] * (point[2] - origin[2]), velocityOfOrigin[2] + omega[3] * (point[1] - origin[1]) - omega[1] * (point[3] - origin[3]), velocityOfOrigin[3] + omega[1] * (point[2] - origin[2]) - omega[2] * (point[1] - origin[1])};
end MbsLite.Util.Euler;

function MbsLite.Util.Quaternions.QMult \"Inline before index reduction\"
  input Real[4] q1;
  input Real[4] q2;
  output Real[4] q3;
  protected Real a1;
  protected Real a2;
  protected Real[3] A1;
  protected Real[3] A2;
  protected Real[3] A3;
algorithm
  a1 := q1[1];
  a2 := q2[1];
  A1 := {q1[2], q1[3], q1[4]};
  A2 := {q2[2], q2[3], q2[4]};
  A3 := {A2[1] * a1 + A1[1] * a2 + A1[2] * A2[3] - A1[3] * A2[2], A2[2] * a1 + A1[2] * a2 + A1[3] * A2[1] - A1[1] * A2[3], A2[3] * a1 + A1[3] * a2 + A1[1] * A2[2] - A1[2] * A2[1]};
  q3 := {a1 * a2 + (-A1[2]) * A2[2] - A1[3] * A2[3] - A1[1] * A2[1], A3[1], A3[2], A3[3]};
end MbsLite.Util.Quaternions.QMult;

function MbsLite.Util.Quaternions.QRot \"Inline before index reduction\"
  input Real angle;
  input Real[3] axis;
  output Real[4] q;
  protected Real s;
algorithm
  s := sin(0.5 * angle);
  q := {cos(0.5 * angle), s * axis[1], s * axis[2], s * axis[3]};
end MbsLite.Util.Quaternions.QRot;

function MbsLite.Util.Quaternions.QToT \"Inline before index reduction\" \"Converts quaternion to Rotation matrix.\"
  input Real[4] q;
  output Real[3, 3] T;
algorithm
  T := {{(q[1] ^ 2.0 + q[2] ^ 2.0 + (-q[3] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[3] - q[1] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[4] + q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[1] * q[4] + q[2] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[3] ^ 2.0 + (-q[2] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[3] * q[4] - q[1] * q[2]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[2] * q[4] - q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[1] * q[2] + q[3] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[4] ^ 2.0 - q[3] ^ 2.0 - q[2] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}};
end MbsLite.Util.Quaternions.QToT;

function MbsLite.Util.StringA
  input Real[:] array;
  input String delim = \", \";
  output String render;
  protected String accumulator = \"\";
  protected Integer counter = 0;
algorithm
  for item in array loop
    accumulator := accumulator + String(item, 0, true, 6);
    counter := 1 + counter;
    if counter < size(array, 1) then
      accumulator := accumulator + delim;
    end if;
  end for;
  render := \"{ \" + accumulator + \" }\";
end MbsLite.Util.StringA;

class MbsLite.Test.Constraints.JointTest
  parameter Integer joint.ConstraintNo = 1;
  Real joint.InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real joint.InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real joint.InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real joint.InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real joint.InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real joint.InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real joint.InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real joint.InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real joint.InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real joint.InPortA.T[1,1] \"Matrix of rotation\";
  Real joint.InPortA.T[1,2] \"Matrix of rotation\";
  Real joint.InPortA.T[1,3] \"Matrix of rotation\";
  Real joint.InPortA.T[2,1] \"Matrix of rotation\";
  Real joint.InPortA.T[2,2] \"Matrix of rotation\";
  Real joint.InPortA.T[2,3] \"Matrix of rotation\";
  Real joint.InPortA.T[3,1] \"Matrix of rotation\";
  Real joint.InPortA.T[3,2] \"Matrix of rotation\";
  Real joint.InPortA.T[3,3] \"Matrix of rotation\";
  Real joint.InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real joint.InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real joint.InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real joint.InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real joint.InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real joint.InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real joint.OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real joint.OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real joint.OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real joint.OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real joint.OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real joint.OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real joint.OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real joint.OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real joint.OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real joint.InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real joint.InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real joint.InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real joint.InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real joint.InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real joint.InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real joint.InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real joint.InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real joint.InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real joint.InPortB.T[1,1] \"Matrix of rotation\";
  Real joint.InPortB.T[1,2] \"Matrix of rotation\";
  Real joint.InPortB.T[1,3] \"Matrix of rotation\";
  Real joint.InPortB.T[2,1] \"Matrix of rotation\";
  Real joint.InPortB.T[2,2] \"Matrix of rotation\";
  Real joint.InPortB.T[2,3] \"Matrix of rotation\";
  Real joint.InPortB.T[3,1] \"Matrix of rotation\";
  Real joint.InPortB.T[3,2] \"Matrix of rotation\";
  Real joint.InPortB.T[3,3] \"Matrix of rotation\";
  Real joint.InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real joint.InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real joint.InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real joint.InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real joint.InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real joint.InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real joint.OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real joint.OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real joint.OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real joint.OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real joint.OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real joint.OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real joint.OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real joint.OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real joint.OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String joint.name = \"joint\";
  parameter Real joint.nA[1] = 1.0 \"Axis in body A local\";
  parameter Real joint.nA[2] = 0.0 \"Axis in body A local\";
  parameter Real joint.nA[3] = 0.0 \"Axis in body A local\";
  parameter Real joint.nB[1] = 1.0 \"Axis in body B local\";
  parameter Real joint.nB[2] = 0.0 \"Axis in body B local\";
  parameter Real joint.nB[3] = 0.0 \"Axis in body B local\";
  parameter Real joint.rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real joint.rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real joint.rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real joint.rB[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body B local\";
  parameter Real joint.rB[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body B local\";
  parameter Real joint.rB[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body B local\";
  Real joint.RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real joint.RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real joint.RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real joint.RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real joint.RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real joint.RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real joint.vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real joint.vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real joint.vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real joint.vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real joint.vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real joint.vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real joint.lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real joint.mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real joint.angle \"Relative angle. Beware numerical error accumulation!\";
  Real joint.epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real joint.epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real joint.epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real joint.nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real joint.nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real joint.nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real joint.nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real joint.nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real joint.nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real joint.M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
  Real rA[1](start = 0.0);
  Real rA[2](start = 0.0);
  Real rA[3](start = 0.0);
  Real vA[1](start = 0.0);
  Real vA[2](start = 0.0);
  Real vA[3](start = 0.0);
  Real qA[1](start = 1.0);
  Real qA[2](start = 0.0);
  Real qA[3](start = 0.0);
  Real qA[4](start = 0.0);
  Real omegaA[1](start = 0.0);
  Real omegaA[2](start = 0.0);
  Real omegaA[3](start = 0.0);
  Real TA[1,1];
  Real TA[1,2];
  Real TA[1,3];
  Real TA[2,1];
  Real TA[2,2];
  Real TA[2,3];
  Real TA[3,1];
  Real TA[3,2];
  Real TA[3,3];
  Real FA[1];
  Real FA[2];
  Real FA[3];
  Real MA[1];
  Real MA[2];
  Real MA[3];
  Real aA[1];
  Real aA[2];
  Real aA[3];
  Real epsilonA[1];
  Real epsilonA[2];
  Real epsilonA[3];
  Real rB[1](start = 0.0);
  Real rB[2](start = 0.0);
  Real rB[3](start = 0.0);
  Real vB[1](start = 0.0);
  Real vB[2](start = 0.0);
  Real vB[3](start = 0.0);
  Real qB[1](start = 1.0);
  Real qB[2](start = 0.0);
  Real qB[3](start = 0.0);
  Real qB[4](start = 0.0);
  Real omegaB[1](start = 0.0);
  Real omegaB[2](start = 0.0);
  Real omegaB[3](start = 0.0);
  Real TB[1,1];
  Real TB[1,2];
  Real TB[1,3];
  Real TB[2,1];
  Real TB[2,2];
  Real TB[2,3];
  Real TB[3,1];
  Real TB[3,2];
  Real TB[3,3];
  Real FB[1];
  Real FB[2];
  Real FB[3];
  Real MB[1];
  Real MB[2];
  Real MB[3];
  Real aB[1];
  Real aB[2];
  Real aB[3];
  Real epsilonB[1];
  Real epsilonB[2];
  Real epsilonB[3];
equation
  joint.RA[1] = joint.InPortA.r[1];
  joint.RA[2] = joint.InPortA.r[2];
  joint.RA[3] = joint.InPortA.r[3];
  joint.RB[1] = joint.InPortB.r[1];
  joint.RB[2] = joint.InPortB.r[2];
  joint.RB[3] = joint.InPortB.r[3];
  joint.vA = MbsLite.Util.Euler({joint.InPortA.r[1], joint.InPortA.r[2], joint.InPortA.r[3]}, {joint.RA[1], joint.RA[2], joint.RA[3]}, {joint.InPortA.v[1], joint.InPortA.v[2], joint.InPortA.v[3]}, {joint.InPortA.omega[1], joint.InPortA.omega[2], joint.InPortA.omega[3]});
  joint.vB = MbsLite.Util.Euler({joint.InPortB.r[1], joint.InPortB.r[2], joint.InPortB.r[3]}, {joint.RB[1], joint.RB[2], joint.RB[3]}, {joint.InPortB.v[1], joint.InPortB.v[2], joint.InPortB.v[3]}, {joint.InPortB.omega[1], joint.InPortB.omega[2], joint.InPortB.omega[3]});
  joint.vA[1] = joint.vB[1];
  joint.vA[2] = joint.vB[2];
  joint.vA[3] = joint.vB[3];
  joint.nAi[1] = joint.InPortA.T[1,1];
  joint.nAi[2] = joint.InPortA.T[2,1];
  joint.nAi[3] = joint.InPortA.T[3,1];
  joint.nBi[1] = joint.InPortB.T[1,1];
  joint.nBi[2] = joint.InPortB.T[2,1];
  joint.nBi[3] = joint.InPortB.T[3,1];
  assert(MbsLite.Util.CompareReal(joint.nAi[1], joint.nBi[1], 1e-08, 1e-05), \"looks like joint joint is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({joint.nAi[1], joint.nAi[2], joint.nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({joint.nBi[1], joint.nBi[2], joint.nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({joint.nBi[1] - joint.nAi[1], joint.nBi[2] - joint.nAi[2], joint.nBi[3] - joint.nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(joint.nAi[2], joint.nBi[2], 1e-08, 1e-05), \"looks like joint joint is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({joint.nAi[1], joint.nAi[2], joint.nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({joint.nBi[1], joint.nBi[2], joint.nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({joint.nBi[1] - joint.nAi[1], joint.nBi[2] - joint.nAi[2], joint.nBi[3] - joint.nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(joint.nAi[3], joint.nBi[3], 1e-08, 1e-05), \"looks like joint joint is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({joint.nAi[1], joint.nAi[2], joint.nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({joint.nBi[1], joint.nBi[2], joint.nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({joint.nBi[1] - joint.nAi[1], joint.nBi[2] - joint.nAi[2], joint.nBi[3] - joint.nAi[3]}, \", \"));
  joint.epsilonr[1] = joint.InPortB.epsilon[1] - joint.InPortA.epsilon[1] - (joint.InPortA.omega[2] * joint.InPortB.omega[3] - joint.InPortA.omega[3] * joint.InPortB.omega[2]);
  joint.epsilonr[2] = joint.InPortB.epsilon[2] - joint.InPortA.epsilon[2] - (joint.InPortA.omega[3] * joint.InPortB.omega[1] - joint.InPortA.omega[1] * joint.InPortB.omega[3]);
  joint.epsilonr[3] = joint.InPortB.epsilon[3] - joint.InPortA.epsilon[3] - (joint.InPortA.omega[1] * joint.InPortB.omega[2] - joint.InPortA.omega[2] * joint.InPortB.omega[1]);
  joint.epsilonr[1] = joint.nAi[1] * joint.lambda;
  joint.epsilonr[2] = joint.nAi[2] * joint.lambda;
  joint.epsilonr[3] = joint.nAi[3] * joint.lambda;
  joint.M = joint.OutPortA.M[1] * joint.nAi[1] + joint.OutPortA.M[2] * joint.nAi[2] + joint.OutPortA.M[3] * joint.nAi[3];
  joint.M = 0.0;
  joint.OutPortA.P[1] = joint.RA[1];
  joint.OutPortA.P[2] = joint.RA[2];
  joint.OutPortA.P[3] = joint.RA[3];
  joint.OutPortB.P[1] = joint.RB[1];
  joint.OutPortB.P[2] = joint.RB[2];
  joint.OutPortB.P[3] = joint.RB[3];
  der(joint.mu) = joint.lambda;
  der(joint.angle) = joint.mu;
  joint.OutPortA.F[1] + joint.OutPortB.F[1] = 0.0;
  joint.OutPortA.F[2] + joint.OutPortB.F[2] = 0.0;
  joint.OutPortA.F[3] + joint.OutPortB.F[3] = 0.0;
  joint.OutPortA.M[1] + joint.OutPortB.M[1] = 0.0;
  joint.OutPortA.M[2] + joint.OutPortB.M[2] = 0.0;
  joint.OutPortA.M[3] + joint.OutPortB.M[3] = 0.0;
  TA = MbsLite.Util.Quaternions.QToT({qA[1], qA[2], qA[3], qA[4]});
  TB = MbsLite.Util.Quaternions.QToT({qB[1], qB[2], qB[3], qB[4]});
  der(rA[1]) = vA[1];
  der(rA[2]) = vA[2];
  der(rA[3]) = vA[3];
  der(vA[1]) = aA[1];
  der(vA[2]) = aA[2];
  der(vA[3]) = aA[3];
  aA[1] = FA[1];
  aA[2] = FA[2];
  aA[3] = FA[3];
  {der(qA[1]), der(qA[2]), der(qA[3]), der(qA[4])} = MbsLite.Util.Quaternions.QMult({qA[1], qA[2], qA[3], qA[4]}, {0.0, omegaA[1], omegaA[2], omegaA[3]}) * 0.5;
  der(omegaA[1]) = epsilonA[1];
  der(omegaA[2]) = epsilonA[2];
  der(omegaA[3]) = epsilonA[3];
  epsilonA[1] = TA[1,1] * MA[1] + TA[2,1] * MA[2] + TA[3,1] * MA[3];
  epsilonA[2] = TA[1,2] * MA[1] + TA[2,2] * MA[2] + TA[3,2] * MA[3];
  epsilonA[3] = TA[1,3] * MA[1] + TA[2,3] * MA[2] + TA[3,3] * MA[3];
  der(rB[1]) = vB[1];
  der(rB[2]) = vB[2];
  der(rB[3]) = vB[3];
  der(vB[1]) = aB[1];
  der(vB[2]) = aB[2];
  der(vB[3]) = aB[3];
  aB[1] = FB[1];
  aB[2] = FB[2];
  aB[3] = FB[3];
  {der(qB[1]), der(qB[2]), der(qB[3]), der(qB[4])} = MbsLite.Util.Quaternions.QMult({qB[1], qB[2], qB[3], qB[4]}, {0.0, omegaB[1], omegaB[2], omegaB[3]}) * 0.5;
  der(omegaB[1]) = epsilonB[1];
  der(omegaB[2]) = epsilonB[2];
  der(omegaB[3]) = epsilonB[3];
  epsilonB[1] = TB[1,1] * MB[1] + TB[2,1] * MB[2] + TB[3,1] * MB[3];
  epsilonB[2] = TB[1,2] * MB[1] + TB[2,2] * MB[2] + TB[3,2] * MB[3];
  epsilonB[3] = TB[1,3] * MB[1] + TB[2,3] * MB[2] + TB[3,3] * MB[3];
  joint.InPortA.r[1] = rA[1];
  joint.InPortA.r[2] = rA[2];
  joint.InPortA.r[3] = rA[3];
  joint.InPortA.v[1] = vA[1];
  joint.InPortA.v[2] = vA[2];
  joint.InPortA.v[3] = vA[3];
  joint.InPortA.a[1] = aA[1];
  joint.InPortA.a[2] = aA[2];
  joint.InPortA.a[3] = aA[3];
  joint.InPortA.T[1,1] = TA[1,1];
  joint.InPortA.T[1,2] = TA[1,2];
  joint.InPortA.T[1,3] = TA[1,3];
  joint.InPortA.T[2,1] = TA[2,1];
  joint.InPortA.T[2,2] = TA[2,2];
  joint.InPortA.T[2,3] = TA[2,3];
  joint.InPortA.T[3,1] = TA[3,1];
  joint.InPortA.T[3,2] = TA[3,2];
  joint.InPortA.T[3,3] = TA[3,3];
  joint.InPortA.omega[1] = omegaA[1];
  joint.InPortA.omega[2] = omegaA[2];
  joint.InPortA.omega[3] = omegaA[3];
  joint.InPortA.epsilon[1] = epsilonA[1];
  joint.InPortA.epsilon[2] = epsilonA[2];
  joint.InPortA.epsilon[3] = epsilonA[3];
  joint.InPortB.r[1] = rB[1];
  joint.InPortB.r[2] = rB[2];
  joint.InPortB.r[3] = rB[3];
  joint.InPortB.v[1] = vB[1];
  joint.InPortB.v[2] = vB[2];
  joint.InPortB.v[3] = vB[3];
  joint.InPortB.a[1] = aB[1];
  joint.InPortB.a[2] = aB[2];
  joint.InPortB.a[3] = aB[3];
  joint.InPortB.T[1,1] = TB[1,1];
  joint.InPortB.T[1,2] = TB[1,2];
  joint.InPortB.T[1,3] = TB[1,3];
  joint.InPortB.T[2,1] = TB[2,1];
  joint.InPortB.T[2,2] = TB[2,2];
  joint.InPortB.T[2,3] = TB[2,3];
  joint.InPortB.T[3,1] = TB[3,1];
  joint.InPortB.T[3,2] = TB[3,2];
  joint.InPortB.T[3,3] = TB[3,3];
  joint.InPortB.omega[1] = omegaB[1];
  joint.InPortB.omega[2] = omegaB[2];
  joint.InPortB.omega[3] = omegaB[3];
  joint.InPortB.epsilon[1] = epsilonB[1];
  joint.InPortB.epsilon[2] = epsilonB[2];
  joint.InPortB.epsilon[3] = epsilonB[3];
  rA[1] = joint.OutPortA.P[1];
  rA[2] = joint.OutPortA.P[2];
  rA[3] = joint.OutPortA.P[3];
  FA[1] = joint.OutPortA.F[1];
  FA[2] = joint.OutPortA.F[2];
  FA[3] = joint.OutPortA.F[3];
  MA[1] = joint.OutPortA.M[1];
  MA[2] = joint.OutPortA.M[2];
  MA[3] = joint.OutPortA.M[3];
  rB[1] = joint.OutPortB.P[1];
  rB[2] = joint.OutPortB.P[2];
  rB[3] = joint.OutPortB.P[3];
  FB[1] = joint.OutPortB.F[1];
  FB[2] = joint.OutPortB.F[2];
  FB[3] = joint.OutPortB.F[3];
  MB[1] = joint.OutPortB.M[1];
  MB[2] = joint.OutPortB.M[2];
  MB[3] = joint.OutPortB.M[3];
  when initial() then
    terminate(\"passed\");
  end when;
  when time > 0.0 then
    assert(false, \"should have terminated after checking the solution to the initial problem\");
  end when;
end MbsLite.Test.Constraints.JointTest;
"
====================================
Checking MbsLite.Test.Constraints.JointTest
"Check of MbsLite.Test.Constraints.JointTest completed successfully.
Class MbsLite.Test.Constraints.JointTest has 165 equation(s) and 159 variable(s).
120 of these are trivial equation(s)."
====================================
Simulating MbsLite.Test.Constraints.JointTest
record SimulationResult
    resultFile = "",
    simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 100, tolerance = 1e-09, method = 'dassl', fileNamePrefix = 'MbsLite.Test.Constraints.JointTest', options = '', outputFormat = 'csv', variableFilter = '.*', cflags = '', simflags = ''",
    messages = "Failed to build model: MbsLite.Test.Constraints.JointTest",
    timeFrontend = 0.0,
    timeBackend = 0.0,
    timeSimCode = 0.0,
    timeTemplates = 0.0,
    timeCompile = 0.0,
    timeSimulation = 0.0,
    timeTotal = 0.0
end SimulationResult;
"[/home/vf/om/models/omni/thin/lib/MbsLite/KinematicPort.mo:3:1-12:18:writable] Warning: Connector .MbsLite.KinematicPort is not balanced: The number of potential variables (24) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/WrenchPort.mo:3:1-9:15:writable] Warning: Connector .MbsLite.WrenchPort is not balanced: The number of potential variables (9) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/KinematicPort.mo:3:1-12:18:writable] Warning: Connector .MbsLite.KinematicPort is not balanced: The number of potential variables (24) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/WrenchPort.mo:3:1-9:15:writable] Warning: Connector .MbsLite.WrenchPort is not balanced: The number of potential variables (9) is not equal to the number of flow variables (0).
Error: Too many equations, over-determined system. The model has 165 equation(s) and 159 variable(s).
"
