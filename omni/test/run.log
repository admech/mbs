====================================
cd to out
"/home/vf/om/models/omni/test/out"
====================================
Setting ModelicaPath
true
====================================
Loading Modelica
true
====================================
Loading MbsLite
true
====================================
Loading MbsLite.Test.Constraints.ContactTest
true
====================================
Instantiating MbsLite.Test.Constraints.ContactTest
"function MbsLite.Util.Assert.Assert
  input Boolean condition;
  input String message;
  input Boolean silent = false;
algorithm
  if not condition then
    assert(false, message);
    Modelica.Utilities.System.exit(-1);
  else
    if not silent then
      Modelica.Utilities.Streams.print(\"Assertion passed: \" + message, \"\");
    end if;
  end if;
end MbsLite.Util.Assert.Assert;

function MbsLite.Util.Assert.AssertInitialized
  input String modelName;
  input Real[:] value;
  input String parameterName;
algorithm
  assert(max(value) < 9.999999999999999e+59, modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitialized;

function MbsLite.Util.Assert.AssertInitializedI
  input String modelName;
  input Integer value;
  input String parameterName;
algorithm
  assert(value > -4611686018427387903, modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitializedI;

function MbsLite.Util.Assert.AssertInitializedS
  input String modelName;
  input String value;
  input String parameterName;
algorithm
  assert(value <> \"NOT INITIALIZED\", modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitializedS;

function MbsLite.Util.Assert.AssertReal
  input Real expected;
  input Real actual;
  input String name;
  input Boolean silent = false;
algorithm
  MbsLite.Util.Assert.Assert(MbsLite.Util.CompareReal(expected, actual, 1e-10, 1e-05), name + \" should be: \" + String(expected, 0, true, 6) + \", but was: \" + String(actual, 0, true, 6), silent);
end MbsLite.Util.Assert.AssertReal;

function MbsLite.Util.Assert.AssertReals
  input Real[:] expected;
  input Real[:] actual;
  input String name;
  protected Boolean passed = true;
  protected String message = name + \" should be: \" + MbsLite.Util.StringA(expected, \", \") + \", but was: \" + MbsLite.Util.StringA(actual, \", \");
algorithm
  MbsLite.Util.Assert.AssertReal(/*Real*/(size(expected, 1)), /*Real*/(size(actual, 1)), \"sizes of expected and actual\", true);
  for i in 1:size(actual, 1) loop
    passed := passed and MbsLite.Util.CompareReal(expected[i], actual[i], 1e-10, 1e-05);
    MbsLite.Util.Assert.Assert(passed, message, true);
  end for;
  if passed then
    Modelica.Utilities.Streams.print(\"Assertion passed: \" + message, \"\");
  end if;
end MbsLite.Util.Assert.AssertReals;

function MbsLite.Util.CompareReal
  input Real a;
  input Real b;
  input Real absTol = 1e-10 \"Absolute tolerance.\";
  input Real relTol = 1e-05 \"Relative tolerance.\";
  output Boolean equal;
  protected Real diff;
algorithm
  diff := abs(a - b);
  equal := diff < absTol or diff <= max(abs(b), abs(a)) * relTol;
end MbsLite.Util.CompareReal;

function MbsLite.Util.Euler \"Inline before index reduction\"
  input Real[3] origin;
  input Real[3] point;
  input Real[3] velocityOfOrigin;
  input Real[3] omega;
  output Real[3] velocityOfPoint;
algorithm
  velocityOfPoint := {velocityOfOrigin[1] + omega[2] * (point[3] - origin[3]) - omega[3] * (point[2] - origin[2]), velocityOfOrigin[2] + omega[3] * (point[1] - origin[1]) - omega[1] * (point[3] - origin[3]), velocityOfOrigin[3] + omega[1] * (point[2] - origin[2]) - omega[2] * (point[1] - origin[1])};
end MbsLite.Util.Euler;

function MbsLite.Util.Quaternions.QMult \"Inline before index reduction\"
  input Real[4] q1;
  input Real[4] q2;
  output Real[4] q3;
  protected Real a1;
  protected Real a2;
  protected Real[3] A1;
  protected Real[3] A2;
  protected Real[3] A3;
algorithm
  a1 := q1[1];
  a2 := q2[1];
  A1 := {q1[2], q1[3], q1[4]};
  A2 := {q2[2], q2[3], q2[4]};
  A3 := {A2[1] * a1 + A1[1] * a2 + A1[2] * A2[3] - A1[3] * A2[2], A2[2] * a1 + A1[2] * a2 + A1[3] * A2[1] - A1[1] * A2[3], A2[3] * a1 + A1[3] * a2 + A1[1] * A2[2] - A1[2] * A2[1]};
  q3 := {a1 * a2 + (-A1[2]) * A2[2] - A1[3] * A2[3] - A1[1] * A2[1], A3[1], A3[2], A3[3]};
end MbsLite.Util.Quaternions.QMult;

function MbsLite.Util.Quaternions.QRot \"Inline before index reduction\"
  input Real angle;
  input Real[3] axis;
  output Real[4] q;
  protected Real s;
algorithm
  s := sin(0.5 * angle);
  q := {cos(0.5 * angle), s * axis[1], s * axis[2], s * axis[3]};
end MbsLite.Util.Quaternions.QRot;

function MbsLite.Util.Quaternions.QToT \"Inline before index reduction\" \"Converts quaternion to Rotation matrix.\"
  input Real[4] q;
  output Real[3, 3] T;
algorithm
  T := {{(q[1] ^ 2.0 + q[2] ^ 2.0 + (-q[3] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[3] - q[1] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[4] + q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[1] * q[4] + q[2] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[3] ^ 2.0 + (-q[2] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[3] * q[4] - q[1] * q[2]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[2] * q[4] - q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[1] * q[2] + q[3] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[4] ^ 2.0 - q[3] ^ 2.0 - q[2] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}};
end MbsLite.Util.Quaternions.QToT;

function MbsLite.Util.StringA
  input Real[:] array;
  input String delim = \", \";
  output String render;
  protected String accumulator = \"\";
  protected Integer counter = 0;
algorithm
  for item in array loop
    accumulator := accumulator + String(item, 0, true, 6);
    counter := 1 + counter;
    if counter < size(array, 1) then
      accumulator := accumulator + delim;
    end if;
  end for;
  render := \"{ \" + accumulator + \" }\";
end MbsLite.Util.StringA;

function Modelica.Math.Vectors.length \"Inline before index reduction\" \"Return length of a vector (better as norm(), if further symbolic processing is performed)\"
  input Real[:] v \"Real vector\";
  output Real result \"Length of vector v\";
algorithm
  result := sqrt(v * v);
end Modelica.Math.Vectors.length;

function Modelica.Math.Vectors.norm \"Return the p-norm of a vector\"
  input Real[:] v \"Real vector\";
  input Real p(min = 1.0) = 2.0 \"Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)\";
  output Real result = 0.0 \"p-norm of vector v\";
  protected Real eps = 1e-14;
algorithm
  if size(v, 1) > 0 then
    if p >= 2.0 - eps and p <= 2.0 + eps then
      result := sqrt(v * v);
    elseif p >= 9.999999999999999e+59 then
      result := max(array(abs($tmpVar0) for $tmpVar0 in v));
    elseif p >= 1.0 - eps and p <= 1.0 + eps then
      result := sum(array(abs($tmpVar3) for $tmpVar3 in v));
    elseif p >= 1.0 then
      result := sum(abs(v[i]) ^ p for i in 1:size(v, 1)) ^ (1.0 / p);
    else
      assert(false, \"Optional argument \\\"p\\\" (= \" + String(p, 0, true, 6) + \") of function \\\"norm\\\" >= 1 required\");
    end if;
  end if;
end Modelica.Math.Vectors.norm;

function Modelica.Math.Vectors.normalize \"Inline before index reduction\" \"Return normalized vector such that length = 1 and prevent zero-division for zero vector\"
  input Real[:] v \"Real vector\";
  input Real eps(min = 0.0) = 1e-13 \"if |v| < eps then result = v/eps\";
  output Real[size(v, 1)] result \"Input vector v normalized to length=1\";
algorithm
  result := smooth(0, if Modelica.Math.Vectors.length(v) >= eps then v / Modelica.Math.Vectors.length(v) else v / eps);
end Modelica.Math.Vectors.normalize;

function Modelica.Utilities.Streams.print \"Print string to terminal or file\"
  input String string = \"\" \"String to be printed\";
  input String fileName = \"\" \"File where to print (empty string is the terminal)\";

  external \"C\" ModelicaInternal_print(string, fileName);
end Modelica.Utilities.Streams.print;

function Modelica.Utilities.System.exit \"Terminate execution of Modelica environment\"
  input Integer status = 0 \"Result to be returned by environment (0 means success)\";

  external \"C\" exit(status);
end Modelica.Utilities.System.exit;

class MbsLite.Test.Constraints.ContactTest
  constant Real forward[1] = 1.0;
  constant Real forward[2] = 0.0;
  constant Real forward[3] = 0.0;
  constant Real vertical[1] = 0.0;
  constant Real vertical[2] = 1.0;
  constant Real vertical[3] = 0.0;
  constant Real userward[1] = 0.0;
  constant Real userward[2] = 0.0;
  constant Real userward[3] = 1.0;
  parameter Integer n = 5;
  parameter Integer nOne = 5;
  parameter Real psi = 0.0;
  parameter Real wheelHubMass = 0.15;
  parameter Real rollerMass = 0.05;
  parameter Real R = 0.05 \"'wheel radius' := distance from wheel axis to the floor\";
  parameter Real halfRollerAngle = 0.6283185307179586;
  parameter Real wheelHubRadius = 0.04045084971874738;
  parameter Real rollerRadius = 0.009549150281252625;
  parameter Real rollerLength = 0.05877852522924731;
  parameter Real rollerRadiusForMoi = 0.004774575140626312;
  parameter Real wheelR[1] = 0.0;
  parameter Real wheelR[2] = 0.05;
  parameter Real wheelR[3] = 0.0;
  parameter Real rollerAxialMoi = 5.699141943371693e-07;
  parameter Real rollerOrthogonalMoi = 1.468043638102385e-05;
  parameter Real omega0 = 1.0;
  parameter Real v0 = 0.009549150281252625;
  parameter Real omega0vec[1] = 0.0;
  parameter Real omega0vec[2] = 0.0;
  parameter Real omega0vec[3] = -1.0;
  parameter Real r0[1] = 0.0;
  parameter Real r0[2] = 0.009549150281252625;
  parameter Real r0[3] = 0.0;
  parameter Real v0vec[1] = 0.009549150281252625;
  parameter Real v0vec[2] = 0.0;
  parameter Real v0vec[3] = 0.0;
  Real roller.OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real roller.OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real roller.OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real roller.OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real roller.OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real roller.OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real roller.OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real roller.OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real roller.OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real roller.OutPort.T[1,1] \"Matrix of rotation\";
  Real roller.OutPort.T[1,2] \"Matrix of rotation\";
  Real roller.OutPort.T[1,3] \"Matrix of rotation\";
  Real roller.OutPort.T[2,1] \"Matrix of rotation\";
  Real roller.OutPort.T[2,2] \"Matrix of rotation\";
  Real roller.OutPort.T[2,3] \"Matrix of rotation\";
  Real roller.OutPort.T[3,1] \"Matrix of rotation\";
  Real roller.OutPort.T[3,2] \"Matrix of rotation\";
  Real roller.OutPort.T[3,3] \"Matrix of rotation\";
  Real roller.OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real roller.OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real roller.OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real roller.OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real roller.OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real roller.OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String roller.name = \"roller\";
  parameter Real roller.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.05 \"Mass of the body\";
  parameter Real roller.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 5.699141943371693e-07 \"Central tensor of inertia of the body\";
  parameter Real roller.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real roller.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real roller.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real roller.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 1.468043638102385e-05 \"Central tensor of inertia of the body\";
  parameter Real roller.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real roller.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real roller.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real roller.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 1.468043638102385e-05 \"Central tensor of inertia of the body\";
  Real roller.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) \"Radius vector of masscenter in global coords\";
  Real roller.r[2](quantity = \"Length\", unit = \"m\", start = 0.009549150281252625) \"Radius vector of masscenter in global coords\";
  Real roller.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) \"Radius vector of masscenter in global coords\";
  Real roller.v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.009549150281252625) \"Velocity vector of masscenter\";
  Real roller.v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real roller.v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real roller.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real roller.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real roller.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real roller.q[1](start = 1.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real roller.q[2](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real roller.q[3](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real roller.q[4](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real roller.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real roller.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real roller.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = -1.0) \"Vector of angular rate in local coords\";
  Real roller.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real roller.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real roller.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real roller.F[1](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real roller.F[2](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real roller.F[3](quantity = \"Force\", unit = \"N\") \"Sum of all forces applied\";
  Real roller.M[1](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real roller.M[2](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real roller.M[3](quantity = \"Torque\", unit = \"N.m\") \"Sum of all torques applied\";
  Real roller.T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real roller.Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer roller.N = 1;
  parameter Real roller.Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  parameter Real roller.Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real roller.Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = -0.0;
  Real roller.InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real roller.InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real roller.InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real roller.InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real roller.InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real roller.InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real roller.InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real roller.InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real roller.InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real roller.crosses[1,1];
  Real roller.crosses[1,2];
  Real roller.crosses[1,3];
  parameter Integer contact.ConstraintNo = 1;
  Real contact.InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real contact.InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real contact.InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real contact.InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real contact.InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real contact.InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real contact.InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real contact.InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real contact.InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real contact.InPortA.T[1,1] \"Matrix of rotation\";
  Real contact.InPortA.T[1,2] \"Matrix of rotation\";
  Real contact.InPortA.T[1,3] \"Matrix of rotation\";
  Real contact.InPortA.T[2,1] \"Matrix of rotation\";
  Real contact.InPortA.T[2,2] \"Matrix of rotation\";
  Real contact.InPortA.T[2,3] \"Matrix of rotation\";
  Real contact.InPortA.T[3,1] \"Matrix of rotation\";
  Real contact.InPortA.T[3,2] \"Matrix of rotation\";
  Real contact.InPortA.T[3,3] \"Matrix of rotation\";
  Real contact.InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real contact.InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real contact.InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real contact.InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real contact.InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real contact.InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real contact.OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real contact.OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real contact.OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real contact.OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real contact.OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real contact.OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real contact.OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real contact.OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real contact.OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real contact.InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real contact.InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real contact.InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real contact.InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real contact.InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real contact.InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real contact.InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real contact.InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real contact.InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real contact.InPortB.T[1,1] \"Matrix of rotation\";
  Real contact.InPortB.T[1,2] \"Matrix of rotation\";
  Real contact.InPortB.T[1,3] \"Matrix of rotation\";
  Real contact.InPortB.T[2,1] \"Matrix of rotation\";
  Real contact.InPortB.T[2,2] \"Matrix of rotation\";
  Real contact.InPortB.T[2,3] \"Matrix of rotation\";
  Real contact.InPortB.T[3,1] \"Matrix of rotation\";
  Real contact.InPortB.T[3,2] \"Matrix of rotation\";
  Real contact.InPortB.T[3,3] \"Matrix of rotation\";
  Real contact.InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real contact.InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real contact.InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real contact.InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real contact.InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real contact.InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real contact.OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real contact.OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real contact.OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real contact.OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real contact.OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real contact.OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real contact.OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real contact.OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real contact.OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String contact.name = \"contact\";
  parameter Integer contact.n = 5 \"Number of rollers\";
  parameter Real contact.R = 0.05 \"Omni wheel outer radius (ellipse small axis)\";
  parameter Real contact.psi = 0.0 \"Angle of roller distortion (fixed axis turn)\";
  parameter Real contact.alpha = 0.6283185307179586 \"Max angle of the half-sector\";
  parameter Real contact.Q = 0.05 \"Ellipse large axis\";
  parameter Real contact.R1 = 0.04045084971874738 \"Omni wheel inner radius\";
  parameter Real contact.L1 = 0.02938926261462366 \"Half roller visible (projection) length\";
  parameter Real contact.L2 = 0.02938926261462366 \"Half roller length\";
  parameter Real contact.nA[1] = 0.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real contact.nA[2] = 1.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real contact.nA[3] = 0.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real contact.gradAtRollerTip[1] = 23.51141009169892;
  parameter Real contact.gradAtRollerTip[2] = 32.3606797749979;
  parameter Real contact.n_at_max[1] = 0.587785252292473 \"Normal to ellipse in local coord (it is in vert plane)\";
  parameter Real contact.n_at_max[2] = 0.8090169943749475 \"Normal to ellipse in local coord (it is in vert plane)\";
  parameter Real contact.i[1] = 1.0 \"Roller axis of symmetry unit vector\";
  parameter Real contact.i[2] = 0.0 \"Roller axis of symmetry unit vector\";
  parameter Real contact.i[3] = 0.0 \"Roller axis of symmetry unit vector\";
  parameter Real contact.cos_of_max = 0.8090169943749475;
  Real contact.rA[1](quantity = \"Length\", unit = \"m\");
  Real contact.rA[2](quantity = \"Length\", unit = \"m\");
  Real contact.rA[3](quantity = \"Length\", unit = \"m\");
  Real contact.rB[1](quantity = \"Length\", unit = \"m\");
  Real contact.rB[2](quantity = \"Length\", unit = \"m\");
  Real contact.rB[3](quantity = \"Length\", unit = \"m\");
  Real contact.ni[1] \"Roller axis in global coords\";
  Real contact.ni[2] \"Roller axis in global coords\";
  Real contact.ni[3] \"Roller axis in global coords\";
  Real contact.crs[1] \"horizontal ni cross vertical\";
  Real contact.crs[2] \"horizontal ni cross vertical\";
  Real contact.crs[3] \"horizontal ni cross vertical\";
  Real contact.nk[1] \"Horizontal (along crs)\";
  Real contact.nk[2] \"Horizontal (along crs)\";
  Real contact.nk[3] \"Horizontal (along crs)\";
  Real contact.n1j[1] \"In vertical direction (= nA)\";
  Real contact.n1j[2] \"In vertical direction (= nA)\";
  Real contact.n1j[3] \"In vertical direction (= nA)\";
  Real contact.n1k[1] \"Horizontal wheel axis, delivered from above\";
  Real contact.n1k[2] \"Horizontal wheel axis, delivered from above\";
  Real contact.n1k[3] \"Horizontal wheel axis, delivered from above\";
  Real contact.lambda \"Parameter to be computed\";
  Real contact.rho[1] \"Unit vector between mass centers\";
  Real contact.rho[2] \"Unit vector between mass centers\";
  Real contact.rho[3] \"Unit vector between mass centers\";
  Real contact.OBPB[1];
  Real contact.OBPB[2];
  Real contact.OBPB[3];
  Real contact.j;
  Real contact.cosBtwAxisAndVert;
  Real contact.vA[1];
  Real contact.vA[2];
  Real contact.vA[3];
  Real contact.vB[1];
  Real contact.vB[2];
  Real contact.vB[3];
  Real contact.relv[1];
  Real contact.relv[2];
  Real contact.relv[3];
  Real contact.relvn;
  Real contact.vAn;
  Real contact.vBn;
  Real contact.vAt[1];
  Real contact.vAt[2];
  Real contact.vAt[3];
  Real contact.vBt[1];
  Real contact.vBt[2];
  Real contact.vBt[3];
  Real contact.relvt[1];
  Real contact.relvt[2];
  Real contact.relvt[3];
  Real contact.relvtsqrt;
  parameter Real contact.delta = 1e-06;
  parameter Real contact.fric = 0.1;
  Real contact.mu;
  Real contact.Forcet[1];
  Real contact.Forcet[2];
  Real contact.Forcet[3];
  Real contact.Drelvn;
  Real contact.Forcen;
  Real contact.isInContact;
  Real base.OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real base.OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real base.OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real base.OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real base.OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real base.OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real base.OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real base.OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real base.OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real base.OutPort.T[1,1] \"Matrix of rotation\";
  Real base.OutPort.T[1,2] \"Matrix of rotation\";
  Real base.OutPort.T[1,3] \"Matrix of rotation\";
  Real base.OutPort.T[2,1] \"Matrix of rotation\";
  Real base.OutPort.T[2,2] \"Matrix of rotation\";
  Real base.OutPort.T[2,3] \"Matrix of rotation\";
  Real base.OutPort.T[3,1] \"Matrix of rotation\";
  Real base.OutPort.T[3,2] \"Matrix of rotation\";
  Real base.OutPort.T[3,3] \"Matrix of rotation\";
  Real base.OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real base.OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real base.OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real base.OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real base.OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real base.OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  constant Real expectedForcen = 0.05;
  constant Real expectedFport[1] = 0.0;
  constant Real expectedFport[2] = 0.05;
  constant Real expectedFport[3] = 0.0;
  constant Real expectedF[1] = 0.0;
  constant Real expectedF[2] = 0.0;
  constant Real expectedF[3] = 0.0;
  constant Real expectedM[1] = 0.0;
  constant Real expectedM[2] = 0.0;
  constant Real expectedM[3] = 0.0;
  constant Real expectedContactPoint[1] = 0.0;
  constant Real expectedContactPoint[2] = 0.0;
  constant Real expectedContactPoint[3] = 0.0;
  constant Real expectedContactPointVelocity[1] = 0.0;
  constant Real expectedContactPointVelocity[2] = 0.0;
  constant Real expectedContactPointVelocity[3] = 0.0;
initial equation
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  if not MbsLite.Util.CompareReal(0.05, contact.Forcen, 1e-10, 1e-05) then
    UNKNOWN EQUATION TYPE
  else
    UNKNOWN EQUATION TYPE
  end if;
  UNKNOWN EQUATION TYPE
  UNKNOWN EQUATION TYPE
  terminate(\"passed\");
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(roller.q[1] ^ 2.0 + roller.q[2] ^ 2.0 + roller.q[3] ^ 2.0 + roller.q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(roller.q[1] ^ 2.0 + roller.q[2] ^ 2.0 + roller.q[3] ^ 2.0 + roller.q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({roller.q[1], roller.q[2], roller.q[3], roller.q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Assert.AssertInitialized(\"roller\", {roller.r[1], roller.r[2], roller.r[3]}, \"r\");
  MbsLite.Util.Assert.AssertInitialized(\"roller\", {roller.v[1], roller.v[2], roller.v[3]}, \"v\");
  MbsLite.Util.Assert.AssertInitialized(\"roller\", {roller.q[1], roller.q[2], roller.q[3], roller.q[4]}, \"q\");
  MbsLite.Util.Assert.AssertInitialized(\"roller\", {roller.omega[1], roller.omega[2], roller.omega[3]}, \"omega\");
initial algorithm
equation
  roller.crosses[1,1] = (roller.InPorts[1].P[2] - roller.r[2]) * roller.InPorts[1].F[3] - (roller.InPorts[1].P[3] - roller.r[3]) * roller.InPorts[1].F[2];
  roller.crosses[1,2] = (roller.InPorts[1].P[3] - roller.r[3]) * roller.InPorts[1].F[1] - (roller.InPorts[1].P[1] - roller.r[1]) * roller.InPorts[1].F[3];
  roller.crosses[1,3] = (roller.InPorts[1].P[1] - roller.r[1]) * roller.InPorts[1].F[2] - (roller.InPorts[1].P[2] - roller.r[2]) * roller.InPorts[1].F[1];
  roller.F[1] = roller.InPorts[1].F[1];
  roller.F[2] = -0.05 + roller.InPorts[1].F[2];
  roller.F[3] = roller.InPorts[1].F[3];
  roller.M[1] = roller.InPorts[1].M[1] + roller.crosses[1,1];
  roller.M[2] = roller.InPorts[1].M[2] + roller.crosses[1,2];
  roller.M[3] = roller.InPorts[1].M[3] + roller.crosses[1,3];
  der(roller.Active) = 0.0;
  der(roller.r[1]) = roller.v[1] * roller.Active;
  der(roller.r[2]) = roller.v[2] * roller.Active;
  der(roller.r[3]) = roller.v[3] * roller.Active;
  der(roller.v[1]) = roller.a[1] * roller.Active;
  der(roller.v[2]) = roller.a[2] * roller.Active;
  der(roller.v[3]) = roller.a[3] * roller.Active;
  roller.a[1] * 0.05 = roller.F[1];
  roller.a[2] * 0.05 = roller.F[2];
  roller.a[3] * 0.05 = roller.F[3];
  {der(roller.q[1]), der(roller.q[2]), der(roller.q[3]), der(roller.q[4])} = MbsLite.Util.Quaternions.QMult({roller.q[1], roller.q[2], roller.q[3], roller.q[4]}, {0.0, roller.omega[1], roller.omega[2], roller.omega[3]}) * 0.5 * roller.Active;
  der(roller.omega[1]) = roller.epsilon[1] * roller.Active;
  der(roller.omega[2]) = roller.epsilon[2] * roller.Active;
  der(roller.omega[3]) = roller.epsilon[3] * roller.Active;
  roller.T = MbsLite.Util.Quaternions.QToT({roller.q[1], roller.q[2], roller.q[3], roller.q[4]});
  5.699141943371693e-07 * roller.epsilon[1] = roller.T[1,1] * roller.M[1] + roller.T[2,1] * roller.M[2] + roller.T[3,1] * roller.M[3];
  1.468043638102385e-05 * roller.epsilon[2] + roller.omega[3] * 5.699141943371693e-07 * roller.omega[1] - roller.omega[1] * 1.468043638102385e-05 * roller.omega[3] = roller.T[1,2] * roller.M[1] + roller.T[2,2] * roller.M[2] + roller.T[3,2] * roller.M[3];
  1.468043638102385e-05 * roller.epsilon[3] + roller.omega[1] * 1.468043638102385e-05 * roller.omega[2] - roller.omega[2] * 5.699141943371693e-07 * roller.omega[1] = roller.T[1,3] * roller.M[1] + roller.T[2,3] * roller.M[2] + roller.T[3,3] * roller.M[3];
  roller.OutPort.r[1] = roller.r[1];
  roller.OutPort.r[2] = roller.r[2];
  roller.OutPort.r[3] = roller.r[3];
  roller.OutPort.v[1] = roller.v[1];
  roller.OutPort.v[2] = roller.v[2];
  roller.OutPort.v[3] = roller.v[3];
  roller.OutPort.a[1] = roller.a[1];
  roller.OutPort.a[2] = roller.a[2];
  roller.OutPort.a[3] = roller.a[3];
  roller.OutPort.T[1,1] = roller.T[1,1];
  roller.OutPort.T[1,2] = roller.T[1,2];
  roller.OutPort.T[1,3] = roller.T[1,3];
  roller.OutPort.T[2,1] = roller.T[2,1];
  roller.OutPort.T[2,2] = roller.T[2,2];
  roller.OutPort.T[2,3] = roller.T[2,3];
  roller.OutPort.T[3,1] = roller.T[3,1];
  roller.OutPort.T[3,2] = roller.T[3,2];
  roller.OutPort.T[3,3] = roller.T[3,3];
  roller.OutPort.omega[1] = roller.T[1,1] * roller.omega[1] + roller.T[1,2] * roller.omega[2] + roller.T[1,3] * roller.omega[3];
  roller.OutPort.omega[2] = roller.T[2,1] * roller.omega[1] + roller.T[2,2] * roller.omega[2] + roller.T[2,3] * roller.omega[3];
  roller.OutPort.omega[3] = roller.T[3,1] * roller.omega[1] + roller.T[3,2] * roller.omega[2] + roller.T[3,3] * roller.omega[3];
  roller.OutPort.epsilon[1] = roller.T[1,1] * roller.epsilon[1] + roller.T[1,2] * roller.epsilon[2] + roller.T[1,3] * roller.epsilon[3];
  roller.OutPort.epsilon[2] = roller.T[2,1] * roller.epsilon[1] + roller.T[2,2] * roller.epsilon[2] + roller.T[2,3] * roller.epsilon[3];
  roller.OutPort.epsilon[3] = roller.T[3,1] * roller.epsilon[1] + roller.T[3,2] * roller.epsilon[2] + roller.T[3,3] * roller.epsilon[3];
  if noEvent(abs(contact.cosBtwAxisAndVert) < 0.8090169943749475) and noEvent(contact.InPortB.r[2] < 0.05) then
    contact.isInContact = 1.0;
    contact.Drelvn = 0.0;
    contact.Forcet[1] = (-contact.relvt[1]) * 0.1 * (if noEvent(contact.relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / contact.relvtsqrt) * contact.Forcen;
    contact.Forcet[2] = contact.mu - contact.relvt[2] * 0.1 * (if noEvent(contact.relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / contact.relvtsqrt) * contact.Forcen;
    contact.Forcet[3] = (-contact.relvt[3]) * 0.1 * (if noEvent(contact.relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / contact.relvtsqrt) * contact.Forcen;
  else
    contact.isInContact = 0.0;
    contact.Forcen = 0.0;
    contact.Forcet[1] = 0.0;
    contact.Forcet[2] = 0.0;
    contact.Forcet[3] = 0.0;
  end if;
  contact.Drelvn = der(contact.relvn);
  contact.Forcen = contact.OutPortB.F[2];
  contact.OutPortB.F[1] = contact.Forcet[1];
  contact.OutPortB.F[2] = contact.Forcet[2] + contact.Forcen;
  contact.OutPortB.F[3] = contact.Forcet[3];
  contact.OutPortB.M[1] = 0.0;
  contact.OutPortB.M[2] = 0.0;
  contact.OutPortB.M[3] = 0.0;
  contact.vA = MbsLite.Util.Euler({contact.InPortA.r[1], contact.InPortA.r[2], contact.InPortA.r[3]}, {contact.rA[1], contact.rA[2], contact.rA[3]}, {contact.InPortA.v[1], contact.InPortA.v[2], contact.InPortA.v[3]}, {contact.InPortA.omega[1], contact.InPortA.omega[2], contact.InPortA.omega[3]});
  contact.vB = MbsLite.Util.Euler({contact.InPortB.r[1], contact.InPortB.r[2], contact.InPortB.r[3]}, {contact.rB[1], contact.rB[2], contact.rB[3]}, {contact.InPortB.v[1], contact.InPortB.v[2], contact.InPortB.v[3]}, {contact.InPortB.omega[1], contact.InPortB.omega[2], contact.InPortB.omega[3]});
  contact.relv[1] = contact.vB[1] - contact.vA[1];
  contact.relv[2] = contact.vB[2] - contact.vA[2];
  contact.relv[3] = contact.vB[3] - contact.vA[3];
  contact.vAn = contact.vA[2];
  contact.vBn = contact.vB[2];
  contact.relvn = contact.relv[2];
  contact.vAt[1] = contact.vA[1];
  contact.vAt[2] = contact.vA[2] - contact.vAn;
  contact.vAt[3] = contact.vA[3];
  contact.vBt[1] = contact.vB[1];
  contact.vBt[2] = contact.vB[2] - contact.vBn;
  contact.vBt[3] = contact.vB[3];
  contact.relvt[1] = contact.vBt[1] - contact.vAt[1];
  contact.relvt[2] = contact.vBt[2] - contact.vAt[2];
  contact.relvt[3] = contact.vBt[3] - contact.vAt[3];
  contact.relvtsqrt = Modelica.Math.Vectors.norm({contact.relvt[1], contact.relvt[2], contact.relvt[3]}, 2.0);
  contact.OutPortA.P[1] = contact.rA[1];
  contact.OutPortA.P[2] = contact.rA[2];
  contact.OutPortA.P[3] = contact.rA[3];
  contact.OutPortB.P[1] = contact.rB[1];
  contact.OutPortB.P[2] = contact.rB[2];
  contact.OutPortB.P[3] = contact.rB[3];
  contact.n1j[1] = 0.0;
  contact.n1j[2] = 1.0;
  contact.n1j[3] = 0.0;
  contact.ni[1] = contact.InPortB.T[1,1];
  contact.ni[2] = contact.InPortB.T[2,1];
  contact.ni[3] = contact.InPortB.T[3,1];
  contact.crs[1] = -contact.ni[3];
  contact.crs[2] = 0.0;
  contact.crs[3] = contact.ni[1];
  contact.nk[1] = contact.crs[1] / sqrt(contact.crs[1] ^ 2.0 + contact.crs[2] ^ 2.0 + contact.crs[3] ^ 2.0);
  contact.nk[2] = contact.crs[2] / sqrt(contact.crs[1] ^ 2.0 + contact.crs[2] ^ 2.0 + contact.crs[3] ^ 2.0);
  contact.nk[3] = contact.crs[3] / sqrt(contact.crs[1] ^ 2.0 + contact.crs[2] ^ 2.0 + contact.crs[3] ^ 2.0);
  contact.cosBtwAxisAndVert = contact.ni[2];
  if noEvent(abs(contact.cosBtwAxisAndVert) < 0.8090169943749475) and noEvent(contact.InPortB.r[2] < 0.05) then
    contact.lambda = (0.05 * (contact.n1j[1] * contact.nk[1] + contact.n1j[2] * contact.nk[2] + contact.n1j[3] * contact.nk[3]) + -0.04045084971874738 * (contact.rho[1] * contact.nk[1] + contact.rho[2] * contact.nk[2] + contact.rho[3] * contact.nk[3])) / (contact.n1k[1] * contact.nk[1] + contact.n1k[2] * contact.nk[2] + contact.n1k[3] * contact.nk[3]);
    contact.OBPB[1] = contact.n1k[1] * contact.lambda - contact.n1j[1] * 0.05 + contact.rho[1] * 0.04045084971874738;
    contact.OBPB[2] = contact.n1k[2] * contact.lambda - contact.n1j[2] * 0.05 + contact.rho[2] * 0.04045084971874738;
    contact.OBPB[3] = contact.n1k[3] * contact.lambda - contact.n1j[3] * 0.05 + contact.rho[3] * 0.04045084971874738;
    contact.rB[1] = contact.InPortB.r[1] + contact.OBPB[1];
    contact.rB[2] = contact.InPortB.r[2] + contact.OBPB[2];
    contact.rB[3] = contact.InPortB.r[3] + contact.OBPB[3];
    contact.j = 1.0;
  else
    contact.lambda = 0.05 * (contact.n1j[1] * contact.nk[1] + contact.n1j[2] * contact.nk[2] + contact.n1j[3] * contact.nk[3]) / (contact.n1k[1] * contact.nk[1] + contact.n1k[2] * contact.nk[2] + contact.n1k[3] * contact.nk[3]);
    contact.OBPB[1] = (-contact.n1j[1]) * 0.05;
    contact.OBPB[2] = (-contact.n1j[2]) * 0.05;
    contact.OBPB[3] = (-contact.n1j[3]) * 0.05;
    if noEvent(contact.cosBtwAxisAndVert > 0.0) then
      contact.rB[1] = contact.InPortB.r[1] - contact.ni[1] * 0.02938926261462366;
      contact.rB[2] = contact.InPortB.r[2] - contact.ni[2] * 0.02938926261462366;
      contact.rB[3] = contact.InPortB.r[3] - contact.ni[3] * 0.02938926261462366;
      contact.j = 2.0;
    else
      contact.rB[1] = contact.InPortB.r[1] + contact.ni[1] * 0.02938926261462366;
      contact.rB[2] = contact.InPortB.r[2] + contact.ni[2] * 0.02938926261462366;
      contact.rB[3] = contact.InPortB.r[3] + contact.ni[3] * 0.02938926261462366;
      contact.j = 3.0;
    end if;
  end if;
  contact.rA[1] = contact.rB[1];
  contact.rA[2] = 0.0;
  contact.rA[3] = contact.rB[3];
  contact.OutPortA.F[1] + contact.OutPortB.F[1] = 0.0;
  contact.OutPortA.F[2] + contact.OutPortB.F[2] = 0.0;
  contact.OutPortA.F[3] + contact.OutPortB.F[3] = 0.0;
  contact.OutPortA.M[1] + contact.OutPortB.M[1] = 0.0;
  contact.OutPortA.M[2] + contact.OutPortB.M[2] = 0.0;
  contact.OutPortA.M[3] + contact.OutPortB.M[3] = 0.0;
  base.OutPort.r[1] = 0.0;
  base.OutPort.r[2] = 0.0;
  base.OutPort.r[3] = 0.0;
  base.OutPort.v[1] = 0.0;
  base.OutPort.v[2] = 0.0;
  base.OutPort.v[3] = 0.0;
  base.OutPort.a[1] = 0.0;
  base.OutPort.a[2] = 0.0;
  base.OutPort.a[3] = 0.0;
  base.OutPort.T[1,1] = 1.0;
  base.OutPort.T[1,2] = 0.0;
  base.OutPort.T[1,3] = 0.0;
  base.OutPort.T[2,1] = 0.0;
  base.OutPort.T[2,2] = 1.0;
  base.OutPort.T[2,3] = 0.0;
  base.OutPort.T[3,1] = 0.0;
  base.OutPort.T[3,2] = 0.0;
  base.OutPort.T[3,3] = 1.0;
  base.OutPort.omega[1] = 0.0;
  base.OutPort.omega[2] = 0.0;
  base.OutPort.omega[3] = 0.0;
  base.OutPort.epsilon[1] = 0.0;
  base.OutPort.epsilon[2] = 0.0;
  base.OutPort.epsilon[3] = 0.0;
  contact.n1k[1] = roller.T[1,3];
  contact.n1k[2] = roller.T[2,3];
  contact.n1k[3] = roller.T[3,3];
  contact.rho = Modelica.Math.Vectors.normalize({-roller.r[1], 0.05 - roller.r[2], -roller.r[3]}, 1e-13);
  when time > 0.0 then
    MbsLite.Util.Assert.Assert(false, \"should have terminated after checking the solution to the initial problem\", false);
  end when;
  contact.InPortB.T[1,1] = roller.OutPort.T[1,1];
  contact.InPortB.T[1,2] = roller.OutPort.T[1,2];
  contact.InPortB.T[1,3] = roller.OutPort.T[1,3];
  contact.InPortB.T[2,1] = roller.OutPort.T[2,1];
  contact.InPortB.T[2,2] = roller.OutPort.T[2,2];
  contact.InPortB.T[2,3] = roller.OutPort.T[2,3];
  contact.InPortB.T[3,1] = roller.OutPort.T[3,1];
  contact.InPortB.T[3,2] = roller.OutPort.T[3,2];
  contact.InPortB.T[3,3] = roller.OutPort.T[3,3];
  contact.InPortB.a[1] = roller.OutPort.a[1];
  contact.InPortB.a[2] = roller.OutPort.a[2];
  contact.InPortB.a[3] = roller.OutPort.a[3];
  contact.InPortB.epsilon[1] = roller.OutPort.epsilon[1];
  contact.InPortB.epsilon[2] = roller.OutPort.epsilon[2];
  contact.InPortB.epsilon[3] = roller.OutPort.epsilon[3];
  contact.InPortB.omega[1] = roller.OutPort.omega[1];
  contact.InPortB.omega[2] = roller.OutPort.omega[2];
  contact.InPortB.omega[3] = roller.OutPort.omega[3];
  contact.InPortB.r[1] = roller.OutPort.r[1];
  contact.InPortB.r[2] = roller.OutPort.r[2];
  contact.InPortB.r[3] = roller.OutPort.r[3];
  contact.InPortB.v[1] = roller.OutPort.v[1];
  contact.InPortB.v[2] = roller.OutPort.v[2];
  contact.InPortB.v[3] = roller.OutPort.v[3];
  contact.OutPortB.F[1] = roller.InPorts[1].F[1];
  contact.OutPortB.F[2] = roller.InPorts[1].F[2];
  contact.OutPortB.F[3] = roller.InPorts[1].F[3];
  contact.OutPortB.M[1] = roller.InPorts[1].M[1];
  contact.OutPortB.M[2] = roller.InPorts[1].M[2];
  contact.OutPortB.M[3] = roller.InPorts[1].M[3];
  contact.OutPortB.P[1] = roller.InPorts[1].P[1];
  contact.OutPortB.P[2] = roller.InPorts[1].P[2];
  contact.OutPortB.P[3] = roller.InPorts[1].P[3];
  base.OutPort.T[1,1] = contact.InPortA.T[1,1];
  base.OutPort.T[1,2] = contact.InPortA.T[1,2];
  base.OutPort.T[1,3] = contact.InPortA.T[1,3];
  base.OutPort.T[2,1] = contact.InPortA.T[2,1];
  base.OutPort.T[2,2] = contact.InPortA.T[2,2];
  base.OutPort.T[2,3] = contact.InPortA.T[2,3];
  base.OutPort.T[3,1] = contact.InPortA.T[3,1];
  base.OutPort.T[3,2] = contact.InPortA.T[3,2];
  base.OutPort.T[3,3] = contact.InPortA.T[3,3];
  base.OutPort.a[1] = contact.InPortA.a[1];
  base.OutPort.a[2] = contact.InPortA.a[2];
  base.OutPort.a[3] = contact.InPortA.a[3];
  base.OutPort.epsilon[1] = contact.InPortA.epsilon[1];
  base.OutPort.epsilon[2] = contact.InPortA.epsilon[2];
  base.OutPort.epsilon[3] = contact.InPortA.epsilon[3];
  base.OutPort.omega[1] = contact.InPortA.omega[1];
  base.OutPort.omega[2] = contact.InPortA.omega[2];
  base.OutPort.omega[3] = contact.InPortA.omega[3];
  base.OutPort.r[1] = contact.InPortA.r[1];
  base.OutPort.r[2] = contact.InPortA.r[2];
  base.OutPort.r[3] = contact.InPortA.r[3];
  base.OutPort.v[1] = contact.InPortA.v[1];
  base.OutPort.v[2] = contact.InPortA.v[2];
  base.OutPort.v[3] = contact.InPortA.v[3];
end MbsLite.Test.Constraints.ContactTest;
"
====================================
Checking MbsLite.Test.Constraints.ContactTest
"Check of MbsLite.Test.Constraints.ContactTest completed successfully.
Class MbsLite.Test.Constraints.ContactTest has 220 equation(s) and 220 variable(s).
144 of these are trivial equation(s)."
====================================
Simulating MbsLite.Test.Constraints.ContactTest
record SimulationResult
    resultFile = "",
    simulationOptions = "startTime = 0.0, stopTime = 1.0, numberOfIntervals = 100, tolerance = 1e-09, method = 'dassl', fileNamePrefix = 'MbsLite.Test.Constraints.ContactTest', options = '', outputFormat = 'csv', variableFilter = '.*', cflags = '', simflags = ''",
    messages = "Simulation execution failed for model: MbsLite.Test.Constraints.ContactTest
stdout            | info    | Assertion passed: Roller torque should be: { 0, 0, 0 }, but was: { 0, -0, 0 }
stdout            | info    | Assertion passed: Roller angular acceleration should be: { 0, 0, 0 }, but was: { 0, 0, 0 }
stdout            | info    | Assertion passed: crosses[1] should be: { 0, 0, 0 }, but was: { 0, -0, 0 }
stdout            | info    | Assertion passed: mu should be: 0, but was: 0
stdout            | info    | Assertion passed: Forcet should be: { 0, 0, 0 }, but was: { -0, -0, -0 }
stdout            | info    | Assertion passed: Drelvn should be: 0, but was: -4.16334e-17
stdout            | info    | Assertion passed: relvn should be: 0, but was: 0
stdout            | info    | Assertion passed: relvt should be: { 0, 0, 0 }, but was: { 0, 0, 0 }
stdout            | info    | Assertion passed: Contact point velocity should be: { 0, 0, 0 }, but was: { 0, 0, 0 }
stdout            | info    | Assertion passed: Contact point velocity Euler should be: { 0, 0, 0 }, but was: { 0, 0, 0 }
stdout            | info    | Assertion passed: Roller isInContact should be: 1, but was: 1
stdout            | info    | Assertion passed: Roller angular velocity should be: { 0, 0, -1 }, but was: { 0, 0, -1 }
stdout            | info    | Assertion passed: Roller velocity should be: { 0.00954915, 0, 0 }, but was: { 0.00954915, 0, 0 }
stdout            | info    | Assertion passed: Roller center should be: { 0, 0.00954915, 0 }, but was: { 0, 0.00954915, 0 }
stdout            | info    | Assertion passed: Contact point should be: { 0, 0, 0 }, but was: { 0, 0, 0 }
stdout            | info    | The initialization finished successfully without homotopy method.
[/home/vf/om/models/omni/thin/lib/MbsLite/Test/Constraints/ContactTest.mo:152:3-152:22:writable]
stdout            | info    | Simulation call terminate() at initialization (time 0.000000)
|                 | |       | Message : passed
",
    timeFrontend = 0.625653305,
    timeBackend = 0.994901869,
    timeSimCode = 0.131475074,
    timeTemplates = 0.1479074589999999,
    timeCompile = 9.432459421000001
end SimulationResult;
"[/home/vf/om/models/omni/thin/lib/MbsLite/KinematicPort.mo:3:1-12:18:writable] Warning: Connector .MbsLite.KinematicPort is not balanced: The number of potential variables (24) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/WrenchPort.mo:3:1-9:15:writable] Warning: Connector .MbsLite.WrenchPort is not balanced: The number of potential variables (9) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/KinematicPort.mo:3:1-12:18:writable] Warning: Connector .MbsLite.KinematicPort is not balanced: The number of potential variables (24) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/WrenchPort.mo:3:1-9:15:writable] Warning: Connector .MbsLite.WrenchPort is not balanced: The number of potential variables (9) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/KinematicPort.mo:3:1-12:18:writable] Warning: Connector .MbsLite.KinematicPort is not balanced: The number of potential variables (24) is not equal to the number of flow variables (0).
[/home/vf/om/models/omni/thin/lib/MbsLite/WrenchPort.mo:3:1-9:15:writable] Warning: Connector .MbsLite.WrenchPort is not balanced: The number of potential variables (9) is not equal to the number of flow variables (0).
Warning: Assuming fixed start value for the following 14 variables:
         contact.relvn:VARIABLE()  type: Real 
         roller.Active:VARIABLE(start = 1.0 )  "Flag of active dynamics" type: Real 
         roller.omega[3]:VARIABLE(start = -1.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [3]
         roller.omega[2]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [3]
         roller.omega[1]:VARIABLE(start = 0.0 unit = "rad/s" )  "Vector of angular rate in local coords" type: Real  [3]
         roller.q[4]:VARIABLE(start = 0.0 )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [4]
         roller.q[3]:VARIABLE(start = 0.0 )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [4]
         roller.q[2]:VARIABLE(start = 0.0 )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [4]
         roller.q[1]:VARIABLE(start = 1.0 )  "Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6" type: Real  [4]
         roller.v[3]:VARIABLE(start = 0.0 unit = "m/s" )  "Velocity vector of masscenter" type: Real  [3]
         roller.v[1]:VARIABLE(start = 0.009549150281252625 unit = "m/s" )  "Velocity vector of masscenter" type: Real  [3]
         roller.r[3]:VARIABLE(start = 0.0 unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [3]
         roller.r[1]:VARIABLE(start = 0.0 unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [3]
         roller.r[2]:VARIABLE(start = 0.009549150281252625 unit = "m" )  "Radius vector of masscenter in global coords" type: Real  [3]
"
