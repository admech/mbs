====================================
cd to out
"/home/vf/om/models/omni/test/out"
====================================
Setting ModelicaPath
true
====================================
Loading Modelica
true
====================================
Loading MbsLite
true
====================================
Loading MbsLite.Test.Omni.OmniWheelOnPlaneTest
true
====================================
Instantiating MbsLite.Test.Omni.OmniWheelOnPlaneTest
"function MbsLite.Util.Assert.AssertInitialized
  input String modelName;
  input Real[:] value;
  input String parameterName;
algorithm
  assert(max(value) < 9.999999999999999e+59, modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitialized;

function MbsLite.Util.Assert.AssertInitializedI
  input String modelName;
  input Integer value;
  input String parameterName;
algorithm
  assert(value > -4611686018427387903, modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitializedI;

function MbsLite.Util.Assert.AssertInitializedS
  input String modelName;
  input String value;
  input String parameterName;
algorithm
  assert(value <> \"NOT INITIALIZED\", modelName + \": \" + parameterName + \" is not initialized\");
end MbsLite.Util.Assert.AssertInitializedS;

function MbsLite.Util.CompareReal
  input Real a;
  input Real b;
  input Real absTol = 1e-10 \"Absolute tolerance.\";
  input Real relTol = 1e-05 \"Relative tolerance.\";
  output Boolean equal;
  protected Real diff;
algorithm
  diff := abs(a - b);
  equal := diff < absTol or diff <= max(abs(b), abs(a)) * relTol;
end MbsLite.Util.CompareReal;

function MbsLite.Util.Euler \"Inline before index reduction\"
  input Real[3] origin;
  input Real[3] point;
  input Real[3] velocityOfOrigin;
  input Real[3] omega;
  output Real[3] velocityOfPoint;
algorithm
  velocityOfPoint := {velocityOfOrigin[1] + omega[2] * (point[3] - origin[3]) - omega[3] * (point[2] - origin[2]), velocityOfOrigin[2] + omega[3] * (point[1] - origin[1]) - omega[1] * (point[3] - origin[3]), velocityOfOrigin[3] + omega[1] * (point[2] - origin[2]) - omega[2] * (point[1] - origin[1])};
end MbsLite.Util.Euler;

function MbsLite.Util.Quaternions.QMult \"Inline before index reduction\"
  input Real[4] q1;
  input Real[4] q2;
  output Real[4] q3;
  protected Real a1;
  protected Real a2;
  protected Real[3] A1;
  protected Real[3] A2;
  protected Real[3] A3;
algorithm
  a1 := q1[1];
  a2 := q2[1];
  A1 := {q1[2], q1[3], q1[4]};
  A2 := {q2[2], q2[3], q2[4]};
  A3 := {A2[1] * a1 + A1[1] * a2 + A1[2] * A2[3] - A1[3] * A2[2], A2[2] * a1 + A1[2] * a2 + A1[3] * A2[1] - A1[1] * A2[3], A2[3] * a1 + A1[3] * a2 + A1[1] * A2[2] - A1[2] * A2[1]};
  q3 := {a1 * a2 + (-A1[2]) * A2[2] - A1[3] * A2[3] - A1[1] * A2[1], A3[1], A3[2], A3[3]};
end MbsLite.Util.Quaternions.QMult;

function MbsLite.Util.Quaternions.QRot \"Inline before index reduction\"
  input Real angle;
  input Real[3] axis;
  output Real[4] q;
  protected Real s;
algorithm
  s := sin(0.5 * angle);
  q := {cos(0.5 * angle), s * axis[1], s * axis[2], s * axis[3]};
end MbsLite.Util.Quaternions.QRot;

function MbsLite.Util.Quaternions.QToT \"Inline before index reduction\" \"Converts quaternion to Rotation matrix.\"
  input Real[4] q;
  output Real[3, 3] T;
algorithm
  T := {{(q[1] ^ 2.0 + q[2] ^ 2.0 + (-q[3] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[3] - q[1] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[2] * q[4] + q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[1] * q[4] + q[2] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[3] ^ 2.0 + (-q[2] ^ 2.0) - q[4] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[3] * q[4] - q[1] * q[2]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}, {2.0 * (q[2] * q[4] - q[1] * q[3]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), 2.0 * (q[1] * q[2] + q[3] * q[4]) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0), (q[1] ^ 2.0 + q[4] ^ 2.0 - q[3] ^ 2.0 - q[2] ^ 2.0) / (q[1] ^ 2.0 + q[2] ^ 2.0 + q[3] ^ 2.0 + q[4] ^ 2.0)}};
end MbsLite.Util.Quaternions.QToT;

function MbsLite.Util.StringA
  input Real[:] array;
  input String delim = \", \";
  output String render;
  protected String accumulator = \"\";
  protected Integer counter = 0;
algorithm
  for item in array loop
    accumulator := accumulator + String(item, 0, true, 6);
    counter := 1 + counter;
    if counter < size(array, 1) then
      accumulator := accumulator + delim;
    end if;
  end for;
  render := \"{ \" + accumulator + \" }\";
end MbsLite.Util.StringA;

function Modelica.Math.Vectors.norm \"Return the p-norm of a vector\"
  input Real[:] v \"Real vector\";
  input Real p(min = 1.0) = 2.0 \"Type of p-norm (often used: 1, 2, or Modelica.Constants.inf)\";
  output Real result = 0.0 \"p-norm of vector v\";
  protected Real eps = 1e-14;
algorithm
  if size(v, 1) > 0 then
    if p >= 2.0 - eps and p <= 2.0 + eps then
      result := sqrt(v * v);
    elseif p >= 9.999999999999999e+59 then
      result := max(array(abs($tmpVar8) for $tmpVar8 in v));
    elseif p >= 1.0 - eps and p <= 1.0 + eps then
      result := sum(array(abs($tmpVar11) for $tmpVar11 in v));
    elseif p >= 1.0 then
      result := sum(abs(v[i]) ^ p for i in 1:size(v, 1)) ^ (1.0 / p);
    else
      assert(false, \"Optional argument \\\"p\\\" (= \" + String(p, 0, true, 6) + \") of function \\\"norm\\\" >= 1 required\");
    end if;
  end if;
end Modelica.Math.Vectors.norm;

class MbsLite.Test.Omni.OmniWheelOnPlaneTest
  constant Real m.forward[1] = 1.0;
  constant Real m.forward[2] = 0.0;
  constant Real m.forward[3] = 0.0;
  constant Real m.vertical[1] = 0.0;
  constant Real m.vertical[2] = 1.0;
  constant Real m.vertical[3] = 0.0;
  constant Real m.Gravity[1] = 0.0;
  constant Real m.Gravity[2] = -1.0;
  constant Real m.Gravity[3] = 0.0;
  parameter Boolean m.strict = false;
  parameter Real m.R = 0.05 \"'wheel radius' := distance from wheel axis to the floor\";
  parameter Integer m.n = 5;
  parameter Integer m.nOne = 2;
  parameter Real m.wheelHubMass = 0.15;
  parameter Real m.rollerMass = 0.05;
  parameter Real m.halfRollerAngle = 0.6283185307179586;
  parameter Real m.wheelHubRadius = 0.04045084971874738;
  parameter Real m.rollerLength = 0.05877852522924731;
  parameter Real m.rollerRadiusForMoi = 0.004774575140626312;
  parameter Real m.v0 = 0.0;
  parameter Real m.v0dirAngle = 0.0;
  parameter Real m.q0[1] = 1.0;
  parameter Real m.q0[2] = 0.0;
  parameter Real m.q0[3] = 0.0;
  parameter Real m.q0[4] = 0.0;
  parameter Real m.v0vec[1] = 0.0;
  parameter Real m.v0vec[2] = 0.0;
  parameter Real m.v0vec[3] = 0.0;
  Real m.base.OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.base.OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.base.OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.base.OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.base.OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.base.OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.base.OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.base.OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.base.OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.base.OutPort.T[1,1] \"Matrix of rotation\";
  Real m.base.OutPort.T[1,2] \"Matrix of rotation\";
  Real m.base.OutPort.T[1,3] \"Matrix of rotation\";
  Real m.base.OutPort.T[2,1] \"Matrix of rotation\";
  Real m.base.OutPort.T[2,2] \"Matrix of rotation\";
  Real m.base.OutPort.T[2,3] \"Matrix of rotation\";
  Real m.base.OutPort.T[3,1] \"Matrix of rotation\";
  Real m.base.OutPort.T[3,2] \"Matrix of rotation\";
  Real m.base.OutPort.T[3,3] \"Matrix of rotation\";
  Real m.base.OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.base.OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.base.OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.base.OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.base.OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.base.OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter Real m.wheel.Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\", start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\", start = 9.999999999999999e+59) = -1.0;
  parameter Real m.wheel.Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\", start = 9.999999999999999e+59) = 0.0;
  constant Real m.wheel.rollerAxisLocal[1] = 1.0;
  constant Real m.wheel.rollerAxisLocal[2] = 0.0;
  constant Real m.wheel.rollerAxisLocal[3] = 0.0;
  constant Real m.wheel.vertical[1] = 0.0;
  constant Real m.wheel.vertical[2] = 1.0;
  constant Real m.wheel.vertical[3] = 0.0;
  constant Real m.wheel.wheelAxis[1] = 0.0;
  constant Real m.wheel.wheelAxis[2] = 0.0;
  constant Real m.wheel.wheelAxis[3] = 1.0;
  parameter String m.wheel.name = \"wheel\";
  parameter Integer m.wheel.n = 5 \"Number of rollers\";
  parameter Integer m.wheel.nOne = 2;
  parameter Real m.wheel.psi = 0.0 \"Roller mecanum angle\";
  parameter Real m.wheel.rollerMass = 0.05;
  parameter Real m.wheel.rollerAxialMoi = 5.699141943371693e-07 \"Roller moment of inertia wrt its axis\";
  parameter Real m.wheel.rollerOrthogonalMoi = 1.468043638102385e-05 \"Roller moment of inertia wrt any axis orthogonal to the main roller axis\";
  parameter Real m.wheel.wheelHubMass = 0.15;
  parameter Real m.wheel.wheelHubAxialMoi = 0.0001227203432226514 \"Wheel hub moment of inertia wrt its axis\";
  parameter Real m.wheel.wheelHubOrthogonalMoi = 6.261017161132568e-05 \"Wheel hub moment of inertia wrt any axis orthogonal to the main wheelHub axis\";
  parameter Real m.wheel.alpha = 0.6283185307179586 \"Max angle of the half-sector\";
  parameter Real m.wheel.R = 0.05 \"Omni wheel outer radius\";
  parameter Real m.wheel.R1 = 0.04045084971874738 \"Omni wheel inner radius\";
  parameter Real m.wheel.r0[1](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.r0[2](start = 9.999999999999999e+59) = 0.05;
  parameter Real m.wheel.r0[3](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.q0[1](start = 9.999999999999999e+59) = 1.0;
  parameter Real m.wheel.q0[2](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.q0[3](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.q0[4](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.v0[1](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.v0[2](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.v0[3](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.omega0[1](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.omega0[2](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.omega0[3](start = 9.999999999999999e+59) = 0.0;
  parameter Real m.wheel.T0[1,1] = 1.0;
  parameter Real m.wheel.T0[1,2] = 0.0;
  parameter Real m.wheel.T0[1,3] = 0.0;
  parameter Real m.wheel.T0[2,1] = 0.0;
  parameter Real m.wheel.T0[2,2] = 1.0;
  parameter Real m.wheel.T0[2,3] = 0.0;
  parameter Real m.wheel.T0[3,1] = 0.0;
  parameter Real m.wheel.T0[3,2] = 0.0;
  parameter Real m.wheel.T0[3,3] = 1.0;
  parameter Real m.wheel.RollerAngles[1] = 0.0 \"Angles between downward vertical { 0, -1, 0 } and roller center radius vectors\";
  parameter Real m.wheel.RollerAngles[2] = 1.256637061435917 \"Angles between downward vertical { 0, -1, 0 } and roller center radius vectors\";
  parameter Real m.wheel.RollerQs[1,1] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(m.wheel.RollerAngles[1], {0.0, 0.0, 1.0}))[1];
  parameter Real m.wheel.RollerQs[1,2] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(m.wheel.RollerAngles[1], {0.0, 0.0, 1.0}))[2];
  parameter Real m.wheel.RollerQs[1,3] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(m.wheel.RollerAngles[1], {0.0, 0.0, 1.0}))[3];
  parameter Real m.wheel.RollerQs[1,4] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(m.wheel.RollerAngles[1], {0.0, 0.0, 1.0}))[4];
  parameter Real m.wheel.RollerQs[2,1] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(m.wheel.RollerAngles[2], {0.0, 0.0, 1.0}))[1];
  parameter Real m.wheel.RollerQs[2,2] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(m.wheel.RollerAngles[2], {0.0, 0.0, 1.0}))[2];
  parameter Real m.wheel.RollerQs[2,3] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(m.wheel.RollerAngles[2], {0.0, 0.0, 1.0}))[3];
  parameter Real m.wheel.RollerQs[2,4] = MbsLite.Util.Quaternions.QMult({1.0, 0.0, 0.0, 0.0}, MbsLite.Util.Quaternions.QRot(m.wheel.RollerAngles[2], {0.0, 0.0, 1.0}))[4];
  parameter Real m.wheel.VerticalInRollersAxes[1,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {0.0, 1.0, 0.0})[1];
  parameter Real m.wheel.VerticalInRollersAxes[1,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {0.0, 1.0, 0.0})[2];
  parameter Real m.wheel.VerticalInRollersAxes[1,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {0.0, 1.0, 0.0})[3];
  parameter Real m.wheel.VerticalInRollersAxes[2,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {0.0, 1.0, 0.0})[1];
  parameter Real m.wheel.VerticalInRollersAxes[2,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {0.0, 1.0, 0.0})[2];
  parameter Real m.wheel.VerticalInRollersAxes[2,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {0.0, 1.0, 0.0})[3];
  parameter Real m.wheel.RollerCenterDirections[1,1] = -0.0;
  parameter Real m.wheel.RollerCenterDirections[1,2] = -1.0;
  parameter Real m.wheel.RollerCenterDirections[1,3] = -0.0;
  parameter Real m.wheel.RollerCenterDirections[2,1] = 0.9510565162951536;
  parameter Real m.wheel.RollerCenterDirections[2,2] = -0.3090169943749475;
  parameter Real m.wheel.RollerCenterDirections[2,3] = -0.0;
  parameter Real m.wheel.RollerAxisDirections[1,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {1.0, 0.0, 0.0})[1];
  parameter Real m.wheel.RollerAxisDirections[1,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {1.0, 0.0, 0.0})[2];
  parameter Real m.wheel.RollerAxisDirections[1,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[1,1], m.wheel.RollerQs[1,2], m.wheel.RollerQs[1,3], m.wheel.RollerQs[1,4]}) * {1.0, 0.0, 0.0})[3];
  parameter Real m.wheel.RollerAxisDirections[2,1] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {1.0, 0.0, 0.0})[1];
  parameter Real m.wheel.RollerAxisDirections[2,2] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {1.0, 0.0, 0.0})[2];
  parameter Real m.wheel.RollerAxisDirections[2,3] = (MbsLite.Util.Quaternions.QToT({m.wheel.RollerQs[2,1], m.wheel.RollerQs[2,2], m.wheel.RollerQs[2,3], m.wheel.RollerQs[2,4]}) * {1.0, 0.0, 0.0})[3];
  parameter Real m.wheel.RollerCenters[1,1] = -0.0;
  parameter Real m.wheel.RollerCenters[1,2] = -0.04045084971874738;
  parameter Real m.wheel.RollerCenters[1,3] = -0.0;
  parameter Real m.wheel.RollerCenters[2,1] = 0.03847104421469068;
  parameter Real m.wheel.RollerCenters[2,2] = -0.0125;
  parameter Real m.wheel.RollerCenters[2,3] = -0.0;
  Real m.wheel.Rollers[1].OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[1].OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[1].OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[1].OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[1].OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Rollers[1].name = \"wheel.Rollers[1]\";
  parameter Real m.wheel.Rollers[1].m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.05 \"Mass of the body\";
  parameter Real m.wheel.Rollers[1].I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 5.699141943371693e-07 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 1.468043638102385e-05 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[1].I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 1.468043638102385e-05 \"Central tensor of inertia of the body\";
  Real m.wheel.Rollers[1].r[1](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[1,1]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[1].r[2](quantity = \"Length\", unit = \"m\", start = 0.05 + m.wheel.RollerCenters[1,2]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[1].r[3](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[1,3]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[1].v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[1].a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[1].q[1](start = m.wheel.RollerQs[1,1]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[1].q[2](start = m.wheel.RollerQs[1,2]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[1].q[3](start = m.wheel.RollerQs[1,3]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[1].q[4](start = m.wheel.RollerQs[1,4]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[1].omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[1].omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[1].omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[1].epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[1].F[1](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Rollers[1].F[2](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Rollers[1].F[3](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Rollers[1].M[1](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Rollers[1].M[2](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Rollers[1].M[3](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Rollers[1].T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[1].Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Rollers[1].N = 2;
  parameter Real m.wheel.Rollers[1].Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0;
  parameter Real m.wheel.Rollers[1].Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Rollers[1].Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0;
  Real m.wheel.Rollers[1].InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[1].InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[1].InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[1].crosses[1,1];
  Real m.wheel.Rollers[1].crosses[1,2];
  Real m.wheel.Rollers[1].crosses[1,3];
  Real m.wheel.Rollers[1].crosses[2,1];
  Real m.wheel.Rollers[1].crosses[2,2];
  Real m.wheel.Rollers[1].crosses[2,3];
  Real m.wheel.Rollers[2].OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Rollers[2].OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[2].OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[2].OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Rollers[2].OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Rollers[2].name = \"wheel.Rollers[2]\";
  parameter Real m.wheel.Rollers[2].m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.05 \"Mass of the body\";
  parameter Real m.wheel.Rollers[2].I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 5.699141943371693e-07 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 1.468043638102385e-05 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Rollers[2].I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 1.468043638102385e-05 \"Central tensor of inertia of the body\";
  Real m.wheel.Rollers[2].r[1](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[2,1]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[2].r[2](quantity = \"Length\", unit = \"m\", start = 0.05 + m.wheel.RollerCenters[2,2]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[2].r[3](quantity = \"Length\", unit = \"m\", start = m.wheel.RollerCenters[2,3]) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Rollers[2].v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Rollers[2].a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Rollers[2].q[1](start = m.wheel.RollerQs[2,1]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[2].q[2](start = m.wheel.RollerQs[2,2]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[2].q[3](start = m.wheel.RollerQs[2,3]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[2].q[4](start = m.wheel.RollerQs[2,4]) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Rollers[2].omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[2].omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[2].omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Rollers[2].epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Rollers[2].F[1](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Rollers[2].F[2](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Rollers[2].F[3](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Rollers[2].M[1](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Rollers[2].M[2](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Rollers[2].M[3](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Rollers[2].T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Rollers[2].Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Rollers[2].N = 2;
  parameter Real m.wheel.Rollers[2].Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0;
  parameter Real m.wheel.Rollers[2].Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Rollers[2].Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0;
  Real m.wheel.Rollers[2].InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Rollers[2].InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Rollers[2].InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Rollers[2].crosses[1,1];
  Real m.wheel.Rollers[2].crosses[1,2];
  Real m.wheel.Rollers[2].crosses[1,3];
  Real m.wheel.Rollers[2].crosses[2,1];
  Real m.wheel.Rollers[2].crosses[2,2];
  Real m.wheel.Rollers[2].crosses[2,3];
  parameter Integer m.wheel.Joints[1].ConstraintNo = 1;
  Real m.wheel.Joints[1].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[1].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[1].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[1].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[1].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[1].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[1].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[1].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Joints[1].name = \"joint1\";
  parameter Real m.wheel.Joints[1].nA[1] = 1.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[1].nA[2] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[1].nA[3] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[1].nB[1] = 1.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[1].nB[2] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[1].nB[3] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[1].rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[1].rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[1].rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[1].rB[1](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[1].rB[2](quantity = \"Length\", unit = \"m\") = -0.04045084971874738 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[1].rB[3](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  Real m.wheel.Joints[1].RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[1].RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[1].RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[1].RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[1].RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[1].RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[1].vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[1].vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[1].vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[1].vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[1].vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[1].vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[1].lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real m.wheel.Joints[1].mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real m.wheel.Joints[1].angle \"Relative angle. Beware numerical error accumulation!\";
  Real m.wheel.Joints[1].epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[1].epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[1].epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[1].nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[1].nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[1].nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[1].nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[1].nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[1].nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[1].M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
  parameter Integer m.wheel.Joints[2].ConstraintNo = 1;
  Real m.wheel.Joints[2].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Joints[2].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Joints[2].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Joints[2].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Joints[2].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Joints[2].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Joints[2].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Joints[2].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Joints[2].name = \"joint2\";
  parameter Real m.wheel.Joints[2].nA[1] = 1.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[2].nA[2] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[2].nA[3] = 0.0 \"Axis in body A local\";
  parameter Real m.wheel.Joints[2].nB[1] = 0.3090169943749475 \"Axis in body B local\";
  parameter Real m.wheel.Joints[2].nB[2] = 0.9510565162951536 \"Axis in body B local\";
  parameter Real m.wheel.Joints[2].nB[3] = 0.0 \"Axis in body B local\";
  parameter Real m.wheel.Joints[2].rA[1](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[2].rA[2](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[2].rA[3](quantity = \"Length\", unit = \"m\") = 0.0 \"Axis position in body A local\";
  parameter Real m.wheel.Joints[2].rB[1](quantity = \"Length\", unit = \"m\") = 0.03847104421469068 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[2].rB[2](quantity = \"Length\", unit = \"m\") = -0.0125 \"Axis position in body B local\";
  parameter Real m.wheel.Joints[2].rB[3](quantity = \"Length\", unit = \"m\") = -0.0 \"Axis position in body B local\";
  Real m.wheel.Joints[2].RA[1](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[2].RA[2](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[2].RA[3](quantity = \"Length\", unit = \"m\") \"Axis position in body A global\";
  Real m.wheel.Joints[2].RB[1](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[2].RB[2](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[2].RB[3](quantity = \"Length\", unit = \"m\") \"Axis position in body B global\";
  Real m.wheel.Joints[2].vA[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[2].vA[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[2].vA[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body A global\";
  Real m.wheel.Joints[2].vB[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[2].vB[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[2].vB[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity of axis point in body B global\";
  Real m.wheel.Joints[2].lambda(quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration along the axis\";
  Real m.wheel.Joints[2].mu(quantity = \"AngularVelocity\", unit = \"rad/s\") \"Relative angular velocity along the axis\";
  Real m.wheel.Joints[2].angle \"Relative angle. Beware numerical error accumulation!\";
  Real m.wheel.Joints[2].epsilonr[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[2].epsilonr[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[2].epsilonr[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Relative angular acceleration\";
  Real m.wheel.Joints[2].nAi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[2].nAi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[2].nAi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body A\";
  Real m.wheel.Joints[2].nBi[1] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[2].nBi[2] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[2].nBi[3] \"Unit vector of joint axis w.r.t. the inertial frame, def by body B\";
  Real m.wheel.Joints[2].M(quantity = \"Torque\", unit = \"N.m\") \"Torque about joint axis\";
  Real m.wheel.Wheel.OutPort.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Wheel.OutPort.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Wheel.OutPort.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Wheel.OutPort.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.OutPort.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.OutPort.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.OutPort.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.OutPort.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.OutPort.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.OutPort.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Wheel.OutPort.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Wheel.OutPort.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Wheel.OutPort.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Wheel.OutPort.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.OutPort.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.OutPort.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter String m.wheel.Wheel.name = \"wheel hub\";
  parameter Real m.wheel.Wheel.m(quantity = \"Mass\", unit = \"kg\", min = 0.0, start = 9.999999999999999e+59) = 0.15 \"Mass of the body\";
  parameter Real m.wheel.Wheel.I[1,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 6.261017161132568e-05 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[1,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[1,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[2,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[2,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 6.261017161132568e-05 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[2,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[3,1](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[3,2](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0 \"Central tensor of inertia of the body\";
  parameter Real m.wheel.Wheel.I[3,3](quantity = \"MomentOfInertia\", unit = \"kg.m2\", start = 9.999999999999999e+59) = 0.0001227203432226514 \"Central tensor of inertia of the body\";
  Real m.wheel.Wheel.r[1](quantity = \"Length\", unit = \"m\", start = 0.0) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Wheel.r[2](quantity = \"Length\", unit = \"m\", start = 0.05) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Wheel.r[3](quantity = \"Length\", unit = \"m\", start = 0.0) \"Radius vector of masscenter in global coords\";
  Real m.wheel.Wheel.v[1](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.v[2](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.v[3](quantity = \"Velocity\", unit = \"m/s\", start = 0.0) \"Velocity vector of masscenter\";
  Real m.wheel.Wheel.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Wheel.q[1](start = 1.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Wheel.q[2](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Wheel.q[3](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Wheel.q[4](start = 0.0) \"Quaternion of body orientation.  QToT(q) * local = global.  E.g. QRot(pi/6, { 0, 0, 1 }) means this body is rotated clockwise along the third axis (normal to the screen) by pi/6\";
  Real m.wheel.Wheel.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Wheel.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Wheel.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\", start = 0.0) \"Vector of angular rate in local coords\";
  Real m.wheel.Wheel.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Wheel.F[1](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Wheel.F[2](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Wheel.F[3](quantity = \"Force\", unit = \"N\", start = 9.999999999999999e+59) \"Sum of all forces applied\";
  Real m.wheel.Wheel.M[1](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Wheel.M[2](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Wheel.M[3](quantity = \"Torque\", unit = \"N.m\", start = 9.999999999999999e+59) \"Sum of all torques applied\";
  Real m.wheel.Wheel.T[1,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[1,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[1,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[2,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[2,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[2,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[3,1] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[3,2] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.T[3,3] \"Matrix of rotation. T * local = global, cols = coords of local base in global\";
  Real m.wheel.Wheel.Active(start = 1.0) \"Flag of active dynamics\";
  parameter Integer m.wheel.Wheel.N = 3;
  parameter Real m.wheel.Wheel.Gravity[1](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0;
  parameter Real m.wheel.Wheel.Gravity[2](quantity = \"Acceleration\", unit = \"m/s2\") = -1.0;
  parameter Real m.wheel.Wheel.Gravity[3](quantity = \"Acceleration\", unit = \"m/s2\") = 0.0;
  Real m.wheel.Wheel.InPorts[1].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[1].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[1].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[1].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[1].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[1].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[1].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[1].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[1].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[2].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[2].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[2].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[2].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[2].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[2].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[2].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[2].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[2].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[3].P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[3].P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[3].P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Wheel.InPorts[3].F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[3].F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[3].F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Wheel.InPorts[3].M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[3].M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.InPorts[3].M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Wheel.crosses[1,1];
  Real m.wheel.Wheel.crosses[1,2];
  Real m.wheel.Wheel.crosses[1,3];
  Real m.wheel.Wheel.crosses[2,1];
  Real m.wheel.Wheel.crosses[2,2];
  Real m.wheel.Wheel.crosses[2,3];
  Real m.wheel.Wheel.crosses[3,1];
  Real m.wheel.Wheel.crosses[3,2];
  Real m.wheel.Wheel.crosses[3,3];
  Real m.wheel.InPortF.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.InPortF.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.InPortF.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.InPortF.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.InPortF.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.InPortF.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.InPortF.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.InPortF.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.InPortF.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.OutPortK.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.OutPortK.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.OutPortK.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.OutPortK.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.OutPortK.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.OutPortK.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.OutPortK.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.OutPortK.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.OutPortK.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.OutPortK.T[1,1] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[1,2] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[1,3] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[2,1] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[2,2] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[2,3] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[3,1] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[3,2] \"Matrix of rotation\";
  Real m.wheel.OutPortK.T[3,3] \"Matrix of rotation\";
  Real m.wheel.OutPortK.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.OutPortK.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.OutPortK.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.OutPortK.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.OutPortK.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.OutPortK.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  parameter Integer m.wheel.Contacts[1].ConstraintNo = 1;
  Real m.wheel.Contacts[1].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[1].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[1].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[1].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[1].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[1].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[1].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[1].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[1].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[1].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[1].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[1].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[1].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[1].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[1].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[1].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[1].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[1].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[1].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[1].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[1].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[1].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[1].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[1].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[1].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[1].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[1].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Contacts[1].name = \"wheel.Contacts[1]\";
  parameter Integer m.wheel.Contacts[1].n = 5 \"Number of rollers\";
  parameter Real m.wheel.Contacts[1].R = 0.05 \"Omni wheel outer radius (ellipse small axis)\";
  parameter Real m.wheel.Contacts[1].psi = 0.0 \"Angle of roller distortion (fixed axis turn)\";
  parameter Real m.wheel.Contacts[1].alpha = 0.6283185307179586 \"Max angle of the half-sector\";
  parameter Real m.wheel.Contacts[1].Q = 0.05 \"Ellipse large axis\";
  parameter Real m.wheel.Contacts[1].R1 = 0.04045084971874738 \"Omni wheel inner radius\";
  parameter Real m.wheel.Contacts[1].L1 = 0.02938926261462366 \"Half roller visible (projection) length\";
  parameter Real m.wheel.Contacts[1].L2 = 0.02938926261462366 \"Half roller length\";
  parameter Real m.wheel.Contacts[1].nA[1] = 0.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real m.wheel.Contacts[1].nA[2] = 1.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real m.wheel.Contacts[1].nA[3] = 0.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real m.wheel.Contacts[1].gradAtRollerTip[1] = 23.51141009169892;
  parameter Real m.wheel.Contacts[1].gradAtRollerTip[2] = 32.3606797749979;
  parameter Real m.wheel.Contacts[1].n_at_max[1] = 0.587785252292473 \"Normal to ellipse in local coord (it is in vert plane)\";
  parameter Real m.wheel.Contacts[1].n_at_max[2] = 0.8090169943749475 \"Normal to ellipse in local coord (it is in vert plane)\";
  parameter Real m.wheel.Contacts[1].i[1] = 1.0 \"Roller axis of symmetry unit vector\";
  parameter Real m.wheel.Contacts[1].i[2] = 0.0 \"Roller axis of symmetry unit vector\";
  parameter Real m.wheel.Contacts[1].i[3] = 0.0 \"Roller axis of symmetry unit vector\";
  parameter Real m.wheel.Contacts[1].cos_of_max = 0.8090169943749475;
  Real m.wheel.Contacts[1].rA[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].rA[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].rA[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].rB[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].rB[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].rB[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[1].ni[1] \"Roller axis in global coords\";
  Real m.wheel.Contacts[1].ni[2] \"Roller axis in global coords\";
  Real m.wheel.Contacts[1].ni[3] \"Roller axis in global coords\";
  Real m.wheel.Contacts[1].crs[1] \"horizontal ni cross vertical\";
  Real m.wheel.Contacts[1].crs[2] \"horizontal ni cross vertical\";
  Real m.wheel.Contacts[1].crs[3] \"horizontal ni cross vertical\";
  Real m.wheel.Contacts[1].nk[1] \"Horizontal (along crs)\";
  Real m.wheel.Contacts[1].nk[2] \"Horizontal (along crs)\";
  Real m.wheel.Contacts[1].nk[3] \"Horizontal (along crs)\";
  Real m.wheel.Contacts[1].n1j[1] \"In vertical direction (= nA)\";
  Real m.wheel.Contacts[1].n1j[2] \"In vertical direction (= nA)\";
  Real m.wheel.Contacts[1].n1j[3] \"In vertical direction (= nA)\";
  Real m.wheel.Contacts[1].n1k[1] \"Horizontal wheel axis, delivered from above\";
  Real m.wheel.Contacts[1].n1k[2] \"Horizontal wheel axis, delivered from above\";
  Real m.wheel.Contacts[1].n1k[3] \"Horizontal wheel axis, delivered from above\";
  Real m.wheel.Contacts[1].lambda \"Parameter to be computed\";
  Real m.wheel.Contacts[1].rho[1] \"Unit vector between mass centers\";
  Real m.wheel.Contacts[1].rho[2] \"Unit vector between mass centers\";
  Real m.wheel.Contacts[1].rho[3] \"Unit vector between mass centers\";
  Real m.wheel.Contacts[1].OBPB[1];
  Real m.wheel.Contacts[1].OBPB[2];
  Real m.wheel.Contacts[1].OBPB[3];
  Real m.wheel.Contacts[1].j;
  Real m.wheel.Contacts[1].cosBtwAxisAndVert;
  Real m.wheel.Contacts[1].vA[1];
  Real m.wheel.Contacts[1].vA[2];
  Real m.wheel.Contacts[1].vA[3];
  Real m.wheel.Contacts[1].vB[1];
  Real m.wheel.Contacts[1].vB[2];
  Real m.wheel.Contacts[1].vB[3];
  Real m.wheel.Contacts[1].relv[1];
  Real m.wheel.Contacts[1].relv[2];
  Real m.wheel.Contacts[1].relv[3];
  Real m.wheel.Contacts[1].relvn;
  Real m.wheel.Contacts[1].vAn;
  Real m.wheel.Contacts[1].vBn;
  Real m.wheel.Contacts[1].vAt[1];
  Real m.wheel.Contacts[1].vAt[2];
  Real m.wheel.Contacts[1].vAt[3];
  Real m.wheel.Contacts[1].vBt[1];
  Real m.wheel.Contacts[1].vBt[2];
  Real m.wheel.Contacts[1].vBt[3];
  Real m.wheel.Contacts[1].relvt[1];
  Real m.wheel.Contacts[1].relvt[2];
  Real m.wheel.Contacts[1].relvt[3];
  Real m.wheel.Contacts[1].relvtsqrt;
  parameter Real m.wheel.Contacts[1].delta = 1e-06;
  parameter Real m.wheel.Contacts[1].fric = 0.1;
  Real m.wheel.Contacts[1].mu;
  Real m.wheel.Contacts[1].Forcet[1];
  Real m.wheel.Contacts[1].Forcet[2];
  Real m.wheel.Contacts[1].Forcet[3];
  Real m.wheel.Contacts[1].Drelvn;
  Real m.wheel.Contacts[1].Forcen;
  Real m.wheel.Contacts[1].isInContact;
  parameter Integer m.wheel.Contacts[2].ConstraintNo = 1;
  Real m.wheel.Contacts[2].InPortA.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[2].InPortA.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortA.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[2].InPortA.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[2].InPortA.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[2].InPortA.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[2].InPortA.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[2].InPortA.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[2].OutPortA.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].OutPortA.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].OutPortA.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].OutPortA.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[2].OutPortA.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[2].OutPortA.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[2].OutPortA.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[2].OutPortA.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[2].OutPortA.M[3](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[2].InPortB.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.Contacts[2].InPortB.T[1,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.T[1,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.T[1,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.T[2,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.T[2,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.T[2,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.T[3,1] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.T[3,2] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.T[3,3] \"Matrix of rotation\";
  Real m.wheel.Contacts[2].InPortB.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[2].InPortB.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[2].InPortB.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.Contacts[2].InPortB.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[2].InPortB.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[2].InPortB.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.Contacts[2].OutPortB.P[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].OutPortB.P[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].OutPortB.P[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].OutPortB.F[1](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[2].OutPortB.F[2](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[2].OutPortB.F[3](quantity = \"Force\", unit = \"N\");
  Real m.wheel.Contacts[2].OutPortB.M[1](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[2].OutPortB.M[2](quantity = \"Torque\", unit = \"N.m\");
  Real m.wheel.Contacts[2].OutPortB.M[3](quantity = \"Torque\", unit = \"N.m\");
  parameter String m.wheel.Contacts[2].name = \"wheel.Contacts[2]\";
  parameter Integer m.wheel.Contacts[2].n = 5 \"Number of rollers\";
  parameter Real m.wheel.Contacts[2].R = 0.05 \"Omni wheel outer radius (ellipse small axis)\";
  parameter Real m.wheel.Contacts[2].psi = 0.0 \"Angle of roller distortion (fixed axis turn)\";
  parameter Real m.wheel.Contacts[2].alpha = 0.6283185307179586 \"Max angle of the half-sector\";
  parameter Real m.wheel.Contacts[2].Q = 0.05 \"Ellipse large axis\";
  parameter Real m.wheel.Contacts[2].R1 = 0.04045084971874738 \"Omni wheel inner radius\";
  parameter Real m.wheel.Contacts[2].L1 = 0.02938926261462366 \"Half roller visible (projection) length\";
  parameter Real m.wheel.Contacts[2].L2 = 0.02938926261462366 \"Half roller length\";
  parameter Real m.wheel.Contacts[2].nA[1] = 0.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real m.wheel.Contacts[2].nA[2] = 1.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real m.wheel.Contacts[2].nA[3] = 0.0 \"Roller over horizontal surface: vertical unit vector (in global coordinates)\";
  parameter Real m.wheel.Contacts[2].gradAtRollerTip[1] = 23.51141009169892;
  parameter Real m.wheel.Contacts[2].gradAtRollerTip[2] = 32.3606797749979;
  parameter Real m.wheel.Contacts[2].n_at_max[1] = 0.587785252292473 \"Normal to ellipse in local coord (it is in vert plane)\";
  parameter Real m.wheel.Contacts[2].n_at_max[2] = 0.8090169943749475 \"Normal to ellipse in local coord (it is in vert plane)\";
  parameter Real m.wheel.Contacts[2].i[1] = 1.0 \"Roller axis of symmetry unit vector\";
  parameter Real m.wheel.Contacts[2].i[2] = 0.0 \"Roller axis of symmetry unit vector\";
  parameter Real m.wheel.Contacts[2].i[3] = 0.0 \"Roller axis of symmetry unit vector\";
  parameter Real m.wheel.Contacts[2].cos_of_max = 0.8090169943749475;
  Real m.wheel.Contacts[2].rA[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].rA[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].rA[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].rB[1](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].rB[2](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].rB[3](quantity = \"Length\", unit = \"m\");
  Real m.wheel.Contacts[2].ni[1] \"Roller axis in global coords\";
  Real m.wheel.Contacts[2].ni[2] \"Roller axis in global coords\";
  Real m.wheel.Contacts[2].ni[3] \"Roller axis in global coords\";
  Real m.wheel.Contacts[2].crs[1] \"horizontal ni cross vertical\";
  Real m.wheel.Contacts[2].crs[2] \"horizontal ni cross vertical\";
  Real m.wheel.Contacts[2].crs[3] \"horizontal ni cross vertical\";
  Real m.wheel.Contacts[2].nk[1] \"Horizontal (along crs)\";
  Real m.wheel.Contacts[2].nk[2] \"Horizontal (along crs)\";
  Real m.wheel.Contacts[2].nk[3] \"Horizontal (along crs)\";
  Real m.wheel.Contacts[2].n1j[1] \"In vertical direction (= nA)\";
  Real m.wheel.Contacts[2].n1j[2] \"In vertical direction (= nA)\";
  Real m.wheel.Contacts[2].n1j[3] \"In vertical direction (= nA)\";
  Real m.wheel.Contacts[2].n1k[1] \"Horizontal wheel axis, delivered from above\";
  Real m.wheel.Contacts[2].n1k[2] \"Horizontal wheel axis, delivered from above\";
  Real m.wheel.Contacts[2].n1k[3] \"Horizontal wheel axis, delivered from above\";
  Real m.wheel.Contacts[2].lambda \"Parameter to be computed\";
  Real m.wheel.Contacts[2].rho[1] \"Unit vector between mass centers\";
  Real m.wheel.Contacts[2].rho[2] \"Unit vector between mass centers\";
  Real m.wheel.Contacts[2].rho[3] \"Unit vector between mass centers\";
  Real m.wheel.Contacts[2].OBPB[1];
  Real m.wheel.Contacts[2].OBPB[2];
  Real m.wheel.Contacts[2].OBPB[3];
  Real m.wheel.Contacts[2].j;
  Real m.wheel.Contacts[2].cosBtwAxisAndVert;
  Real m.wheel.Contacts[2].vA[1];
  Real m.wheel.Contacts[2].vA[2];
  Real m.wheel.Contacts[2].vA[3];
  Real m.wheel.Contacts[2].vB[1];
  Real m.wheel.Contacts[2].vB[2];
  Real m.wheel.Contacts[2].vB[3];
  Real m.wheel.Contacts[2].relv[1];
  Real m.wheel.Contacts[2].relv[2];
  Real m.wheel.Contacts[2].relv[3];
  Real m.wheel.Contacts[2].relvn;
  Real m.wheel.Contacts[2].vAn;
  Real m.wheel.Contacts[2].vBn;
  Real m.wheel.Contacts[2].vAt[1];
  Real m.wheel.Contacts[2].vAt[2];
  Real m.wheel.Contacts[2].vAt[3];
  Real m.wheel.Contacts[2].vBt[1];
  Real m.wheel.Contacts[2].vBt[2];
  Real m.wheel.Contacts[2].vBt[3];
  Real m.wheel.Contacts[2].relvt[1];
  Real m.wheel.Contacts[2].relvt[2];
  Real m.wheel.Contacts[2].relvt[3];
  Real m.wheel.Contacts[2].relvtsqrt;
  parameter Real m.wheel.Contacts[2].delta = 1e-06;
  parameter Real m.wheel.Contacts[2].fric = 0.1;
  Real m.wheel.Contacts[2].mu;
  Real m.wheel.Contacts[2].Forcet[1];
  Real m.wheel.Contacts[2].Forcet[2];
  Real m.wheel.Contacts[2].Forcet[3];
  Real m.wheel.Contacts[2].Drelvn;
  Real m.wheel.Contacts[2].Forcen;
  Real m.wheel.Contacts[2].isInContact;
  Real m.wheel.InPortK.r[1](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.InPortK.r[2](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.InPortK.r[3](quantity = \"Length\", unit = \"m\") \"Radius vector of masscenter\";
  Real m.wheel.InPortK.v[1](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.InPortK.v[2](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.InPortK.v[3](quantity = \"Velocity\", unit = \"m/s\") \"Velocity vector of masscenter\";
  Real m.wheel.InPortK.a[1](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.InPortK.a[2](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.InPortK.a[3](quantity = \"Acceleration\", unit = \"m/s2\") \"Acceleration vector of masscenter\";
  Real m.wheel.InPortK.T[1,1] \"Matrix of rotation\";
  Real m.wheel.InPortK.T[1,2] \"Matrix of rotation\";
  Real m.wheel.InPortK.T[1,3] \"Matrix of rotation\";
  Real m.wheel.InPortK.T[2,1] \"Matrix of rotation\";
  Real m.wheel.InPortK.T[2,2] \"Matrix of rotation\";
  Real m.wheel.InPortK.T[2,3] \"Matrix of rotation\";
  Real m.wheel.InPortK.T[3,1] \"Matrix of rotation\";
  Real m.wheel.InPortK.T[3,2] \"Matrix of rotation\";
  Real m.wheel.InPortK.T[3,3] \"Matrix of rotation\";
  Real m.wheel.InPortK.omega[1](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.InPortK.omega[2](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.InPortK.omega[3](quantity = \"AngularVelocity\", unit = \"rad/s\") \"Vector of angular rate\";
  Real m.wheel.InPortK.epsilon[1](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.InPortK.epsilon[2](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.wheel.InPortK.epsilon[3](quantity = \"AngularAcceleration\", unit = \"rad/s2\") \"Vector of angular acceleration\";
  Real m.torque;
  Real m.epsilonNaklon;
  Real m.omegaNaklon;
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Rollers[1].q[1] ^ 2.0 + m.wheel.Rollers[1].q[2] ^ 2.0 + m.wheel.Rollers[1].q[3] ^ 2.0 + m.wheel.Rollers[1].q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Rollers[1].q[1] ^ 2.0 + m.wheel.Rollers[1].q[2] ^ 2.0 + m.wheel.Rollers[1].q[3] ^ 2.0 + m.wheel.Rollers[1].q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Rollers[1].q[1], m.wheel.Rollers[1].q[2], m.wheel.Rollers[1].q[3], m.wheel.Rollers[1].q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].r[1], m.wheel.Rollers[1].r[2], m.wheel.Rollers[1].r[3]}, \"r\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].v[1], m.wheel.Rollers[1].v[2], m.wheel.Rollers[1].v[3]}, \"v\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].q[1], m.wheel.Rollers[1].q[2], m.wheel.Rollers[1].q[3], m.wheel.Rollers[1].q[4]}, \"q\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].omega[1], m.wheel.Rollers[1].omega[2], m.wheel.Rollers[1].omega[3]}, \"omega\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].F[1], m.wheel.Rollers[1].F[2], m.wheel.Rollers[1].F[3]}, \"F\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[1]\", {m.wheel.Rollers[1].M[1], m.wheel.Rollers[1].M[2], m.wheel.Rollers[1].M[3]}, \"M\");
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Rollers[2].q[1] ^ 2.0 + m.wheel.Rollers[2].q[2] ^ 2.0 + m.wheel.Rollers[2].q[3] ^ 2.0 + m.wheel.Rollers[2].q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Rollers[2].q[1] ^ 2.0 + m.wheel.Rollers[2].q[2] ^ 2.0 + m.wheel.Rollers[2].q[3] ^ 2.0 + m.wheel.Rollers[2].q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Rollers[2].q[1], m.wheel.Rollers[2].q[2], m.wheel.Rollers[2].q[3], m.wheel.Rollers[2].q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].r[1], m.wheel.Rollers[2].r[2], m.wheel.Rollers[2].r[3]}, \"r\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].v[1], m.wheel.Rollers[2].v[2], m.wheel.Rollers[2].v[3]}, \"v\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].q[1], m.wheel.Rollers[2].q[2], m.wheel.Rollers[2].q[3], m.wheel.Rollers[2].q[4]}, \"q\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].omega[1], m.wheel.Rollers[2].omega[2], m.wheel.Rollers[2].omega[3]}, \"omega\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].F[1], m.wheel.Rollers[2].F[2], m.wheel.Rollers[2].F[3]}, \"F\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel.Rollers[2]\", {m.wheel.Rollers[2].M[1], m.wheel.Rollers[2].M[2], m.wheel.Rollers[2].M[3]}, \"M\");
initial algorithm

initial algorithm
  assert(MbsLite.Util.CompareReal(m.wheel.Wheel.q[1] ^ 2.0 + m.wheel.Wheel.q[2] ^ 2.0 + m.wheel.Wheel.q[3] ^ 2.0 + m.wheel.Wheel.q[4] ^ 2.0, 1.0, 1e-10, 1e-05), \"Quaternion of body orientation should have norm 1, was: \" + String(m.wheel.Wheel.q[1] ^ 2.0 + m.wheel.Wheel.q[2] ^ 2.0 + m.wheel.Wheel.q[3] ^ 2.0 + m.wheel.Wheel.q[4] ^ 2.0, 0, true, 6) + \", q = \" + MbsLite.Util.StringA({m.wheel.Wheel.q[1], m.wheel.Wheel.q[2], m.wheel.Wheel.q[3], m.wheel.Wheel.q[4]}, \", \") + \". Are the initial conditions specified?\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.r[1], m.wheel.Wheel.r[2], m.wheel.Wheel.r[3]}, \"r\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.v[1], m.wheel.Wheel.v[2], m.wheel.Wheel.v[3]}, \"v\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.q[1], m.wheel.Wheel.q[2], m.wheel.Wheel.q[3], m.wheel.Wheel.q[4]}, \"q\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.omega[1], m.wheel.Wheel.omega[2], m.wheel.Wheel.omega[3]}, \"omega\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.F[1], m.wheel.Wheel.F[2], m.wheel.Wheel.F[3]}, \"F\");
  MbsLite.Util.Assert.AssertInitialized(\"wheel hub\", {m.wheel.Wheel.M[1], m.wheel.Wheel.M[2], m.wheel.Wheel.M[3]}, \"M\");
initial algorithm

initial algorithm

initial algorithm
equation
  m.base.OutPort.r[1] = 0.0;
  m.base.OutPort.r[2] = 0.0;
  m.base.OutPort.r[3] = 0.0;
  m.base.OutPort.v[1] = 0.0;
  m.base.OutPort.v[2] = 0.0;
  m.base.OutPort.v[3] = 0.0;
  m.base.OutPort.a[1] = 0.0;
  m.base.OutPort.a[2] = 0.0;
  m.base.OutPort.a[3] = 0.0;
  m.base.OutPort.T[1,1] = 1.0;
  m.base.OutPort.T[1,2] = 0.0;
  m.base.OutPort.T[1,3] = 0.0;
  m.base.OutPort.T[2,1] = 0.0;
  m.base.OutPort.T[2,2] = 1.0;
  m.base.OutPort.T[2,3] = 0.0;
  m.base.OutPort.T[3,1] = 0.0;
  m.base.OutPort.T[3,2] = 0.0;
  m.base.OutPort.T[3,3] = 1.0;
  m.base.OutPort.omega[1] = 0.0;
  m.base.OutPort.omega[2] = 0.0;
  m.base.OutPort.omega[3] = 0.0;
  m.base.OutPort.epsilon[1] = 0.0;
  m.base.OutPort.epsilon[2] = 0.0;
  m.base.OutPort.epsilon[3] = 0.0;
  m.wheel.Rollers[1].crosses[1,1] = (m.wheel.Rollers[1].InPorts[1].P[2] - m.wheel.Rollers[1].r[2]) * m.wheel.Rollers[1].InPorts[1].F[3] - (m.wheel.Rollers[1].InPorts[1].P[3] - m.wheel.Rollers[1].r[3]) * m.wheel.Rollers[1].InPorts[1].F[2];
  m.wheel.Rollers[1].crosses[1,2] = (m.wheel.Rollers[1].InPorts[1].P[3] - m.wheel.Rollers[1].r[3]) * m.wheel.Rollers[1].InPorts[1].F[1] - (m.wheel.Rollers[1].InPorts[1].P[1] - m.wheel.Rollers[1].r[1]) * m.wheel.Rollers[1].InPorts[1].F[3];
  m.wheel.Rollers[1].crosses[1,3] = (m.wheel.Rollers[1].InPorts[1].P[1] - m.wheel.Rollers[1].r[1]) * m.wheel.Rollers[1].InPorts[1].F[2] - (m.wheel.Rollers[1].InPorts[1].P[2] - m.wheel.Rollers[1].r[2]) * m.wheel.Rollers[1].InPorts[1].F[1];
  m.wheel.Rollers[1].crosses[2,1] = (m.wheel.Rollers[1].InPorts[2].P[2] - m.wheel.Rollers[1].r[2]) * m.wheel.Rollers[1].InPorts[2].F[3] - (m.wheel.Rollers[1].InPorts[2].P[3] - m.wheel.Rollers[1].r[3]) * m.wheel.Rollers[1].InPorts[2].F[2];
  m.wheel.Rollers[1].crosses[2,2] = (m.wheel.Rollers[1].InPorts[2].P[3] - m.wheel.Rollers[1].r[3]) * m.wheel.Rollers[1].InPorts[2].F[1] - (m.wheel.Rollers[1].InPorts[2].P[1] - m.wheel.Rollers[1].r[1]) * m.wheel.Rollers[1].InPorts[2].F[3];
  m.wheel.Rollers[1].crosses[2,3] = (m.wheel.Rollers[1].InPorts[2].P[1] - m.wheel.Rollers[1].r[1]) * m.wheel.Rollers[1].InPorts[2].F[2] - (m.wheel.Rollers[1].InPorts[2].P[2] - m.wheel.Rollers[1].r[2]) * m.wheel.Rollers[1].InPorts[2].F[1];
  m.wheel.Rollers[1].F[1] = m.wheel.Rollers[1].InPorts[1].F[1] + m.wheel.Rollers[1].InPorts[2].F[1];
  m.wheel.Rollers[1].F[2] = -0.05 + m.wheel.Rollers[1].InPorts[1].F[2] + m.wheel.Rollers[1].InPorts[2].F[2];
  m.wheel.Rollers[1].F[3] = m.wheel.Rollers[1].InPorts[1].F[3] + m.wheel.Rollers[1].InPorts[2].F[3];
  m.wheel.Rollers[1].M[1] = m.wheel.Rollers[1].InPorts[1].M[1] + m.wheel.Rollers[1].crosses[1,1] + m.wheel.Rollers[1].InPorts[2].M[1] + m.wheel.Rollers[1].crosses[2,1];
  m.wheel.Rollers[1].M[2] = m.wheel.Rollers[1].InPorts[1].M[2] + m.wheel.Rollers[1].crosses[1,2] + m.wheel.Rollers[1].InPorts[2].M[2] + m.wheel.Rollers[1].crosses[2,2];
  m.wheel.Rollers[1].M[3] = m.wheel.Rollers[1].InPorts[1].M[3] + m.wheel.Rollers[1].crosses[1,3] + m.wheel.Rollers[1].InPorts[2].M[3] + m.wheel.Rollers[1].crosses[2,3];
  der(m.wheel.Rollers[1].Active) = 0.0;
  der(m.wheel.Rollers[1].r[1]) = m.wheel.Rollers[1].v[1] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].r[2]) = m.wheel.Rollers[1].v[2] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].r[3]) = m.wheel.Rollers[1].v[3] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].v[1]) = m.wheel.Rollers[1].a[1] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].v[2]) = m.wheel.Rollers[1].a[2] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].v[3]) = m.wheel.Rollers[1].a[3] * m.wheel.Rollers[1].Active;
  m.wheel.Rollers[1].a[1] * 0.05 = m.wheel.Rollers[1].F[1];
  m.wheel.Rollers[1].a[2] * 0.05 = m.wheel.Rollers[1].F[2];
  m.wheel.Rollers[1].a[3] * 0.05 = m.wheel.Rollers[1].F[3];
  {der(m.wheel.Rollers[1].q[1]), der(m.wheel.Rollers[1].q[2]), der(m.wheel.Rollers[1].q[3]), der(m.wheel.Rollers[1].q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Rollers[1].q[1], m.wheel.Rollers[1].q[2], m.wheel.Rollers[1].q[3], m.wheel.Rollers[1].q[4]}, {0.0, m.wheel.Rollers[1].omega[1], m.wheel.Rollers[1].omega[2], m.wheel.Rollers[1].omega[3]}) * 0.5 * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].omega[1]) = m.wheel.Rollers[1].epsilon[1] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].omega[2]) = m.wheel.Rollers[1].epsilon[2] * m.wheel.Rollers[1].Active;
  der(m.wheel.Rollers[1].omega[3]) = m.wheel.Rollers[1].epsilon[3] * m.wheel.Rollers[1].Active;
  m.wheel.Rollers[1].T = MbsLite.Util.Quaternions.QToT({m.wheel.Rollers[1].q[1], m.wheel.Rollers[1].q[2], m.wheel.Rollers[1].q[3], m.wheel.Rollers[1].q[4]});
  5.699141943371693e-07 * m.wheel.Rollers[1].epsilon[1] = m.wheel.Rollers[1].T[1,1] * m.wheel.Rollers[1].M[1] + m.wheel.Rollers[1].T[2,1] * m.wheel.Rollers[1].M[2] + m.wheel.Rollers[1].T[3,1] * m.wheel.Rollers[1].M[3];
  1.468043638102385e-05 * m.wheel.Rollers[1].epsilon[2] + m.wheel.Rollers[1].omega[3] * 5.699141943371693e-07 * m.wheel.Rollers[1].omega[1] - m.wheel.Rollers[1].omega[1] * 1.468043638102385e-05 * m.wheel.Rollers[1].omega[3] = m.wheel.Rollers[1].T[1,2] * m.wheel.Rollers[1].M[1] + m.wheel.Rollers[1].T[2,2] * m.wheel.Rollers[1].M[2] + m.wheel.Rollers[1].T[3,2] * m.wheel.Rollers[1].M[3];
  1.468043638102385e-05 * m.wheel.Rollers[1].epsilon[3] + m.wheel.Rollers[1].omega[1] * 1.468043638102385e-05 * m.wheel.Rollers[1].omega[2] - m.wheel.Rollers[1].omega[2] * 5.699141943371693e-07 * m.wheel.Rollers[1].omega[1] = m.wheel.Rollers[1].T[1,3] * m.wheel.Rollers[1].M[1] + m.wheel.Rollers[1].T[2,3] * m.wheel.Rollers[1].M[2] + m.wheel.Rollers[1].T[3,3] * m.wheel.Rollers[1].M[3];
  m.wheel.Rollers[1].OutPort.r[1] = m.wheel.Rollers[1].r[1];
  m.wheel.Rollers[1].OutPort.r[2] = m.wheel.Rollers[1].r[2];
  m.wheel.Rollers[1].OutPort.r[3] = m.wheel.Rollers[1].r[3];
  m.wheel.Rollers[1].OutPort.v[1] = m.wheel.Rollers[1].v[1];
  m.wheel.Rollers[1].OutPort.v[2] = m.wheel.Rollers[1].v[2];
  m.wheel.Rollers[1].OutPort.v[3] = m.wheel.Rollers[1].v[3];
  m.wheel.Rollers[1].OutPort.a[1] = m.wheel.Rollers[1].a[1];
  m.wheel.Rollers[1].OutPort.a[2] = m.wheel.Rollers[1].a[2];
  m.wheel.Rollers[1].OutPort.a[3] = m.wheel.Rollers[1].a[3];
  m.wheel.Rollers[1].OutPort.T[1,1] = m.wheel.Rollers[1].T[1,1];
  m.wheel.Rollers[1].OutPort.T[1,2] = m.wheel.Rollers[1].T[1,2];
  m.wheel.Rollers[1].OutPort.T[1,3] = m.wheel.Rollers[1].T[1,3];
  m.wheel.Rollers[1].OutPort.T[2,1] = m.wheel.Rollers[1].T[2,1];
  m.wheel.Rollers[1].OutPort.T[2,2] = m.wheel.Rollers[1].T[2,2];
  m.wheel.Rollers[1].OutPort.T[2,3] = m.wheel.Rollers[1].T[2,3];
  m.wheel.Rollers[1].OutPort.T[3,1] = m.wheel.Rollers[1].T[3,1];
  m.wheel.Rollers[1].OutPort.T[3,2] = m.wheel.Rollers[1].T[3,2];
  m.wheel.Rollers[1].OutPort.T[3,3] = m.wheel.Rollers[1].T[3,3];
  m.wheel.Rollers[1].OutPort.omega[1] = m.wheel.Rollers[1].T[1,1] * m.wheel.Rollers[1].omega[1] + m.wheel.Rollers[1].T[1,2] * m.wheel.Rollers[1].omega[2] + m.wheel.Rollers[1].T[1,3] * m.wheel.Rollers[1].omega[3];
  m.wheel.Rollers[1].OutPort.omega[2] = m.wheel.Rollers[1].T[2,1] * m.wheel.Rollers[1].omega[1] + m.wheel.Rollers[1].T[2,2] * m.wheel.Rollers[1].omega[2] + m.wheel.Rollers[1].T[2,3] * m.wheel.Rollers[1].omega[3];
  m.wheel.Rollers[1].OutPort.omega[3] = m.wheel.Rollers[1].T[3,1] * m.wheel.Rollers[1].omega[1] + m.wheel.Rollers[1].T[3,2] * m.wheel.Rollers[1].omega[2] + m.wheel.Rollers[1].T[3,3] * m.wheel.Rollers[1].omega[3];
  m.wheel.Rollers[1].OutPort.epsilon[1] = m.wheel.Rollers[1].T[1,1] * m.wheel.Rollers[1].epsilon[1] + m.wheel.Rollers[1].T[1,2] * m.wheel.Rollers[1].epsilon[2] + m.wheel.Rollers[1].T[1,3] * m.wheel.Rollers[1].epsilon[3];
  m.wheel.Rollers[1].OutPort.epsilon[2] = m.wheel.Rollers[1].T[2,1] * m.wheel.Rollers[1].epsilon[1] + m.wheel.Rollers[1].T[2,2] * m.wheel.Rollers[1].epsilon[2] + m.wheel.Rollers[1].T[2,3] * m.wheel.Rollers[1].epsilon[3];
  m.wheel.Rollers[1].OutPort.epsilon[3] = m.wheel.Rollers[1].T[3,1] * m.wheel.Rollers[1].epsilon[1] + m.wheel.Rollers[1].T[3,2] * m.wheel.Rollers[1].epsilon[2] + m.wheel.Rollers[1].T[3,3] * m.wheel.Rollers[1].epsilon[3];
  m.wheel.Rollers[2].crosses[1,1] = (m.wheel.Rollers[2].InPorts[1].P[2] - m.wheel.Rollers[2].r[2]) * m.wheel.Rollers[2].InPorts[1].F[3] - (m.wheel.Rollers[2].InPorts[1].P[3] - m.wheel.Rollers[2].r[3]) * m.wheel.Rollers[2].InPorts[1].F[2];
  m.wheel.Rollers[2].crosses[1,2] = (m.wheel.Rollers[2].InPorts[1].P[3] - m.wheel.Rollers[2].r[3]) * m.wheel.Rollers[2].InPorts[1].F[1] - (m.wheel.Rollers[2].InPorts[1].P[1] - m.wheel.Rollers[2].r[1]) * m.wheel.Rollers[2].InPorts[1].F[3];
  m.wheel.Rollers[2].crosses[1,3] = (m.wheel.Rollers[2].InPorts[1].P[1] - m.wheel.Rollers[2].r[1]) * m.wheel.Rollers[2].InPorts[1].F[2] - (m.wheel.Rollers[2].InPorts[1].P[2] - m.wheel.Rollers[2].r[2]) * m.wheel.Rollers[2].InPorts[1].F[1];
  m.wheel.Rollers[2].crosses[2,1] = (m.wheel.Rollers[2].InPorts[2].P[2] - m.wheel.Rollers[2].r[2]) * m.wheel.Rollers[2].InPorts[2].F[3] - (m.wheel.Rollers[2].InPorts[2].P[3] - m.wheel.Rollers[2].r[3]) * m.wheel.Rollers[2].InPorts[2].F[2];
  m.wheel.Rollers[2].crosses[2,2] = (m.wheel.Rollers[2].InPorts[2].P[3] - m.wheel.Rollers[2].r[3]) * m.wheel.Rollers[2].InPorts[2].F[1] - (m.wheel.Rollers[2].InPorts[2].P[1] - m.wheel.Rollers[2].r[1]) * m.wheel.Rollers[2].InPorts[2].F[3];
  m.wheel.Rollers[2].crosses[2,3] = (m.wheel.Rollers[2].InPorts[2].P[1] - m.wheel.Rollers[2].r[1]) * m.wheel.Rollers[2].InPorts[2].F[2] - (m.wheel.Rollers[2].InPorts[2].P[2] - m.wheel.Rollers[2].r[2]) * m.wheel.Rollers[2].InPorts[2].F[1];
  m.wheel.Rollers[2].F[1] = m.wheel.Rollers[2].InPorts[1].F[1] + m.wheel.Rollers[2].InPorts[2].F[1];
  m.wheel.Rollers[2].F[2] = -0.05 + m.wheel.Rollers[2].InPorts[1].F[2] + m.wheel.Rollers[2].InPorts[2].F[2];
  m.wheel.Rollers[2].F[3] = m.wheel.Rollers[2].InPorts[1].F[3] + m.wheel.Rollers[2].InPorts[2].F[3];
  m.wheel.Rollers[2].M[1] = m.wheel.Rollers[2].InPorts[1].M[1] + m.wheel.Rollers[2].crosses[1,1] + m.wheel.Rollers[2].InPorts[2].M[1] + m.wheel.Rollers[2].crosses[2,1];
  m.wheel.Rollers[2].M[2] = m.wheel.Rollers[2].InPorts[1].M[2] + m.wheel.Rollers[2].crosses[1,2] + m.wheel.Rollers[2].InPorts[2].M[2] + m.wheel.Rollers[2].crosses[2,2];
  m.wheel.Rollers[2].M[3] = m.wheel.Rollers[2].InPorts[1].M[3] + m.wheel.Rollers[2].crosses[1,3] + m.wheel.Rollers[2].InPorts[2].M[3] + m.wheel.Rollers[2].crosses[2,3];
  der(m.wheel.Rollers[2].Active) = 0.0;
  der(m.wheel.Rollers[2].r[1]) = m.wheel.Rollers[2].v[1] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].r[2]) = m.wheel.Rollers[2].v[2] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].r[3]) = m.wheel.Rollers[2].v[3] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].v[1]) = m.wheel.Rollers[2].a[1] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].v[2]) = m.wheel.Rollers[2].a[2] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].v[3]) = m.wheel.Rollers[2].a[3] * m.wheel.Rollers[2].Active;
  m.wheel.Rollers[2].a[1] * 0.05 = m.wheel.Rollers[2].F[1];
  m.wheel.Rollers[2].a[2] * 0.05 = m.wheel.Rollers[2].F[2];
  m.wheel.Rollers[2].a[3] * 0.05 = m.wheel.Rollers[2].F[3];
  {der(m.wheel.Rollers[2].q[1]), der(m.wheel.Rollers[2].q[2]), der(m.wheel.Rollers[2].q[3]), der(m.wheel.Rollers[2].q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Rollers[2].q[1], m.wheel.Rollers[2].q[2], m.wheel.Rollers[2].q[3], m.wheel.Rollers[2].q[4]}, {0.0, m.wheel.Rollers[2].omega[1], m.wheel.Rollers[2].omega[2], m.wheel.Rollers[2].omega[3]}) * 0.5 * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].omega[1]) = m.wheel.Rollers[2].epsilon[1] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].omega[2]) = m.wheel.Rollers[2].epsilon[2] * m.wheel.Rollers[2].Active;
  der(m.wheel.Rollers[2].omega[3]) = m.wheel.Rollers[2].epsilon[3] * m.wheel.Rollers[2].Active;
  m.wheel.Rollers[2].T = MbsLite.Util.Quaternions.QToT({m.wheel.Rollers[2].q[1], m.wheel.Rollers[2].q[2], m.wheel.Rollers[2].q[3], m.wheel.Rollers[2].q[4]});
  5.699141943371693e-07 * m.wheel.Rollers[2].epsilon[1] = m.wheel.Rollers[2].T[1,1] * m.wheel.Rollers[2].M[1] + m.wheel.Rollers[2].T[2,1] * m.wheel.Rollers[2].M[2] + m.wheel.Rollers[2].T[3,1] * m.wheel.Rollers[2].M[3];
  1.468043638102385e-05 * m.wheel.Rollers[2].epsilon[2] + m.wheel.Rollers[2].omega[3] * 5.699141943371693e-07 * m.wheel.Rollers[2].omega[1] - m.wheel.Rollers[2].omega[1] * 1.468043638102385e-05 * m.wheel.Rollers[2].omega[3] = m.wheel.Rollers[2].T[1,2] * m.wheel.Rollers[2].M[1] + m.wheel.Rollers[2].T[2,2] * m.wheel.Rollers[2].M[2] + m.wheel.Rollers[2].T[3,2] * m.wheel.Rollers[2].M[3];
  1.468043638102385e-05 * m.wheel.Rollers[2].epsilon[3] + m.wheel.Rollers[2].omega[1] * 1.468043638102385e-05 * m.wheel.Rollers[2].omega[2] - m.wheel.Rollers[2].omega[2] * 5.699141943371693e-07 * m.wheel.Rollers[2].omega[1] = m.wheel.Rollers[2].T[1,3] * m.wheel.Rollers[2].M[1] + m.wheel.Rollers[2].T[2,3] * m.wheel.Rollers[2].M[2] + m.wheel.Rollers[2].T[3,3] * m.wheel.Rollers[2].M[3];
  m.wheel.Rollers[2].OutPort.r[1] = m.wheel.Rollers[2].r[1];
  m.wheel.Rollers[2].OutPort.r[2] = m.wheel.Rollers[2].r[2];
  m.wheel.Rollers[2].OutPort.r[3] = m.wheel.Rollers[2].r[3];
  m.wheel.Rollers[2].OutPort.v[1] = m.wheel.Rollers[2].v[1];
  m.wheel.Rollers[2].OutPort.v[2] = m.wheel.Rollers[2].v[2];
  m.wheel.Rollers[2].OutPort.v[3] = m.wheel.Rollers[2].v[3];
  m.wheel.Rollers[2].OutPort.a[1] = m.wheel.Rollers[2].a[1];
  m.wheel.Rollers[2].OutPort.a[2] = m.wheel.Rollers[2].a[2];
  m.wheel.Rollers[2].OutPort.a[3] = m.wheel.Rollers[2].a[3];
  m.wheel.Rollers[2].OutPort.T[1,1] = m.wheel.Rollers[2].T[1,1];
  m.wheel.Rollers[2].OutPort.T[1,2] = m.wheel.Rollers[2].T[1,2];
  m.wheel.Rollers[2].OutPort.T[1,3] = m.wheel.Rollers[2].T[1,3];
  m.wheel.Rollers[2].OutPort.T[2,1] = m.wheel.Rollers[2].T[2,1];
  m.wheel.Rollers[2].OutPort.T[2,2] = m.wheel.Rollers[2].T[2,2];
  m.wheel.Rollers[2].OutPort.T[2,3] = m.wheel.Rollers[2].T[2,3];
  m.wheel.Rollers[2].OutPort.T[3,1] = m.wheel.Rollers[2].T[3,1];
  m.wheel.Rollers[2].OutPort.T[3,2] = m.wheel.Rollers[2].T[3,2];
  m.wheel.Rollers[2].OutPort.T[3,3] = m.wheel.Rollers[2].T[3,3];
  m.wheel.Rollers[2].OutPort.omega[1] = m.wheel.Rollers[2].T[1,1] * m.wheel.Rollers[2].omega[1] + m.wheel.Rollers[2].T[1,2] * m.wheel.Rollers[2].omega[2] + m.wheel.Rollers[2].T[1,3] * m.wheel.Rollers[2].omega[3];
  m.wheel.Rollers[2].OutPort.omega[2] = m.wheel.Rollers[2].T[2,1] * m.wheel.Rollers[2].omega[1] + m.wheel.Rollers[2].T[2,2] * m.wheel.Rollers[2].omega[2] + m.wheel.Rollers[2].T[2,3] * m.wheel.Rollers[2].omega[3];
  m.wheel.Rollers[2].OutPort.omega[3] = m.wheel.Rollers[2].T[3,1] * m.wheel.Rollers[2].omega[1] + m.wheel.Rollers[2].T[3,2] * m.wheel.Rollers[2].omega[2] + m.wheel.Rollers[2].T[3,3] * m.wheel.Rollers[2].omega[3];
  m.wheel.Rollers[2].OutPort.epsilon[1] = m.wheel.Rollers[2].T[1,1] * m.wheel.Rollers[2].epsilon[1] + m.wheel.Rollers[2].T[1,2] * m.wheel.Rollers[2].epsilon[2] + m.wheel.Rollers[2].T[1,3] * m.wheel.Rollers[2].epsilon[3];
  m.wheel.Rollers[2].OutPort.epsilon[2] = m.wheel.Rollers[2].T[2,1] * m.wheel.Rollers[2].epsilon[1] + m.wheel.Rollers[2].T[2,2] * m.wheel.Rollers[2].epsilon[2] + m.wheel.Rollers[2].T[2,3] * m.wheel.Rollers[2].epsilon[3];
  m.wheel.Rollers[2].OutPort.epsilon[3] = m.wheel.Rollers[2].T[3,1] * m.wheel.Rollers[2].epsilon[1] + m.wheel.Rollers[2].T[3,2] * m.wheel.Rollers[2].epsilon[2] + m.wheel.Rollers[2].T[3,3] * m.wheel.Rollers[2].epsilon[3];
  m.wheel.Joints[1].RA[1] = m.wheel.Joints[1].InPortA.r[1];
  m.wheel.Joints[1].RA[2] = m.wheel.Joints[1].InPortA.r[2];
  m.wheel.Joints[1].RA[3] = m.wheel.Joints[1].InPortA.r[3];
  m.wheel.Joints[1].RB[1] = m.wheel.Joints[1].InPortB.r[1] + m.wheel.Joints[1].InPortB.T[1,2] * -0.04045084971874738;
  m.wheel.Joints[1].RB[2] = m.wheel.Joints[1].InPortB.r[2] + m.wheel.Joints[1].InPortB.T[2,2] * -0.04045084971874738;
  m.wheel.Joints[1].RB[3] = m.wheel.Joints[1].InPortB.r[3] + m.wheel.Joints[1].InPortB.T[3,2] * -0.04045084971874738;
  m.wheel.Joints[1].vA = MbsLite.Util.Euler({m.wheel.Joints[1].InPortA.r[1], m.wheel.Joints[1].InPortA.r[2], m.wheel.Joints[1].InPortA.r[3]}, {m.wheel.Joints[1].RA[1], m.wheel.Joints[1].RA[2], m.wheel.Joints[1].RA[3]}, {m.wheel.Joints[1].InPortA.v[1], m.wheel.Joints[1].InPortA.v[2], m.wheel.Joints[1].InPortA.v[3]}, {m.wheel.Joints[1].InPortA.omega[1], m.wheel.Joints[1].InPortA.omega[2], m.wheel.Joints[1].InPortA.omega[3]});
  m.wheel.Joints[1].vB = MbsLite.Util.Euler({m.wheel.Joints[1].InPortB.r[1], m.wheel.Joints[1].InPortB.r[2], m.wheel.Joints[1].InPortB.r[3]}, {m.wheel.Joints[1].RB[1], m.wheel.Joints[1].RB[2], m.wheel.Joints[1].RB[3]}, {m.wheel.Joints[1].InPortB.v[1], m.wheel.Joints[1].InPortB.v[2], m.wheel.Joints[1].InPortB.v[3]}, {m.wheel.Joints[1].InPortB.omega[1], m.wheel.Joints[1].InPortB.omega[2], m.wheel.Joints[1].InPortB.omega[3]});
  m.wheel.Joints[1].vA[1] = m.wheel.Joints[1].vB[1];
  m.wheel.Joints[1].vA[2] = m.wheel.Joints[1].vB[2];
  m.wheel.Joints[1].vA[3] = m.wheel.Joints[1].vB[3];
  m.wheel.Joints[1].nAi[1] = m.wheel.Joints[1].InPortA.T[1,1];
  m.wheel.Joints[1].nAi[2] = m.wheel.Joints[1].InPortA.T[2,1];
  m.wheel.Joints[1].nAi[3] = m.wheel.Joints[1].InPortA.T[3,1];
  m.wheel.Joints[1].nBi[1] = m.wheel.Joints[1].InPortB.T[1,1];
  m.wheel.Joints[1].nBi[2] = m.wheel.Joints[1].InPortB.T[2,1];
  m.wheel.Joints[1].nBi[3] = m.wheel.Joints[1].InPortB.T[3,1];
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nBi[1], 1e-08, 1e-05), \"looks like joint joint1 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1], m.wheel.Joints[1].nBi[2], m.wheel.Joints[1].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1] - m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nBi[2] - m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nBi[3] - m.wheel.Joints[1].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nBi[2], 1e-08, 1e-05), \"looks like joint joint1 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1], m.wheel.Joints[1].nBi[2], m.wheel.Joints[1].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1] - m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nBi[2] - m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nBi[3] - m.wheel.Joints[1].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[1].nAi[3], m.wheel.Joints[1].nBi[3], 1e-08, 1e-05), \"looks like joint joint1 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1], m.wheel.Joints[1].nBi[2], m.wheel.Joints[1].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[1].nBi[1] - m.wheel.Joints[1].nAi[1], m.wheel.Joints[1].nBi[2] - m.wheel.Joints[1].nAi[2], m.wheel.Joints[1].nBi[3] - m.wheel.Joints[1].nAi[3]}, \", \"));
  m.wheel.Joints[1].epsilonr[1] = m.wheel.Joints[1].InPortB.epsilon[1] - m.wheel.Joints[1].InPortA.epsilon[1] - (m.wheel.Joints[1].InPortA.omega[2] * m.wheel.Joints[1].InPortB.omega[3] - m.wheel.Joints[1].InPortA.omega[3] * m.wheel.Joints[1].InPortB.omega[2]);
  m.wheel.Joints[1].epsilonr[2] = m.wheel.Joints[1].InPortB.epsilon[2] - m.wheel.Joints[1].InPortA.epsilon[2] - (m.wheel.Joints[1].InPortA.omega[3] * m.wheel.Joints[1].InPortB.omega[1] - m.wheel.Joints[1].InPortA.omega[1] * m.wheel.Joints[1].InPortB.omega[3]);
  m.wheel.Joints[1].epsilonr[3] = m.wheel.Joints[1].InPortB.epsilon[3] - m.wheel.Joints[1].InPortA.epsilon[3] - (m.wheel.Joints[1].InPortA.omega[1] * m.wheel.Joints[1].InPortB.omega[2] - m.wheel.Joints[1].InPortA.omega[2] * m.wheel.Joints[1].InPortB.omega[1]);
  m.wheel.Joints[1].epsilonr[1] = m.wheel.Joints[1].nAi[1] * m.wheel.Joints[1].lambda;
  m.wheel.Joints[1].epsilonr[2] = m.wheel.Joints[1].nAi[2] * m.wheel.Joints[1].lambda;
  m.wheel.Joints[1].epsilonr[3] = m.wheel.Joints[1].nAi[3] * m.wheel.Joints[1].lambda;
  m.wheel.Joints[1].M = m.wheel.Joints[1].OutPortA.M[1] * m.wheel.Joints[1].nAi[1] + m.wheel.Joints[1].OutPortA.M[2] * m.wheel.Joints[1].nAi[2] + m.wheel.Joints[1].OutPortA.M[3] * m.wheel.Joints[1].nAi[3];
  m.wheel.Joints[1].M = 0.0;
  m.wheel.Joints[1].OutPortA.P[1] = m.wheel.Joints[1].RA[1];
  m.wheel.Joints[1].OutPortA.P[2] = m.wheel.Joints[1].RA[2];
  m.wheel.Joints[1].OutPortA.P[3] = m.wheel.Joints[1].RA[3];
  m.wheel.Joints[1].OutPortB.P[1] = m.wheel.Joints[1].RB[1];
  m.wheel.Joints[1].OutPortB.P[2] = m.wheel.Joints[1].RB[2];
  m.wheel.Joints[1].OutPortB.P[3] = m.wheel.Joints[1].RB[3];
  der(m.wheel.Joints[1].mu) = m.wheel.Joints[1].lambda;
  der(m.wheel.Joints[1].angle) = m.wheel.Joints[1].mu;
  m.wheel.Joints[1].OutPortA.F[1] + m.wheel.Joints[1].OutPortB.F[1] = 0.0;
  m.wheel.Joints[1].OutPortA.F[2] + m.wheel.Joints[1].OutPortB.F[2] = 0.0;
  m.wheel.Joints[1].OutPortA.F[3] + m.wheel.Joints[1].OutPortB.F[3] = 0.0;
  m.wheel.Joints[1].OutPortA.M[1] + m.wheel.Joints[1].OutPortB.M[1] = 0.0;
  m.wheel.Joints[1].OutPortA.M[2] + m.wheel.Joints[1].OutPortB.M[2] = 0.0;
  m.wheel.Joints[1].OutPortA.M[3] + m.wheel.Joints[1].OutPortB.M[3] = 0.0;
  m.wheel.Joints[2].RA[1] = m.wheel.Joints[2].InPortA.r[1];
  m.wheel.Joints[2].RA[2] = m.wheel.Joints[2].InPortA.r[2];
  m.wheel.Joints[2].RA[3] = m.wheel.Joints[2].InPortA.r[3];
  m.wheel.Joints[2].RB[1] = m.wheel.Joints[2].InPortB.r[1] + m.wheel.Joints[2].InPortB.T[1,1] * 0.03847104421469068 + m.wheel.Joints[2].InPortB.T[1,2] * -0.0125;
  m.wheel.Joints[2].RB[2] = m.wheel.Joints[2].InPortB.r[2] + m.wheel.Joints[2].InPortB.T[2,1] * 0.03847104421469068 + m.wheel.Joints[2].InPortB.T[2,2] * -0.0125;
  m.wheel.Joints[2].RB[3] = m.wheel.Joints[2].InPortB.r[3] + m.wheel.Joints[2].InPortB.T[3,1] * 0.03847104421469068 + m.wheel.Joints[2].InPortB.T[3,2] * -0.0125;
  m.wheel.Joints[2].vA = MbsLite.Util.Euler({m.wheel.Joints[2].InPortA.r[1], m.wheel.Joints[2].InPortA.r[2], m.wheel.Joints[2].InPortA.r[3]}, {m.wheel.Joints[2].RA[1], m.wheel.Joints[2].RA[2], m.wheel.Joints[2].RA[3]}, {m.wheel.Joints[2].InPortA.v[1], m.wheel.Joints[2].InPortA.v[2], m.wheel.Joints[2].InPortA.v[3]}, {m.wheel.Joints[2].InPortA.omega[1], m.wheel.Joints[2].InPortA.omega[2], m.wheel.Joints[2].InPortA.omega[3]});
  m.wheel.Joints[2].vB = MbsLite.Util.Euler({m.wheel.Joints[2].InPortB.r[1], m.wheel.Joints[2].InPortB.r[2], m.wheel.Joints[2].InPortB.r[3]}, {m.wheel.Joints[2].RB[1], m.wheel.Joints[2].RB[2], m.wheel.Joints[2].RB[3]}, {m.wheel.Joints[2].InPortB.v[1], m.wheel.Joints[2].InPortB.v[2], m.wheel.Joints[2].InPortB.v[3]}, {m.wheel.Joints[2].InPortB.omega[1], m.wheel.Joints[2].InPortB.omega[2], m.wheel.Joints[2].InPortB.omega[3]});
  m.wheel.Joints[2].vA[1] = m.wheel.Joints[2].vB[1];
  m.wheel.Joints[2].vA[2] = m.wheel.Joints[2].vB[2];
  m.wheel.Joints[2].vA[3] = m.wheel.Joints[2].vB[3];
  m.wheel.Joints[2].nAi[1] = m.wheel.Joints[2].InPortA.T[1,1];
  m.wheel.Joints[2].nAi[2] = m.wheel.Joints[2].InPortA.T[2,1];
  m.wheel.Joints[2].nAi[3] = m.wheel.Joints[2].InPortA.T[3,1];
  m.wheel.Joints[2].nBi[1] = m.wheel.Joints[2].InPortB.T[1,1] * 0.3090169943749475 + m.wheel.Joints[2].InPortB.T[1,2] * 0.9510565162951536;
  m.wheel.Joints[2].nBi[2] = m.wheel.Joints[2].InPortB.T[2,1] * 0.3090169943749475 + m.wheel.Joints[2].InPortB.T[2,2] * 0.9510565162951536;
  m.wheel.Joints[2].nBi[3] = m.wheel.Joints[2].InPortB.T[3,1] * 0.3090169943749475 + m.wheel.Joints[2].InPortB.T[3,2] * 0.9510565162951536;
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nBi[1], 1e-08, 1e-05), \"looks like joint joint2 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1], m.wheel.Joints[2].nBi[2], m.wheel.Joints[2].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1] - m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nBi[2] - m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nBi[3] - m.wheel.Joints[2].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nBi[2], 1e-08, 1e-05), \"looks like joint joint2 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1], m.wheel.Joints[2].nBi[2], m.wheel.Joints[2].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1] - m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nBi[2] - m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nBi[3] - m.wheel.Joints[2].nAi[3]}, \", \"));
  assert(MbsLite.Util.CompareReal(m.wheel.Joints[2].nAi[3], m.wheel.Joints[2].nBi[3], 1e-08, 1e-05), \"looks like joint joint2 is getting worse... axes in inertial coords should be same, but were: nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nAi[3]}, \", \") + \", nBi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1], m.wheel.Joints[2].nBi[2], m.wheel.Joints[2].nBi[3]}, \", \") + \", nBi - nAi = \" + MbsLite.Util.StringA({m.wheel.Joints[2].nBi[1] - m.wheel.Joints[2].nAi[1], m.wheel.Joints[2].nBi[2] - m.wheel.Joints[2].nAi[2], m.wheel.Joints[2].nBi[3] - m.wheel.Joints[2].nAi[3]}, \", \"));
  m.wheel.Joints[2].epsilonr[1] = m.wheel.Joints[2].InPortB.epsilon[1] - m.wheel.Joints[2].InPortA.epsilon[1] - (m.wheel.Joints[2].InPortA.omega[2] * m.wheel.Joints[2].InPortB.omega[3] - m.wheel.Joints[2].InPortA.omega[3] * m.wheel.Joints[2].InPortB.omega[2]);
  m.wheel.Joints[2].epsilonr[2] = m.wheel.Joints[2].InPortB.epsilon[2] - m.wheel.Joints[2].InPortA.epsilon[2] - (m.wheel.Joints[2].InPortA.omega[3] * m.wheel.Joints[2].InPortB.omega[1] - m.wheel.Joints[2].InPortA.omega[1] * m.wheel.Joints[2].InPortB.omega[3]);
  m.wheel.Joints[2].epsilonr[3] = m.wheel.Joints[2].InPortB.epsilon[3] - m.wheel.Joints[2].InPortA.epsilon[3] - (m.wheel.Joints[2].InPortA.omega[1] * m.wheel.Joints[2].InPortB.omega[2] - m.wheel.Joints[2].InPortA.omega[2] * m.wheel.Joints[2].InPortB.omega[1]);
  m.wheel.Joints[2].epsilonr[1] = m.wheel.Joints[2].nAi[1] * m.wheel.Joints[2].lambda;
  m.wheel.Joints[2].epsilonr[2] = m.wheel.Joints[2].nAi[2] * m.wheel.Joints[2].lambda;
  m.wheel.Joints[2].epsilonr[3] = m.wheel.Joints[2].nAi[3] * m.wheel.Joints[2].lambda;
  m.wheel.Joints[2].M = m.wheel.Joints[2].OutPortA.M[1] * m.wheel.Joints[2].nAi[1] + m.wheel.Joints[2].OutPortA.M[2] * m.wheel.Joints[2].nAi[2] + m.wheel.Joints[2].OutPortA.M[3] * m.wheel.Joints[2].nAi[3];
  m.wheel.Joints[2].M = 0.0;
  m.wheel.Joints[2].OutPortA.P[1] = m.wheel.Joints[2].RA[1];
  m.wheel.Joints[2].OutPortA.P[2] = m.wheel.Joints[2].RA[2];
  m.wheel.Joints[2].OutPortA.P[3] = m.wheel.Joints[2].RA[3];
  m.wheel.Joints[2].OutPortB.P[1] = m.wheel.Joints[2].RB[1];
  m.wheel.Joints[2].OutPortB.P[2] = m.wheel.Joints[2].RB[2];
  m.wheel.Joints[2].OutPortB.P[3] = m.wheel.Joints[2].RB[3];
  der(m.wheel.Joints[2].mu) = m.wheel.Joints[2].lambda;
  der(m.wheel.Joints[2].angle) = m.wheel.Joints[2].mu;
  m.wheel.Joints[2].OutPortA.F[1] + m.wheel.Joints[2].OutPortB.F[1] = 0.0;
  m.wheel.Joints[2].OutPortA.F[2] + m.wheel.Joints[2].OutPortB.F[2] = 0.0;
  m.wheel.Joints[2].OutPortA.F[3] + m.wheel.Joints[2].OutPortB.F[3] = 0.0;
  m.wheel.Joints[2].OutPortA.M[1] + m.wheel.Joints[2].OutPortB.M[1] = 0.0;
  m.wheel.Joints[2].OutPortA.M[2] + m.wheel.Joints[2].OutPortB.M[2] = 0.0;
  m.wheel.Joints[2].OutPortA.M[3] + m.wheel.Joints[2].OutPortB.M[3] = 0.0;
  m.wheel.Wheel.crosses[1,1] = (m.wheel.Wheel.InPorts[1].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[1].F[3] - (m.wheel.Wheel.InPorts[1].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[1].F[2];
  m.wheel.Wheel.crosses[1,2] = (m.wheel.Wheel.InPorts[1].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[1].F[1] - (m.wheel.Wheel.InPorts[1].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[1].F[3];
  m.wheel.Wheel.crosses[1,3] = (m.wheel.Wheel.InPorts[1].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[1].F[2] - (m.wheel.Wheel.InPorts[1].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[1].F[1];
  m.wheel.Wheel.crosses[2,1] = (m.wheel.Wheel.InPorts[2].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[2].F[3] - (m.wheel.Wheel.InPorts[2].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[2].F[2];
  m.wheel.Wheel.crosses[2,2] = (m.wheel.Wheel.InPorts[2].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[2].F[1] - (m.wheel.Wheel.InPorts[2].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[2].F[3];
  m.wheel.Wheel.crosses[2,3] = (m.wheel.Wheel.InPorts[2].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[2].F[2] - (m.wheel.Wheel.InPorts[2].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[2].F[1];
  m.wheel.Wheel.crosses[3,1] = (m.wheel.Wheel.InPorts[3].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[3].F[3] - (m.wheel.Wheel.InPorts[3].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[3].F[2];
  m.wheel.Wheel.crosses[3,2] = (m.wheel.Wheel.InPorts[3].P[3] - m.wheel.Wheel.r[3]) * m.wheel.Wheel.InPorts[3].F[1] - (m.wheel.Wheel.InPorts[3].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[3].F[3];
  m.wheel.Wheel.crosses[3,3] = (m.wheel.Wheel.InPorts[3].P[1] - m.wheel.Wheel.r[1]) * m.wheel.Wheel.InPorts[3].F[2] - (m.wheel.Wheel.InPorts[3].P[2] - m.wheel.Wheel.r[2]) * m.wheel.Wheel.InPorts[3].F[1];
  m.wheel.Wheel.F[1] = m.wheel.Wheel.InPorts[1].F[1] + m.wheel.Wheel.InPorts[2].F[1] + m.wheel.Wheel.InPorts[3].F[1];
  m.wheel.Wheel.F[2] = -0.15 + m.wheel.Wheel.InPorts[1].F[2] + m.wheel.Wheel.InPorts[2].F[2] + m.wheel.Wheel.InPorts[3].F[2];
  m.wheel.Wheel.F[3] = m.wheel.Wheel.InPorts[1].F[3] + m.wheel.Wheel.InPorts[2].F[3] + m.wheel.Wheel.InPorts[3].F[3];
  m.wheel.Wheel.M[1] = m.wheel.Wheel.InPorts[1].M[1] + m.wheel.Wheel.crosses[1,1] + m.wheel.Wheel.InPorts[2].M[1] + m.wheel.Wheel.crosses[2,1] + m.wheel.Wheel.InPorts[3].M[1] + m.wheel.Wheel.crosses[3,1];
  m.wheel.Wheel.M[2] = m.wheel.Wheel.InPorts[1].M[2] + m.wheel.Wheel.crosses[1,2] + m.wheel.Wheel.InPorts[2].M[2] + m.wheel.Wheel.crosses[2,2] + m.wheel.Wheel.InPorts[3].M[2] + m.wheel.Wheel.crosses[3,2];
  m.wheel.Wheel.M[3] = m.wheel.Wheel.InPorts[1].M[3] + m.wheel.Wheel.crosses[1,3] + m.wheel.Wheel.InPorts[2].M[3] + m.wheel.Wheel.crosses[2,3] + m.wheel.Wheel.InPorts[3].M[3] + m.wheel.Wheel.crosses[3,3];
  der(m.wheel.Wheel.Active) = 0.0;
  der(m.wheel.Wheel.r[1]) = m.wheel.Wheel.v[1] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.r[2]) = m.wheel.Wheel.v[2] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.r[3]) = m.wheel.Wheel.v[3] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.v[1]) = m.wheel.Wheel.a[1] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.v[2]) = m.wheel.Wheel.a[2] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.v[3]) = m.wheel.Wheel.a[3] * m.wheel.Wheel.Active;
  m.wheel.Wheel.a[1] * 0.15 = m.wheel.Wheel.F[1];
  m.wheel.Wheel.a[2] * 0.15 = m.wheel.Wheel.F[2];
  m.wheel.Wheel.a[3] * 0.15 = m.wheel.Wheel.F[3];
  {der(m.wheel.Wheel.q[1]), der(m.wheel.Wheel.q[2]), der(m.wheel.Wheel.q[3]), der(m.wheel.Wheel.q[4])} = MbsLite.Util.Quaternions.QMult({m.wheel.Wheel.q[1], m.wheel.Wheel.q[2], m.wheel.Wheel.q[3], m.wheel.Wheel.q[4]}, {0.0, m.wheel.Wheel.omega[1], m.wheel.Wheel.omega[2], m.wheel.Wheel.omega[3]}) * 0.5 * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.omega[1]) = m.wheel.Wheel.epsilon[1] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.omega[2]) = m.wheel.Wheel.epsilon[2] * m.wheel.Wheel.Active;
  der(m.wheel.Wheel.omega[3]) = m.wheel.Wheel.epsilon[3] * m.wheel.Wheel.Active;
  m.wheel.Wheel.T = MbsLite.Util.Quaternions.QToT({m.wheel.Wheel.q[1], m.wheel.Wheel.q[2], m.wheel.Wheel.q[3], m.wheel.Wheel.q[4]});
  6.261017161132568e-05 * m.wheel.Wheel.epsilon[1] + m.wheel.Wheel.omega[2] * 0.0001227203432226514 * m.wheel.Wheel.omega[3] - m.wheel.Wheel.omega[3] * 6.261017161132568e-05 * m.wheel.Wheel.omega[2] = m.wheel.Wheel.T[1,1] * m.wheel.Wheel.M[1] + m.wheel.Wheel.T[2,1] * m.wheel.Wheel.M[2] + m.wheel.Wheel.T[3,1] * m.wheel.Wheel.M[3];
  6.261017161132568e-05 * m.wheel.Wheel.epsilon[2] + m.wheel.Wheel.omega[3] * 6.261017161132568e-05 * m.wheel.Wheel.omega[1] - m.wheel.Wheel.omega[1] * 0.0001227203432226514 * m.wheel.Wheel.omega[3] = m.wheel.Wheel.T[1,2] * m.wheel.Wheel.M[1] + m.wheel.Wheel.T[2,2] * m.wheel.Wheel.M[2] + m.wheel.Wheel.T[3,2] * m.wheel.Wheel.M[3];
  0.0001227203432226514 * m.wheel.Wheel.epsilon[3] = m.wheel.Wheel.T[1,3] * m.wheel.Wheel.M[1] + m.wheel.Wheel.T[2,3] * m.wheel.Wheel.M[2] + m.wheel.Wheel.T[3,3] * m.wheel.Wheel.M[3];
  m.wheel.Wheel.OutPort.r[1] = m.wheel.Wheel.r[1];
  m.wheel.Wheel.OutPort.r[2] = m.wheel.Wheel.r[2];
  m.wheel.Wheel.OutPort.r[3] = m.wheel.Wheel.r[3];
  m.wheel.Wheel.OutPort.v[1] = m.wheel.Wheel.v[1];
  m.wheel.Wheel.OutPort.v[2] = m.wheel.Wheel.v[2];
  m.wheel.Wheel.OutPort.v[3] = m.wheel.Wheel.v[3];
  m.wheel.Wheel.OutPort.a[1] = m.wheel.Wheel.a[1];
  m.wheel.Wheel.OutPort.a[2] = m.wheel.Wheel.a[2];
  m.wheel.Wheel.OutPort.a[3] = m.wheel.Wheel.a[3];
  m.wheel.Wheel.OutPort.T[1,1] = m.wheel.Wheel.T[1,1];
  m.wheel.Wheel.OutPort.T[1,2] = m.wheel.Wheel.T[1,2];
  m.wheel.Wheel.OutPort.T[1,3] = m.wheel.Wheel.T[1,3];
  m.wheel.Wheel.OutPort.T[2,1] = m.wheel.Wheel.T[2,1];
  m.wheel.Wheel.OutPort.T[2,2] = m.wheel.Wheel.T[2,2];
  m.wheel.Wheel.OutPort.T[2,3] = m.wheel.Wheel.T[2,3];
  m.wheel.Wheel.OutPort.T[3,1] = m.wheel.Wheel.T[3,1];
  m.wheel.Wheel.OutPort.T[3,2] = m.wheel.Wheel.T[3,2];
  m.wheel.Wheel.OutPort.T[3,3] = m.wheel.Wheel.T[3,3];
  m.wheel.Wheel.OutPort.omega[1] = m.wheel.Wheel.T[1,1] * m.wheel.Wheel.omega[1] + m.wheel.Wheel.T[1,2] * m.wheel.Wheel.omega[2] + m.wheel.Wheel.T[1,3] * m.wheel.Wheel.omega[3];
  m.wheel.Wheel.OutPort.omega[2] = m.wheel.Wheel.T[2,1] * m.wheel.Wheel.omega[1] + m.wheel.Wheel.T[2,2] * m.wheel.Wheel.omega[2] + m.wheel.Wheel.T[2,3] * m.wheel.Wheel.omega[3];
  m.wheel.Wheel.OutPort.omega[3] = m.wheel.Wheel.T[3,1] * m.wheel.Wheel.omega[1] + m.wheel.Wheel.T[3,2] * m.wheel.Wheel.omega[2] + m.wheel.Wheel.T[3,3] * m.wheel.Wheel.omega[3];
  m.wheel.Wheel.OutPort.epsilon[1] = m.wheel.Wheel.T[1,1] * m.wheel.Wheel.epsilon[1] + m.wheel.Wheel.T[1,2] * m.wheel.Wheel.epsilon[2] + m.wheel.Wheel.T[1,3] * m.wheel.Wheel.epsilon[3];
  m.wheel.Wheel.OutPort.epsilon[2] = m.wheel.Wheel.T[2,1] * m.wheel.Wheel.epsilon[1] + m.wheel.Wheel.T[2,2] * m.wheel.Wheel.epsilon[2] + m.wheel.Wheel.T[2,3] * m.wheel.Wheel.epsilon[3];
  m.wheel.Wheel.OutPort.epsilon[3] = m.wheel.Wheel.T[3,1] * m.wheel.Wheel.epsilon[1] + m.wheel.Wheel.T[3,2] * m.wheel.Wheel.epsilon[2] + m.wheel.Wheel.T[3,3] * m.wheel.Wheel.epsilon[3];
  if noEvent(abs(m.wheel.Contacts[1].cosBtwAxisAndVert) < 0.8090169943749475) and noEvent(m.wheel.Contacts[1].InPortB.r[2] < 0.05) then
    m.wheel.Contacts[1].isInContact = 1.0;
    m.wheel.Contacts[1].Drelvn = 0.0;
    m.wheel.Contacts[1].Forcet[1] = (-m.wheel.Contacts[1].relvt[1]) * 0.1 * (if noEvent(m.wheel.Contacts[1].relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / m.wheel.Contacts[1].relvtsqrt) * m.wheel.Contacts[1].Forcen;
    m.wheel.Contacts[1].Forcet[2] = m.wheel.Contacts[1].mu - m.wheel.Contacts[1].relvt[2] * 0.1 * (if noEvent(m.wheel.Contacts[1].relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / m.wheel.Contacts[1].relvtsqrt) * m.wheel.Contacts[1].Forcen;
    m.wheel.Contacts[1].Forcet[3] = (-m.wheel.Contacts[1].relvt[3]) * 0.1 * (if noEvent(m.wheel.Contacts[1].relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / m.wheel.Contacts[1].relvtsqrt) * m.wheel.Contacts[1].Forcen;
  else
    m.wheel.Contacts[1].isInContact = 0.0;
    m.wheel.Contacts[1].Forcen = 0.0;
    m.wheel.Contacts[1].Forcet[1] = 0.0;
    m.wheel.Contacts[1].Forcet[2] = 0.0;
    m.wheel.Contacts[1].Forcet[3] = 0.0;
  end if;
  m.wheel.Contacts[1].Drelvn = der(m.wheel.Contacts[1].relvn);
  m.wheel.Contacts[1].Forcen = m.wheel.Contacts[1].OutPortB.F[2];
  m.wheel.Contacts[1].OutPortB.F[1] = m.wheel.Contacts[1].Forcet[1];
  m.wheel.Contacts[1].OutPortB.F[2] = m.wheel.Contacts[1].Forcet[2] + m.wheel.Contacts[1].Forcen;
  m.wheel.Contacts[1].OutPortB.F[3] = m.wheel.Contacts[1].Forcet[3];
  m.wheel.Contacts[1].OutPortB.M[1] = 0.0;
  m.wheel.Contacts[1].OutPortB.M[2] = 0.0;
  m.wheel.Contacts[1].OutPortB.M[3] = 0.0;
  m.wheel.Contacts[1].vA = MbsLite.Util.Euler({m.wheel.Contacts[1].InPortA.r[1], m.wheel.Contacts[1].InPortA.r[2], m.wheel.Contacts[1].InPortA.r[3]}, {m.wheel.Contacts[1].rA[1], m.wheel.Contacts[1].rA[2], m.wheel.Contacts[1].rA[3]}, {m.wheel.Contacts[1].InPortA.v[1], m.wheel.Contacts[1].InPortA.v[2], m.wheel.Contacts[1].InPortA.v[3]}, {m.wheel.Contacts[1].InPortA.omega[1], m.wheel.Contacts[1].InPortA.omega[2], m.wheel.Contacts[1].InPortA.omega[3]});
  m.wheel.Contacts[1].vB = MbsLite.Util.Euler({m.wheel.Contacts[1].InPortB.r[1], m.wheel.Contacts[1].InPortB.r[2], m.wheel.Contacts[1].InPortB.r[3]}, {m.wheel.Contacts[1].rB[1], m.wheel.Contacts[1].rB[2], m.wheel.Contacts[1].rB[3]}, {m.wheel.Contacts[1].InPortB.v[1], m.wheel.Contacts[1].InPortB.v[2], m.wheel.Contacts[1].InPortB.v[3]}, {m.wheel.Contacts[1].InPortB.omega[1], m.wheel.Contacts[1].InPortB.omega[2], m.wheel.Contacts[1].InPortB.omega[3]});
  m.wheel.Contacts[1].relv[1] = m.wheel.Contacts[1].vB[1] - m.wheel.Contacts[1].vA[1];
  m.wheel.Contacts[1].relv[2] = m.wheel.Contacts[1].vB[2] - m.wheel.Contacts[1].vA[2];
  m.wheel.Contacts[1].relv[3] = m.wheel.Contacts[1].vB[3] - m.wheel.Contacts[1].vA[3];
  m.wheel.Contacts[1].vAn = m.wheel.Contacts[1].vA[2];
  m.wheel.Contacts[1].vBn = m.wheel.Contacts[1].vB[2];
  m.wheel.Contacts[1].relvn = m.wheel.Contacts[1].relv[2];
  m.wheel.Contacts[1].vAt[1] = m.wheel.Contacts[1].vA[1];
  m.wheel.Contacts[1].vAt[2] = m.wheel.Contacts[1].vA[2] - m.wheel.Contacts[1].vAn;
  m.wheel.Contacts[1].vAt[3] = m.wheel.Contacts[1].vA[3];
  m.wheel.Contacts[1].vBt[1] = m.wheel.Contacts[1].vB[1];
  m.wheel.Contacts[1].vBt[2] = m.wheel.Contacts[1].vB[2] - m.wheel.Contacts[1].vBn;
  m.wheel.Contacts[1].vBt[3] = m.wheel.Contacts[1].vB[3];
  m.wheel.Contacts[1].relvt[1] = m.wheel.Contacts[1].vBt[1] - m.wheel.Contacts[1].vAt[1];
  m.wheel.Contacts[1].relvt[2] = m.wheel.Contacts[1].vBt[2] - m.wheel.Contacts[1].vAt[2];
  m.wheel.Contacts[1].relvt[3] = m.wheel.Contacts[1].vBt[3] - m.wheel.Contacts[1].vAt[3];
  m.wheel.Contacts[1].relvtsqrt = Modelica.Math.Vectors.norm({m.wheel.Contacts[1].relvt[1], m.wheel.Contacts[1].relvt[2], m.wheel.Contacts[1].relvt[3]}, 2.0);
  m.wheel.Contacts[1].OutPortA.P[1] = m.wheel.Contacts[1].rA[1];
  m.wheel.Contacts[1].OutPortA.P[2] = m.wheel.Contacts[1].rA[2];
  m.wheel.Contacts[1].OutPortA.P[3] = m.wheel.Contacts[1].rA[3];
  m.wheel.Contacts[1].OutPortB.P[1] = m.wheel.Contacts[1].rB[1];
  m.wheel.Contacts[1].OutPortB.P[2] = m.wheel.Contacts[1].rB[2];
  m.wheel.Contacts[1].OutPortB.P[3] = m.wheel.Contacts[1].rB[3];
  m.wheel.Contacts[1].n1j[1] = 0.0;
  m.wheel.Contacts[1].n1j[2] = 1.0;
  m.wheel.Contacts[1].n1j[3] = 0.0;
  m.wheel.Contacts[1].ni[1] = m.wheel.Contacts[1].InPortB.T[1,1];
  m.wheel.Contacts[1].ni[2] = m.wheel.Contacts[1].InPortB.T[2,1];
  m.wheel.Contacts[1].ni[3] = m.wheel.Contacts[1].InPortB.T[3,1];
  m.wheel.Contacts[1].crs[1] = -m.wheel.Contacts[1].ni[3];
  m.wheel.Contacts[1].crs[2] = 0.0;
  m.wheel.Contacts[1].crs[3] = m.wheel.Contacts[1].ni[1];
  m.wheel.Contacts[1].nk[1] = m.wheel.Contacts[1].crs[1] / sqrt(m.wheel.Contacts[1].crs[1] ^ 2.0 + m.wheel.Contacts[1].crs[2] ^ 2.0 + m.wheel.Contacts[1].crs[3] ^ 2.0);
  m.wheel.Contacts[1].nk[2] = m.wheel.Contacts[1].crs[2] / sqrt(m.wheel.Contacts[1].crs[1] ^ 2.0 + m.wheel.Contacts[1].crs[2] ^ 2.0 + m.wheel.Contacts[1].crs[3] ^ 2.0);
  m.wheel.Contacts[1].nk[3] = m.wheel.Contacts[1].crs[3] / sqrt(m.wheel.Contacts[1].crs[1] ^ 2.0 + m.wheel.Contacts[1].crs[2] ^ 2.0 + m.wheel.Contacts[1].crs[3] ^ 2.0);
  m.wheel.Contacts[1].cosBtwAxisAndVert = m.wheel.Contacts[1].ni[2];
  if noEvent(abs(m.wheel.Contacts[1].cosBtwAxisAndVert) < 0.8090169943749475) and noEvent(m.wheel.Contacts[1].InPortB.r[2] < 0.05) then
    m.wheel.Contacts[1].lambda = (0.05 * (m.wheel.Contacts[1].n1j[1] * m.wheel.Contacts[1].nk[1] + m.wheel.Contacts[1].n1j[2] * m.wheel.Contacts[1].nk[2] + m.wheel.Contacts[1].n1j[3] * m.wheel.Contacts[1].nk[3]) + -0.04045084971874738 * (m.wheel.Contacts[1].rho[1] * m.wheel.Contacts[1].nk[1] + m.wheel.Contacts[1].rho[2] * m.wheel.Contacts[1].nk[2] + m.wheel.Contacts[1].rho[3] * m.wheel.Contacts[1].nk[3])) / (m.wheel.Contacts[1].n1k[1] * m.wheel.Contacts[1].nk[1] + m.wheel.Contacts[1].n1k[2] * m.wheel.Contacts[1].nk[2] + m.wheel.Contacts[1].n1k[3] * m.wheel.Contacts[1].nk[3]);
    m.wheel.Contacts[1].OBPB[1] = m.wheel.Contacts[1].n1k[1] * m.wheel.Contacts[1].lambda - m.wheel.Contacts[1].n1j[1] * 0.05 + m.wheel.Contacts[1].rho[1] * 0.04045084971874738;
    m.wheel.Contacts[1].OBPB[2] = m.wheel.Contacts[1].n1k[2] * m.wheel.Contacts[1].lambda - m.wheel.Contacts[1].n1j[2] * 0.05 + m.wheel.Contacts[1].rho[2] * 0.04045084971874738;
    m.wheel.Contacts[1].OBPB[3] = m.wheel.Contacts[1].n1k[3] * m.wheel.Contacts[1].lambda - m.wheel.Contacts[1].n1j[3] * 0.05 + m.wheel.Contacts[1].rho[3] * 0.04045084971874738;
    m.wheel.Contacts[1].rB[1] = m.wheel.Contacts[1].InPortB.r[1] + m.wheel.Contacts[1].OBPB[1];
    m.wheel.Contacts[1].rB[2] = m.wheel.Contacts[1].InPortB.r[2] + m.wheel.Contacts[1].OBPB[2];
    m.wheel.Contacts[1].rB[3] = m.wheel.Contacts[1].InPortB.r[3] + m.wheel.Contacts[1].OBPB[3];
    m.wheel.Contacts[1].j = 1.0;
  else
    m.wheel.Contacts[1].lambda = 0.05 * (m.wheel.Contacts[1].n1j[1] * m.wheel.Contacts[1].nk[1] + m.wheel.Contacts[1].n1j[2] * m.wheel.Contacts[1].nk[2] + m.wheel.Contacts[1].n1j[3] * m.wheel.Contacts[1].nk[3]) / (m.wheel.Contacts[1].n1k[1] * m.wheel.Contacts[1].nk[1] + m.wheel.Contacts[1].n1k[2] * m.wheel.Contacts[1].nk[2] + m.wheel.Contacts[1].n1k[3] * m.wheel.Contacts[1].nk[3]);
    m.wheel.Contacts[1].OBPB[1] = (-m.wheel.Contacts[1].n1j[1]) * 0.05;
    m.wheel.Contacts[1].OBPB[2] = (-m.wheel.Contacts[1].n1j[2]) * 0.05;
    m.wheel.Contacts[1].OBPB[3] = (-m.wheel.Contacts[1].n1j[3]) * 0.05;
    if noEvent(m.wheel.Contacts[1].cosBtwAxisAndVert > 0.0) then
      m.wheel.Contacts[1].rB[1] = m.wheel.Contacts[1].InPortB.r[1] - m.wheel.Contacts[1].ni[1] * 0.02938926261462366;
      m.wheel.Contacts[1].rB[2] = m.wheel.Contacts[1].InPortB.r[2] - m.wheel.Contacts[1].ni[2] * 0.02938926261462366;
      m.wheel.Contacts[1].rB[3] = m.wheel.Contacts[1].InPortB.r[3] - m.wheel.Contacts[1].ni[3] * 0.02938926261462366;
      m.wheel.Contacts[1].j = 2.0;
    else
      m.wheel.Contacts[1].rB[1] = m.wheel.Contacts[1].InPortB.r[1] + m.wheel.Contacts[1].ni[1] * 0.02938926261462366;
      m.wheel.Contacts[1].rB[2] = m.wheel.Contacts[1].InPortB.r[2] + m.wheel.Contacts[1].ni[2] * 0.02938926261462366;
      m.wheel.Contacts[1].rB[3] = m.wheel.Contacts[1].InPortB.r[3] + m.wheel.Contacts[1].ni[3] * 0.02938926261462366;
      m.wheel.Contacts[1].j = 3.0;
    end if;
  end if;
  m.wheel.Contacts[1].rA[1] = m.wheel.Contacts[1].rB[1];
  m.wheel.Contacts[1].rA[2] = 0.0;
  m.wheel.Contacts[1].rA[3] = m.wheel.Contacts[1].rB[3];
  m.wheel.Contacts[1].OutPortA.F[1] + m.wheel.Contacts[1].OutPortB.F[1] = 0.0;
  m.wheel.Contacts[1].OutPortA.F[2] + m.wheel.Contacts[1].OutPortB.F[2] = 0.0;
  m.wheel.Contacts[1].OutPortA.F[3] + m.wheel.Contacts[1].OutPortB.F[3] = 0.0;
  m.wheel.Contacts[1].OutPortA.M[1] + m.wheel.Contacts[1].OutPortB.M[1] = 0.0;
  m.wheel.Contacts[1].OutPortA.M[2] + m.wheel.Contacts[1].OutPortB.M[2] = 0.0;
  m.wheel.Contacts[1].OutPortA.M[3] + m.wheel.Contacts[1].OutPortB.M[3] = 0.0;
  if noEvent(abs(m.wheel.Contacts[2].cosBtwAxisAndVert) < 0.8090169943749475) and noEvent(m.wheel.Contacts[2].InPortB.r[2] < 0.05) then
    m.wheel.Contacts[2].isInContact = 1.0;
    m.wheel.Contacts[2].Drelvn = 0.0;
    m.wheel.Contacts[2].Forcet[1] = (-m.wheel.Contacts[2].relvt[1]) * 0.1 * (if noEvent(m.wheel.Contacts[2].relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / m.wheel.Contacts[2].relvtsqrt) * m.wheel.Contacts[2].Forcen;
    m.wheel.Contacts[2].Forcet[2] = m.wheel.Contacts[2].mu - m.wheel.Contacts[2].relvt[2] * 0.1 * (if noEvent(m.wheel.Contacts[2].relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / m.wheel.Contacts[2].relvtsqrt) * m.wheel.Contacts[2].Forcen;
    m.wheel.Contacts[2].Forcet[3] = (-m.wheel.Contacts[2].relvt[3]) * 0.1 * (if noEvent(m.wheel.Contacts[2].relvtsqrt <= 1e-06) then 1000000.0 else 1.0 / m.wheel.Contacts[2].relvtsqrt) * m.wheel.Contacts[2].Forcen;
  else
    m.wheel.Contacts[2].isInContact = 0.0;
    m.wheel.Contacts[2].Forcen = 0.0;
    m.wheel.Contacts[2].Forcet[1] = 0.0;
    m.wheel.Contacts[2].Forcet[2] = 0.0;
    m.wheel.Contacts[2].Forcet[3] = 0.0;
  end if;
  m.wheel.Contacts[2].Drelvn = der(m.wheel.Contacts[2].relvn);
  m.wheel.Contacts[2].Forcen = m.wheel.Contacts[2].OutPortB.F[2];
  m.wheel.Contacts[2].OutPortB.F[1] = m.wheel.Contacts[2].Forcet[1];
  m.wheel.Contacts[2].OutPortB.F[2] = m.wheel.Contacts[2].Forcet[2] + m.wheel.Contacts[2].Forcen;
  m.wheel.Contacts[2].OutPortB.F[3] = m.wheel.Contacts[2].Forcet[3];
  m.wheel.Contacts[2].OutPortB.M[1] = 0.0;
  m.wheel.Contacts[2].OutPortB.M[2] = 0.0;
  m.wheel.Contacts[2].OutPortB.M[3] = 0.0;
  m.wheel.Contacts[2].vA = MbsLite.Util.Euler({m.wheel.Contacts[2].InPortA.r[1], m.wheel.Contacts[2].InPortA.r[2], m.wheel.Contacts[2].InPortA.r[3]}, {m.wheel.Contacts[2].rA[1], m.wheel.Contacts[2].rA[2], m.wheel.Contacts[2].rA[3]}, {m.wheel.Contacts[2].InPortA.v[1], m.wheel.Contacts[2].InPortA.v[2], m.wheel.Contacts[2].InPortA.v[3]}, {m.wheel.Contacts[2].InPortA.omega[1], m.wheel.Contacts[2].InPortA.omega[2], m.wheel.Contacts[2].InPortA.omega[3]});
  m.wheel.Contacts[2].vB = MbsLite.Util.Euler({m.wheel.Contacts[2].InPortB.r[1], m.wheel.Contacts[2].InPortB.r[2], m.wheel.Contacts[2].InPortB.r[3]}, {m.wheel.Contacts[2].rB[1], m.wheel.Contacts[2].rB[2], m.wheel.Contacts[2].rB[3]}, {m.wheel.Contacts[2].InPortB.v[1], m.wheel.Contacts[2].InPortB.v[2], m.wheel.Contacts[2].InPortB.v[3]}, {m.wheel.Contacts[2].InPortB.omega[1], m.wheel.Contacts[2].InPortB.omega[2], m.wheel.Contacts[2].InPortB.omega[3]});
  m.wheel.Contacts[2].relv[1] = m.wheel.Contacts[2].vB[1] - m.wheel.Contacts[2].vA[1];
  m.wheel.Contacts[2].relv[2] = m.wheel.Contacts[2].vB[2] - m.wheel.Contacts[2].vA[2];
  m.wheel.Contacts[2].relv[3] = m.wheel.Contacts[2].vB[3] - m.wheel.Contacts[2].vA[3];
  m.wheel.Contacts[2].vAn = m.wheel.Contacts[2].vA[2];
  m.wheel.Contacts[2].vBn = m.wheel.Contacts[2].vB[2];
  m.wheel.Contacts[2].relvn = m.wheel.Contacts[2].relv[2];
  m.wheel.Contacts[2].vAt[1] = m.wheel.Contacts[2].vA[1];
  m.wheel.Contacts[2].vAt[2] = m.wheel.Contacts[2].vA[2] - m.wheel.Contacts[2].vAn;
  m.wheel.Contacts[2].vAt[3] = m.wheel.Contacts[2].vA[3];
  m.wheel.Contacts[2].vBt[1] = m.wheel.Contacts[2].vB[1];
  m.wheel.Contacts[2].vBt[2] = m.wheel.Contacts[2].vB[2] - m.wheel.Contacts[2].vBn;
  m.wheel.Contacts[2].vBt[3] = m.wheel.Contacts[2].vB[3];
  m.wheel.Contacts[2].relvt[1] = m.wheel.Contacts[2].vBt[1] - m.wheel.Contacts[2].vAt[1];
  m.wheel.Contacts[2].relvt[2] = m.wheel.Contacts[2].vBt[2] - m.wheel.Contacts[2].vAt[2];
  m.wheel.Contacts[2].relvt[3] = m.wheel.Contacts[2].vBt[3] - m.wheel.Contacts[2].vAt[3];
  m.wheel.Contacts[2].relvtsqrt = Modelica.Math.Vectors.norm({m.wheel.Contacts[2].relvt[1], m.wheel.Contacts[2].relvt[2], m.wheel.Contacts[2].relvt[3]}, 2.0);
  m.wheel.Contacts[2].OutPortA.P[1] = m.wheel.Contacts[2].rA[1];
  m.wheel.Contacts[2].OutPortA.P[2] = m.wheel.Contacts[2].rA[2];
  m.wheel.Contacts[2].OutPortA.P[3] = m.wheel.Contacts[2].rA[3];
  m.wheel.Contacts[2].OutPortB.P[1] = m.wheel.Contacts[2].rB[1];
  m.wheel.Contacts[2].OutPortB.P[2] = m.wheel.Contacts[2].rB[2];
  m.wheel.Contacts[2].OutPortB.P[3] = m.wheel.Contacts[2].rB[3];
  m.wheel.Contacts[2].n1j[1] = 0.0;
  m.wheel.Contacts[2].n1j[2] = 1.0;
  m.wheel.Contacts[2].n1j[3] = 0.0;
  m.wheel.Contacts[2].ni[1] = m.wheel.Contacts[2].InPortB.T[1,1];
  m.wheel.Contacts[2].ni[2] = m.wheel.Contacts[2].InPortB.T[2,1];
  m.wheel.Contacts[2].ni[3] = m.wheel.Contacts[2].InPortB.T[3,1];
  m.wheel.Contacts[2].crs[1] = -m.wheel.Contacts[2].ni[3];
  m.wheel.Contacts[2].crs[2] = 0.0;
  m.wheel.Contacts[2].crs[3] = m.wheel.Contacts[2].ni[1];
  m.wheel.Contacts[2].nk[1] = m.wheel.Contacts[2].crs[1] / sqrt(m.wheel.Contacts[2].crs[1] ^ 2.0 + m.wheel.Contacts[2].crs[2] ^ 2.0 + m.wheel.Contacts[2].crs[3] ^ 2.0);
  m.wheel.Contacts[2].nk[2] = m.wheel.Contacts[2].crs[2] / sqrt(m.wheel.Contacts[2].crs[1] ^ 2.0 + m.wheel.Contacts[2].crs[2] ^ 2.0 + m.wheel.Contacts[2].crs[3] ^ 2.0);
  m.wheel.Contacts[2].nk[3] = m.wheel.Contacts[2].crs[3] / sqrt(m.wheel.Contacts[2].crs[1] ^ 2.0 + m.wheel.Contacts[2].crs[2] ^ 2.0 + m.wheel.Contacts[2].crs[3] ^ 2.0);
  m.wheel.Contacts[2].cosBtwAxisAndVert = m.wheel.Contacts[2].ni[2];
  if noEvent(abs(m.wheel.Contacts[2].cosBtwAxisAndVert) < 0.8090169943749475) and noEvent(m.wheel.Contacts[2].InPortB.r[2] < 0.05) then
    m.wheel.Contacts[2].lambda = (0.05 * (m.wheel.Contacts[2].n1j[1] * m.wheel.Contacts[2].nk[1] + m.wheel.Contacts[2].n1j[2] * m.wheel.Contacts[2].nk[2] + m.wheel.Contacts[2].n1j[3] * m.wheel.Contacts[2].nk[3]) + -0.04045084971874738 * (m.wheel.Contacts[2].rho[1] * m.wheel.Contacts[2].nk[1] + m.wheel.Contacts[2].rho[2] * m.wheel.Contacts[2].nk[2] + m.wheel.Contacts[2].rho[3] * m.wheel.Contacts[2].nk[3])) / (m.wheel.Contacts[2].n1k[1] * m.wheel.Contacts[2].nk[1] + m.wheel.Contacts[2].n1k[2] * m.wheel.Contacts[2].nk[2] + m.wheel.Contacts[2].n1k[3] * m.wheel.Contacts[2].nk[3]);
    m.wheel.Contacts[2].OBPB[1] = m.wheel.Contacts[2].n1k[1] * m.wheel.Contacts[2].lambda - m.wheel.Contacts[2].n1j[1] * 0.05 + m.wheel.Contacts[2].rho[1] * 0.04045084971874738;
    m.wheel.Contacts[2].OBPB[2] = m.wheel.Contacts[2].n1k[2] * m.wheel.Contacts[2].lambda - m.wheel.Contacts[2].n1j[2] * 0.05 + m.wheel.Contacts[2].rho[2] * 0.04045084971874738;
    m.wheel.Contacts[2].OBPB[3] = m.wheel.Contacts[2].n1k[3] * m.wheel.Contacts[2].lambda - m.wheel.Contacts[2].n1j[3] * 0.05 + m.wheel.Contacts[2].rho[3] * 0.04045084971874738;
    m.wheel.Contacts[2].rB[1] = m.wheel.Contacts[2].InPortB.r[1] + m.wheel.Contacts[2].OBPB[1];
    m.wheel.Contacts[2].rB[2] = m.wheel.Contacts[2].InPortB.r[2] + m.wheel.Contacts[2].OBPB[2];
    m.wheel.Contacts[2].rB[3] = m.wheel.Contacts[2].InPortB.r[3] + m.wheel.Contacts[2].OBPB[3];
    m.wheel.Contacts[2].j = 1.0;
  else
    m.wheel.Contacts[2].lambda = 0.05 * (m.wheel.Contacts[2].n1j[1] * m.wheel.Contacts[2].nk[1] + m.wheel.Contacts[2].n1j[2] * m.wheel.Contacts[2].nk[2] + m.wheel.Contacts[2].n1j[3] * m.wheel.Contacts[2].nk[3]) / (m.wheel.Contacts[2].n1k[1] * m.wheel.Contacts[2].nk[1] + m.wheel.Contacts[2].n1k[2] * m.wheel.Contacts[2].nk[2] + m.wheel.Contacts[2].n1k[3] * m.wheel.Contacts[2].nk[3]);
    m.wheel.Contacts[2].OBPB[1] = (-m.wheel.Contacts[2].n1j[1]) * 0.05;
    m.wheel.Contacts[2].OBPB[2] = (-m.wheel.Contacts[2].n1j[2]) * 0.05;
    m.wheel.Contacts[2].OBPB[3] = (-m.wheel.Contacts[2].n1j[3]) * 0.05;
    if noEvent(m.wheel.Contacts[2].cosBtwAxisAndVert > 0.0) then
      m.wheel.Contacts[2].rB[1] = m.wheel.Contacts[2].InPortB.r[1] - m.wheel.Contacts[2].ni[1] * 0.02938926261462366;
      m.wheel.Contacts[2].rB[2] = m.wheel.Contacts[2].InPortB.r[2] - m.wheel.Contacts[2].ni[2] * 0.02938926261462366;
      m.wheel.Contacts[2].rB[3] = m.wheel.Contacts[2].InPortB.r[3] - m.wheel.Contacts[2].ni[3] * 0.02938926261462366;
      m.wheel.Contacts[2].j = 2.0;
    else
      m.wheel.Contacts[2].rB[1] = m.wheel.Contacts[2].InPortB.r[1] + m.wheel.Contacts[2].ni[1] * 0.02938926261462366;
      m.wheel.Contacts[2].rB[2] = m.wheel.Contacts[2].InPortB.r[2] + m.wheel.Contacts[2].ni[2] * 0.02938926261462366;
      m.wheel.Contacts[2].rB[3] = m.wheel.Contacts[2].InPortB.r[3] + m.wheel.Contacts[2].ni[3] * 0.02938926261462366;
      m.wheel.Contacts[2].j = 3.0;
    end if;
  end if;
  m.wheel.Contacts[2].rA[1] = m.wheel.Contacts[2].rB[1];
  m.wheel.Contacts[2].rA[2] = 0.0;
  m.wheel.Contacts[2].rA[3] = m.wheel.Contacts[2].rB[3];
  m.wheel.Contacts[2].OutPortA.F[1] + m.wheel.Contacts[2].OutPortB.F[1] = 0.0;
  m.wheel.Contacts[2].OutPortA.F[2] + m.wheel.Contacts[2].OutPortB.F[2] = 0.0;
  m.wheel.Contacts[2].OutPortA.F[3] + m.wheel.Contacts[2].OutPortB.F[3] = 0.0;
  m.wheel.Contacts[2].OutPortA.M[1] + m.wheel.Contacts[2].OutPortB.M[1] = 0.0;
  m.wheel.Contacts[2].OutPortA.M[2] + m.wheel.Contacts[2].OutPortB.M[2] = 0.0;
  m.wheel.Contacts[2].OutPortA.M[3] + m.wheel.Contacts[2].OutPortB.M[3] = 0.0;
  m.wheel.Contacts[1].n1k[1] = m.wheel.Wheel.T[1,3];
  m.wheel.Contacts[1].n1k[2] = m.wheel.Wheel.T[2,3];
  m.wheel.Contacts[1].n1k[3] = m.wheel.Wheel.T[3,3];
  m.wheel.Contacts[1].rho[1] = (m.wheel.Wheel.r[1] - m.wheel.Rollers[1].r[1]) / sqrt((m.wheel.Wheel.r[1] - m.wheel.Rollers[1].r[1]) ^ 2.0 + (m.wheel.Wheel.r[2] - m.wheel.Rollers[1].r[2]) ^ 2.0 + (m.wheel.Wheel.r[3] - m.wheel.Rollers[1].r[3]) ^ 2.0);
  m.wheel.Contacts[1].rho[2] = (m.wheel.Wheel.r[2] - m.wheel.Rollers[1].r[2]) / sqrt((m.wheel.Wheel.r[1] - m.wheel.Rollers[1].r[1]) ^ 2.0 + (m.wheel.Wheel.r[2] - m.wheel.Rollers[1].r[2]) ^ 2.0 + (m.wheel.Wheel.r[3] - m.wheel.Rollers[1].r[3]) ^ 2.0);
  m.wheel.Contacts[1].rho[3] = (m.wheel.Wheel.r[3] - m.wheel.Rollers[1].r[3]) / sqrt((m.wheel.Wheel.r[1] - m.wheel.Rollers[1].r[1]) ^ 2.0 + (m.wheel.Wheel.r[2] - m.wheel.Rollers[1].r[2]) ^ 2.0 + (m.wheel.Wheel.r[3] - m.wheel.Rollers[1].r[3]) ^ 2.0);
  m.wheel.Contacts[2].n1k[1] = m.wheel.Wheel.T[1,3];
  m.wheel.Contacts[2].n1k[2] = m.wheel.Wheel.T[2,3];
  m.wheel.Contacts[2].n1k[3] = m.wheel.Wheel.T[3,3];
  m.wheel.Contacts[2].rho[1] = (m.wheel.Wheel.r[1] - m.wheel.Rollers[2].r[1]) / sqrt((m.wheel.Wheel.r[1] - m.wheel.Rollers[2].r[1]) ^ 2.0 + (m.wheel.Wheel.r[2] - m.wheel.Rollers[2].r[2]) ^ 2.0 + (m.wheel.Wheel.r[3] - m.wheel.Rollers[2].r[3]) ^ 2.0);
  m.wheel.Contacts[2].rho[2] = (m.wheel.Wheel.r[2] - m.wheel.Rollers[2].r[2]) / sqrt((m.wheel.Wheel.r[1] - m.wheel.Rollers[2].r[1]) ^ 2.0 + (m.wheel.Wheel.r[2] - m.wheel.Rollers[2].r[2]) ^ 2.0 + (m.wheel.Wheel.r[3] - m.wheel.Rollers[2].r[3]) ^ 2.0);
  m.wheel.Contacts[2].rho[3] = (m.wheel.Wheel.r[3] - m.wheel.Rollers[2].r[3]) / sqrt((m.wheel.Wheel.r[1] - m.wheel.Rollers[2].r[1]) ^ 2.0 + (m.wheel.Wheel.r[2] - m.wheel.Rollers[2].r[2]) ^ 2.0 + (m.wheel.Wheel.r[3] - m.wheel.Rollers[2].r[3]) ^ 2.0);
  m.wheel.InPortF.P[1] = m.wheel.OutPortK.r[1];
  m.wheel.InPortF.P[2] = m.wheel.OutPortK.r[2];
  m.wheel.InPortF.P[3] = m.wheel.OutPortK.r[3];
  m.wheel.InPortF.F[1] = 0.0;
  m.wheel.InPortF.F[2] = 0.0;
  m.wheel.InPortF.F[3] = 0.0;
  m.wheel.InPortF.M[1] = m.wheel.OutPortK.T[1,1] * m.torque;
  m.wheel.InPortF.M[2] = m.wheel.OutPortK.T[2,1] * m.torque;
  m.wheel.InPortF.M[3] = m.wheel.OutPortK.T[3,1] * m.torque;
  m.omegaNaklon = m.wheel.OutPortK.omega[1] * m.wheel.OutPortK.T[1,1] + m.wheel.OutPortK.omega[2] * m.wheel.OutPortK.T[2,1] + m.wheel.OutPortK.omega[3] * m.wheel.OutPortK.T[3,1];
  der(m.omegaNaklon) = m.epsilonNaklon;
  m.epsilonNaklon = 0.0;
  when time == 1.0 then
    assert(true, \"zero should be zero, was: 0\");
  end when;
  m.wheel.Contacts[1].InPortA.T[1,1] = m.wheel.Contacts[2].InPortA.T[1,1];
  m.wheel.Contacts[1].InPortA.T[1,1] = m.wheel.InPortK.T[1,1];
  m.wheel.Contacts[1].InPortA.T[1,2] = m.wheel.Contacts[2].InPortA.T[1,2];
  m.wheel.Contacts[1].InPortA.T[1,2] = m.wheel.InPortK.T[1,2];
  m.wheel.Contacts[1].InPortA.T[1,3] = m.wheel.Contacts[2].InPortA.T[1,3];
  m.wheel.Contacts[1].InPortA.T[1,3] = m.wheel.InPortK.T[1,3];
  m.wheel.Contacts[1].InPortA.T[2,1] = m.wheel.Contacts[2].InPortA.T[2,1];
  m.wheel.Contacts[1].InPortA.T[2,1] = m.wheel.InPortK.T[2,1];
  m.wheel.Contacts[1].InPortA.T[2,2] = m.wheel.Contacts[2].InPortA.T[2,2];
  m.wheel.Contacts[1].InPortA.T[2,2] = m.wheel.InPortK.T[2,2];
  m.wheel.Contacts[1].InPortA.T[2,3] = m.wheel.Contacts[2].InPortA.T[2,3];
  m.wheel.Contacts[1].InPortA.T[2,3] = m.wheel.InPortK.T[2,3];
  m.wheel.Contacts[1].InPortA.T[3,1] = m.wheel.Contacts[2].InPortA.T[3,1];
  m.wheel.Contacts[1].InPortA.T[3,1] = m.wheel.InPortK.T[3,1];
  m.wheel.Contacts[1].InPortA.T[3,2] = m.wheel.Contacts[2].InPortA.T[3,2];
  m.wheel.Contacts[1].InPortA.T[3,2] = m.wheel.InPortK.T[3,2];
  m.wheel.Contacts[1].InPortA.T[3,3] = m.wheel.Contacts[2].InPortA.T[3,3];
  m.wheel.Contacts[1].InPortA.T[3,3] = m.wheel.InPortK.T[3,3];
  m.wheel.Contacts[1].InPortA.a[1] = m.wheel.Contacts[2].InPortA.a[1];
  m.wheel.Contacts[1].InPortA.a[1] = m.wheel.InPortK.a[1];
  m.wheel.Contacts[1].InPortA.a[2] = m.wheel.Contacts[2].InPortA.a[2];
  m.wheel.Contacts[1].InPortA.a[2] = m.wheel.InPortK.a[2];
  m.wheel.Contacts[1].InPortA.a[3] = m.wheel.Contacts[2].InPortA.a[3];
  m.wheel.Contacts[1].InPortA.a[3] = m.wheel.InPortK.a[3];
  m.wheel.Contacts[1].InPortA.epsilon[1] = m.wheel.Contacts[2].InPortA.epsilon[1];
  m.wheel.Contacts[1].InPortA.epsilon[1] = m.wheel.InPortK.epsilon[1];
  m.wheel.Contacts[1].InPortA.epsilon[2] = m.wheel.Contacts[2].InPortA.epsilon[2];
  m.wheel.Contacts[1].InPortA.epsilon[2] = m.wheel.InPortK.epsilon[2];
  m.wheel.Contacts[1].InPortA.epsilon[3] = m.wheel.Contacts[2].InPortA.epsilon[3];
  m.wheel.Contacts[1].InPortA.epsilon[3] = m.wheel.InPortK.epsilon[3];
  m.wheel.Contacts[1].InPortA.omega[1] = m.wheel.Contacts[2].InPortA.omega[1];
  m.wheel.Contacts[1].InPortA.omega[1] = m.wheel.InPortK.omega[1];
  m.wheel.Contacts[1].InPortA.omega[2] = m.wheel.Contacts[2].InPortA.omega[2];
  m.wheel.Contacts[1].InPortA.omega[2] = m.wheel.InPortK.omega[2];
  m.wheel.Contacts[1].InPortA.omega[3] = m.wheel.Contacts[2].InPortA.omega[3];
  m.wheel.Contacts[1].InPortA.omega[3] = m.wheel.InPortK.omega[3];
  m.wheel.Contacts[1].InPortA.r[1] = m.wheel.Contacts[2].InPortA.r[1];
  m.wheel.Contacts[1].InPortA.r[1] = m.wheel.InPortK.r[1];
  m.wheel.Contacts[1].InPortA.r[2] = m.wheel.Contacts[2].InPortA.r[2];
  m.wheel.Contacts[1].InPortA.r[2] = m.wheel.InPortK.r[2];
  m.wheel.Contacts[1].InPortA.r[3] = m.wheel.Contacts[2].InPortA.r[3];
  m.wheel.Contacts[1].InPortA.r[3] = m.wheel.InPortK.r[3];
  m.wheel.Contacts[1].InPortA.v[1] = m.wheel.Contacts[2].InPortA.v[1];
  m.wheel.Contacts[1].InPortA.v[1] = m.wheel.InPortK.v[1];
  m.wheel.Contacts[1].InPortA.v[2] = m.wheel.Contacts[2].InPortA.v[2];
  m.wheel.Contacts[1].InPortA.v[2] = m.wheel.InPortK.v[2];
  m.wheel.Contacts[1].InPortA.v[3] = m.wheel.Contacts[2].InPortA.v[3];
  m.wheel.Contacts[1].InPortA.v[3] = m.wheel.InPortK.v[3];
  m.wheel.Contacts[1].InPortB.T[1,1] = m.wheel.Joints[1].InPortA.T[1,1];
  m.wheel.Contacts[1].InPortB.T[1,1] = m.wheel.Rollers[1].OutPort.T[1,1];
  m.wheel.Contacts[1].InPortB.T[1,2] = m.wheel.Joints[1].InPortA.T[1,2];
  m.wheel.Contacts[1].InPortB.T[1,2] = m.wheel.Rollers[1].OutPort.T[1,2];
  m.wheel.Contacts[1].InPortB.T[1,3] = m.wheel.Joints[1].InPortA.T[1,3];
  m.wheel.Contacts[1].InPortB.T[1,3] = m.wheel.Rollers[1].OutPort.T[1,3];
  m.wheel.Contacts[1].InPortB.T[2,1] = m.wheel.Joints[1].InPortA.T[2,1];
  m.wheel.Contacts[1].InPortB.T[2,1] = m.wheel.Rollers[1].OutPort.T[2,1];
  m.wheel.Contacts[1].InPortB.T[2,2] = m.wheel.Joints[1].InPortA.T[2,2];
  m.wheel.Contacts[1].InPortB.T[2,2] = m.wheel.Rollers[1].OutPort.T[2,2];
  m.wheel.Contacts[1].InPortB.T[2,3] = m.wheel.Joints[1].InPortA.T[2,3];
  m.wheel.Contacts[1].InPortB.T[2,3] = m.wheel.Rollers[1].OutPort.T[2,3];
  m.wheel.Contacts[1].InPortB.T[3,1] = m.wheel.Joints[1].InPortA.T[3,1];
  m.wheel.Contacts[1].InPortB.T[3,1] = m.wheel.Rollers[1].OutPort.T[3,1];
  m.wheel.Contacts[1].InPortB.T[3,2] = m.wheel.Joints[1].InPortA.T[3,2];
  m.wheel.Contacts[1].InPortB.T[3,2] = m.wheel.Rollers[1].OutPort.T[3,2];
  m.wheel.Contacts[1].InPortB.T[3,3] = m.wheel.Joints[1].InPortA.T[3,3];
  m.wheel.Contacts[1].InPortB.T[3,3] = m.wheel.Rollers[1].OutPort.T[3,3];
  m.wheel.Contacts[1].InPortB.a[1] = m.wheel.Joints[1].InPortA.a[1];
  m.wheel.Contacts[1].InPortB.a[1] = m.wheel.Rollers[1].OutPort.a[1];
  m.wheel.Contacts[1].InPortB.a[2] = m.wheel.Joints[1].InPortA.a[2];
  m.wheel.Contacts[1].InPortB.a[2] = m.wheel.Rollers[1].OutPort.a[2];
  m.wheel.Contacts[1].InPortB.a[3] = m.wheel.Joints[1].InPortA.a[3];
  m.wheel.Contacts[1].InPortB.a[3] = m.wheel.Rollers[1].OutPort.a[3];
  m.wheel.Contacts[1].InPortB.epsilon[1] = m.wheel.Joints[1].InPortA.epsilon[1];
  m.wheel.Contacts[1].InPortB.epsilon[1] = m.wheel.Rollers[1].OutPort.epsilon[1];
  m.wheel.Contacts[1].InPortB.epsilon[2] = m.wheel.Joints[1].InPortA.epsilon[2];
  m.wheel.Contacts[1].InPortB.epsilon[2] = m.wheel.Rollers[1].OutPort.epsilon[2];
  m.wheel.Contacts[1].InPortB.epsilon[3] = m.wheel.Joints[1].InPortA.epsilon[3];
  m.wheel.Contacts[1].InPortB.epsilon[3] = m.wheel.Rollers[1].OutPort.epsilon[3];
  m.wheel.Contacts[1].InPortB.omega[1] = m.wheel.Joints[1].InPortA.omega[1];
  m.wheel.Contacts[1].InPortB.omega[1] = m.wheel.Rollers[1].OutPort.omega[1];
  m.wheel.Contacts[1].InPortB.omega[2] = m.wheel.Joints[1].InPortA.omega[2];
  m.wheel.Contacts[1].InPortB.omega[2] = m.wheel.Rollers[1].OutPort.omega[2];
  m.wheel.Contacts[1].InPortB.omega[3] = m.wheel.Joints[1].InPortA.omega[3];
  m.wheel.Contacts[1].InPortB.omega[3] = m.wheel.Rollers[1].OutPort.omega[3];
  m.wheel.Contacts[1].InPortB.r[1] = m.wheel.Joints[1].InPortA.r[1];
  m.wheel.Contacts[1].InPortB.r[1] = m.wheel.Rollers[1].OutPort.r[1];
  m.wheel.Contacts[1].InPortB.r[2] = m.wheel.Joints[1].InPortA.r[2];
  m.wheel.Contacts[1].InPortB.r[2] = m.wheel.Rollers[1].OutPort.r[2];
  m.wheel.Contacts[1].InPortB.r[3] = m.wheel.Joints[1].InPortA.r[3];
  m.wheel.Contacts[1].InPortB.r[3] = m.wheel.Rollers[1].OutPort.r[3];
  m.wheel.Contacts[1].InPortB.v[1] = m.wheel.Joints[1].InPortA.v[1];
  m.wheel.Contacts[1].InPortB.v[1] = m.wheel.Rollers[1].OutPort.v[1];
  m.wheel.Contacts[1].InPortB.v[2] = m.wheel.Joints[1].InPortA.v[2];
  m.wheel.Contacts[1].InPortB.v[2] = m.wheel.Rollers[1].OutPort.v[2];
  m.wheel.Contacts[1].InPortB.v[3] = m.wheel.Joints[1].InPortA.v[3];
  m.wheel.Contacts[1].InPortB.v[3] = m.wheel.Rollers[1].OutPort.v[3];
  m.wheel.Contacts[1].OutPortB.F[1] = m.wheel.Rollers[1].InPorts[1].F[1];
  m.wheel.Contacts[1].OutPortB.F[2] = m.wheel.Rollers[1].InPorts[1].F[2];
  m.wheel.Contacts[1].OutPortB.F[3] = m.wheel.Rollers[1].InPorts[1].F[3];
  m.wheel.Contacts[1].OutPortB.M[1] = m.wheel.Rollers[1].InPorts[1].M[1];
  m.wheel.Contacts[1].OutPortB.M[2] = m.wheel.Rollers[1].InPorts[1].M[2];
  m.wheel.Contacts[1].OutPortB.M[3] = m.wheel.Rollers[1].InPorts[1].M[3];
  m.wheel.Contacts[1].OutPortB.P[1] = m.wheel.Rollers[1].InPorts[1].P[1];
  m.wheel.Contacts[1].OutPortB.P[2] = m.wheel.Rollers[1].InPorts[1].P[2];
  m.wheel.Contacts[1].OutPortB.P[3] = m.wheel.Rollers[1].InPorts[1].P[3];
  m.wheel.Contacts[2].InPortB.T[1,1] = m.wheel.Joints[2].InPortA.T[1,1];
  m.wheel.Contacts[2].InPortB.T[1,1] = m.wheel.Rollers[2].OutPort.T[1,1];
  m.wheel.Contacts[2].InPortB.T[1,2] = m.wheel.Joints[2].InPortA.T[1,2];
  m.wheel.Contacts[2].InPortB.T[1,2] = m.wheel.Rollers[2].OutPort.T[1,2];
  m.wheel.Contacts[2].InPortB.T[1,3] = m.wheel.Joints[2].InPortA.T[1,3];
  m.wheel.Contacts[2].InPortB.T[1,3] = m.wheel.Rollers[2].OutPort.T[1,3];
  m.wheel.Contacts[2].InPortB.T[2,1] = m.wheel.Joints[2].InPortA.T[2,1];
  m.wheel.Contacts[2].InPortB.T[2,1] = m.wheel.Rollers[2].OutPort.T[2,1];
  m.wheel.Contacts[2].InPortB.T[2,2] = m.wheel.Joints[2].InPortA.T[2,2];
  m.wheel.Contacts[2].InPortB.T[2,2] = m.wheel.Rollers[2].OutPort.T[2,2];
  m.wheel.Contacts[2].InPortB.T[2,3] = m.wheel.Joints[2].InPortA.T[2,3];
  m.wheel.Contacts[2].InPortB.T[2,3] = m.wheel.Rollers[2].OutPort.T[2,3];
  m.wheel.Contacts[2].InPortB.T[3,1] = m.wheel.Joints[2].InPortA.T[3,1];
  m.wheel.Contacts[2].InPortB.T[3,1] = m.wheel.Rollers[2].OutPort.T[3,1];
  m.wheel.Contacts[2].InPortB.T[3,2] = m.wheel.Joints[2].InPortA.T[3,2];
  m.wheel.Contacts[2].InPortB.T[3,2] = m.wheel.Rollers[2].OutPort.T[3,2];
  m.wheel.Contacts[2].InPortB.T[3,3] = m.wheel.Joints[2].InPortA.T[3,3];
  m.wheel.Contacts[2].InPortB.T[3,3] = m.wheel.Rollers[2].OutPort.T[3,3];
  m.wheel.Contacts[2].InPortB.a[1] = m.wheel.Joints[2].InPortA.a[1];
  m.wheel.Contacts[2].InPortB.a[1] = m.wheel.Rollers[2].OutPort.a[1];
  m.wheel.Contacts[2].InPortB.a[2] = m.wheel.Joints[2].InPortA.a[2];
  m.wheel.Contacts[2].InPortB.a[2] = m.wheel.Rollers[2].OutPort.a[2];
  m.wheel.Contacts[2].InPortB.a[3] = m.wheel.Joints[2].InPortA.a[3];
  m.wheel.Contacts[2].InPortB.a[3] = m.wheel.Rollers[2].OutPort.a[3];
  m.wheel.Contacts[2].InPortB.epsilon[1] = m.wheel.Joints[2].InPortA.epsilon[1];
  m.wheel.Contacts[2].InPortB.epsilon[1] = m.wheel.Rollers[2].OutPort.epsilon[1];
  m.wheel.Contacts[2].InPortB.epsilon[2] = m.wheel.Joints[2].InPortA.epsilon[2];
  m.wheel.Contacts[2].InPortB.epsilon[2] = m.wheel.Rollers[2].OutPort.epsilon[2];
  m.wheel.Contacts[2].InPortB.epsilon[3] = m.wheel.Joints[2].InPortA.epsilon[3];
  m.wheel.Contacts[2].InPortB.epsilon[3] = m.wheel.Rollers[2].OutPort.epsilon[3];
  m.wheel.Contacts[2].InPortB.omega[1] = m.wheel.Joints[2].InPortA.omega[1];
  m.wheel.Contacts[2].InPortB.omega[1] = m.wheel.Rollers[2].OutPort.omega[1];
  m.wheel.Contacts[2].InPortB.omega[2] = m.wheel.Joints[2].InPortA.omega[2];
  m.wheel.Contacts[2].InPortB.omega[2] = m.wheel.Rollers[2].OutPort.omega[2];
  m.wheel.Contacts[2].InPortB.omega[3] = m.wheel.Joints[2].InPortA.omega[3];
  m.wheel.Contacts[2].InPortB.omega[3] = m.wheel.Rollers[2].OutPort.omega[3];
  m.wheel.Contacts[2].InPortB.r[1] = m.wheel.Joints[2].InPortA.r[1];
  m.wheel.Contacts[2].InPortB.r[1] = m.wheel.Rollers[2].OutPort.r[1];
  m.wheel.Contacts[2].InPortB.r[2] = m.wheel.Joints[2].InPortA.r[2];
  m.wheel.Contacts[2].InPortB.r[2] = m.wheel.Rollers[2].OutPort.r[2];
  m.wheel.Contacts[2].InPortB.r[3] = m.wheel.Joints[2].InPortA.r[3];
  m.wheel.Contacts[2].InPortB.r[3] = m.wheel.Rollers[2].OutPort.r[3];
  m.wheel.Contacts[2].InPortB.v[1] = m.wheel.Joints[2].InPortA.v[1];
  m.wheel.Contacts[2].InPortB.v[1] = m.wheel.Rollers[2].OutPort.v[1];
  m.wheel.Contacts[2].InPortB.v[2] = m.wheel.Joints[2].InPortA.v[2];
  m.wheel.Contacts[2].InPortB.v[2] = m.wheel.Rollers[2].OutPort.v[2];
  m.wheel.Contacts[2].InPortB.v[3] = m.wheel.Joints[2].InPortA.v[3];
  m.wheel.Contacts[2].InPortB.v[3] = m.wheel.Rollers[2].OutPort.v[3];
  m.wheel.Contacts[2].OutPortB.F[1] = m.wheel.Rollers[2].InPorts[1].F[1];
  m.wheel.Contacts[2].OutPortB.F[2] = m.wheel.Rollers[2].InPorts[1].F[2];
  m.wheel.Contacts[2].OutPortB.F[3] = m.wheel.Rollers[2].InPorts[1].F[3];
  m.wheel.Contacts[2].OutPortB.M[1] = m.wheel.Rollers[2].InPorts[1].M[1];
  m.wheel.Contacts[2].OutPortB.M[2] = m.wheel.Rollers[2].InPorts[1].M[2];
  m.wheel.Contacts[2].OutPortB.M[3] = m.wheel.Rollers[2].InPorts[1].M[3];
  m.wheel.Contacts[2].OutPortB.P[1] = m.wheel.Rollers[2].InPorts[1].P[1];
  m.wheel.Contacts[2].OutPortB.P[2] = m.wheel.Rollers[2].InPorts[1].P[2];
  m.wheel.Contacts[2].OutPortB.P[3] = m.wheel.Rollers[2].InPorts[1].P[3];
  m.wheel.Joints[1].OutPortA.F[1] = m.wheel.Rollers[1].InPorts[2].F[1];
  m.wheel.Joints[1].OutPortA.F[2] = m.wheel.Rollers[1].InPorts[2].F[2];
  m.wheel.Joints[1].OutPortA.F[3] = m.wheel.Rollers[1].InPorts[2].F[3];
  m.wheel.Joints[1].OutPortA.M[1] = m.wheel.Rollers[1].InPorts[2].M[1];
  m.wheel.Joints[1].OutPortA.M[2] = m.wheel.Rollers[1].InPorts[2].M[2];
  m.wheel.Joints[1].OutPortA.M[3] = m.wheel.Rollers[1].InPorts[2].M[3];
  m.wheel.Joints[1].OutPortA.P[1] = m.wheel.Rollers[1].InPorts[2].P[1];
  m.wheel.Joints[1].OutPortA.P[2] = m.wheel.Rollers[1].InPorts[2].P[2];
  m.wheel.Joints[1].OutPortA.P[3] = m.wheel.Rollers[1].InPorts[2].P[3];
  m.wheel.Joints[1].OutPortB.F[1] = m.wheel.Wheel.InPorts[2].F[1];
  m.wheel.Joints[1].OutPortB.F[2] = m.wheel.Wheel.InPorts[2].F[2];
  m.wheel.Joints[1].OutPortB.F[3] = m.wheel.Wheel.InPorts[2].F[3];
  m.wheel.Joints[1].OutPortB.M[1] = m.wheel.Wheel.InPorts[2].M[1];
  m.wheel.Joints[1].OutPortB.M[2] = m.wheel.Wheel.InPorts[2].M[2];
  m.wheel.Joints[1].OutPortB.M[3] = m.wheel.Wheel.InPorts[2].M[3];
  m.wheel.Joints[1].OutPortB.P[1] = m.wheel.Wheel.InPorts[2].P[1];
  m.wheel.Joints[1].OutPortB.P[2] = m.wheel.Wheel.InPorts[2].P[2];
  m.wheel.Joints[1].OutPortB.P[3] = m.wheel.Wheel.InPorts[2].P[3];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.Joints[2].InPortB.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.OutPortK.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,1] = m.wheel.Wheel.OutPort.T[1,1];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.Joints[2].InPortB.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.OutPortK.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,2] = m.wheel.Wheel.OutPort.T[1,2];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.Joints[2].InPortB.T[1,3];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.OutPortK.T[1,3];
  m.wheel.Joints[1].InPortB.T[1,3] = m.wheel.Wheel.OutPort.T[1,3];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.Joints[2].InPortB.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.OutPortK.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,1] = m.wheel.Wheel.OutPort.T[2,1];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.Joints[2].InPortB.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.OutPortK.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,2] = m.wheel.Wheel.OutPort.T[2,2];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.Joints[2].InPortB.T[2,3];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.OutPortK.T[2,3];
  m.wheel.Joints[1].InPortB.T[2,3] = m.wheel.Wheel.OutPort.T[2,3];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.Joints[2].InPortB.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.OutPortK.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,1] = m.wheel.Wheel.OutPort.T[3,1];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.Joints[2].InPortB.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.OutPortK.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,2] = m.wheel.Wheel.OutPort.T[3,2];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.Joints[2].InPortB.T[3,3];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.OutPortK.T[3,3];
  m.wheel.Joints[1].InPortB.T[3,3] = m.wheel.Wheel.OutPort.T[3,3];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.Joints[2].InPortB.a[1];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.OutPortK.a[1];
  m.wheel.Joints[1].InPortB.a[1] = m.wheel.Wheel.OutPort.a[1];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.Joints[2].InPortB.a[2];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.OutPortK.a[2];
  m.wheel.Joints[1].InPortB.a[2] = m.wheel.Wheel.OutPort.a[2];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.Joints[2].InPortB.a[3];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.OutPortK.a[3];
  m.wheel.Joints[1].InPortB.a[3] = m.wheel.Wheel.OutPort.a[3];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.Joints[2].InPortB.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.OutPortK.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[1] = m.wheel.Wheel.OutPort.epsilon[1];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.Joints[2].InPortB.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.OutPortK.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[2] = m.wheel.Wheel.OutPort.epsilon[2];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.Joints[2].InPortB.epsilon[3];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.OutPortK.epsilon[3];
  m.wheel.Joints[1].InPortB.epsilon[3] = m.wheel.Wheel.OutPort.epsilon[3];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.Joints[2].InPortB.omega[1];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.OutPortK.omega[1];
  m.wheel.Joints[1].InPortB.omega[1] = m.wheel.Wheel.OutPort.omega[1];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.Joints[2].InPortB.omega[2];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.OutPortK.omega[2];
  m.wheel.Joints[1].InPortB.omega[2] = m.wheel.Wheel.OutPort.omega[2];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.Joints[2].InPortB.omega[3];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.OutPortK.omega[3];
  m.wheel.Joints[1].InPortB.omega[3] = m.wheel.Wheel.OutPort.omega[3];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.Joints[2].InPortB.r[1];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.OutPortK.r[1];
  m.wheel.Joints[1].InPortB.r[1] = m.wheel.Wheel.OutPort.r[1];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.Joints[2].InPortB.r[2];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.OutPortK.r[2];
  m.wheel.Joints[1].InPortB.r[2] = m.wheel.Wheel.OutPort.r[2];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.Joints[2].InPortB.r[3];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.OutPortK.r[3];
  m.wheel.Joints[1].InPortB.r[3] = m.wheel.Wheel.OutPort.r[3];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.Joints[2].InPortB.v[1];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.OutPortK.v[1];
  m.wheel.Joints[1].InPortB.v[1] = m.wheel.Wheel.OutPort.v[1];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.Joints[2].InPortB.v[2];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.OutPortK.v[2];
  m.wheel.Joints[1].InPortB.v[2] = m.wheel.Wheel.OutPort.v[2];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.Joints[2].InPortB.v[3];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.OutPortK.v[3];
  m.wheel.Joints[1].InPortB.v[3] = m.wheel.Wheel.OutPort.v[3];
  m.wheel.Joints[2].OutPortA.F[1] = m.wheel.Rollers[2].InPorts[2].F[1];
  m.wheel.Joints[2].OutPortA.F[2] = m.wheel.Rollers[2].InPorts[2].F[2];
  m.wheel.Joints[2].OutPortA.F[3] = m.wheel.Rollers[2].InPorts[2].F[3];
  m.wheel.Joints[2].OutPortA.M[1] = m.wheel.Rollers[2].InPorts[2].M[1];
  m.wheel.Joints[2].OutPortA.M[2] = m.wheel.Rollers[2].InPorts[2].M[2];
  m.wheel.Joints[2].OutPortA.M[3] = m.wheel.Rollers[2].InPorts[2].M[3